import { fabric } from 'fabric';import { ViewController } from '../../../../../src/core/ViewController';import { SCREEN_CONFIG } from './prefab/Const';import { bg1, bg2, bg3, bg4, bg5 } from './prefab/Backgroud';import { Hole } from './prefab/Hole';import { Hammer } from './prefab/Hammer';import { TimelineMax, TweenMax } from 'gsap';import { Subject } from './observer/Subject';import { ViewModel } from '../viewModel';export default class StoryCanvas {  myCanvas: fabric.Canvas;  zoom = 1;  subject: Subject;  hammer: Hammer;  hole: Hole;  hammerGroup: fabric.Group;  correctCount = 0;  isPauseAnimation = false;  hitCount: number;  constructor() {    let width;    let height;    const backgroundtItem = document.getElementById('backgroundDiv');    //初始化适配方案，按比例设置canvas宽高    if (SCREEN_CONFIG.ratio > SCREEN_CONFIG.uiRatio) {      console.log('宽填不满');      height = SCREEN_CONFIG.windowHeight;      width =        (SCREEN_CONFIG.uiRatioWidth * height) / SCREEN_CONFIG.uiRatioHeight;      this.zoom = height / SCREEN_CONFIG.uiHeight;      if (width < SCREEN_CONFIG.windowWidth) {        (backgroundtItem.children[0] as any).style.height =  (bg1().height * this.zoom) + 'px';        (backgroundtItem.children[1] as any).style.height =  (bg2().height * this.zoom) + 'px';        (backgroundtItem.children[2] as any).style.height =  (bg3().height * this.zoom) + 'px';        (backgroundtItem.children[3] as any).style.height =  (bg4().height * this.zoom) + 'px';        (backgroundtItem.children[4] as any).style.height =  (bg5().height * this.zoom) + 'px';      }    } else {      console.log('高填不满');      width = SCREEN_CONFIG.windowWidth;      height =        (SCREEN_CONFIG.uiRatioHeight * width) / SCREEN_CONFIG.uiRatioWidth;      if (height < window.innerHeight) {        height = window.innerHeight;      }      this.zoom = width / SCREEN_CONFIG.uiWidth;    }    const myCanvasEle = document.getElementById(      'storyCanvas'    ) as HTMLCanvasElement;    myCanvasEle.width = width;    myCanvasEle.height = height;    this.myCanvas = new fabric.Canvas('storyCanvas');    this.myCanvas.selection = false;    (this.myCanvas as any).wrapperEl.style.zIndex = 1;    this.initResource();    this.initCanvasScale();    this.hitCount = 0;    (window as any).stroyCanvas = this;  }  initCanvasScale() {    this.myCanvas.setZoom(this.zoom);  }  async initResource() {    const bg_one    = bg1();    const bg_two    = bg2();    const bg_three  = bg3();    const bg_four   = bg4();    const bg_five   = bg5();    bg_one.set('width', SCREEN_CONFIG.windowWidth / this.zoom);    bg_one.set('height', SCREEN_CONFIG.windowHeight / this.zoom);    bg_two.set('width', SCREEN_CONFIG.windowWidth / this.zoom);    bg_two.set('height', SCREEN_CONFIG.windowHeight / this.zoom);    bg_three.set('width', SCREEN_CONFIG.windowWidth / this.zoom);    bg_three.set('height', SCREEN_CONFIG.windowHeight / this.zoom);    bg_four.set('width', SCREEN_CONFIG.windowWidth / this.zoom);    bg_four.set('height', SCREEN_CONFIG.windowHeight / this.zoom);    bg_five.set('width', SCREEN_CONFIG.windowWidth / this.zoom);    bg_five.set('height', SCREEN_CONFIG.windowHeight / this.zoom);    this.myCanvas.add(bg_one);    this.myCanvas.add(bg_two);    this.myCanvas.add(bg_three);    this.myCanvas.add(bg_four);    //114 177    this.subject = new Subject();    const rows = 3;    const cols = 4;    //地鼠宽度    const dsWidth = 222;    //每行地鼠间距    const topPos = 166;    //第一行距离顶部间距    const firstPadding = 44;    const animationGroups = [];    const holeArray = [];    //初始化地鼠    let no = 0;    for (let i = 0; i < rows; i++) {      const groupArry = [];      for (let j = 0; j < cols; j++) {        this.hole = new Hole(          this.subject,          this.myCanvas,          { left: j * dsWidth, top: 0 },          ++no        );        const group1 = await this.hole.initStaticHole();        holeArray.push(this.hole);        animationGroups.push(this.hole.dsFabricObj);        groupArry.push(group1);      }      const option = {        name: 'parentGroup',        originX: 'center',        subTargetCheck: true,        perPixelTargetFind: true,        left: this.myCanvas.getWidth() / 2 / this.zoom,        width: this.myCanvas.getWidth(),        top: topPos * i + firstPadding,        selectable: false,        targetFindTolerance: 2      };      const holeGroup = new fabric.Group(groupArry, option);      holeGroup.set('width', SCREEN_CONFIG.windowWidth / this.zoom);      this.myCanvas.add(holeGroup);    }    //最后覆盖一层响应点击事件    for ( let k = 0 ; k < holeArray.length; k++) {      console.log('hold group');      holeArray[k].initEventArea();    }    this.hammer = new Hammer(this.subject);    //初始化锤子    this.hammerGroup = await this.hammer.initHammerGroup();    this.myCanvas.add(this.hammerGroup);    this.myCanvas.on('mouse:down', (e) => {    });    this.myCanvas.add(bg_five);    this.myCanvas.renderAll();    ViewController.getInstance().hideLoading();    this.initElectronAnimation();    setTimeout(() => {      (ViewController.getInstance().viewHandler        .viewModel as ViewModel).showTip = false;      this.subject.generateTopic();    }, 3000);  }  intersect(point: any, obj: any) {    const objTransformMatrix = obj.calcTransformMatrix();    const beginPos = {      x: objTransformMatrix[4],      y: objTransformMatrix[5]    };    const endPos = {      x: beginPos.x + obj.width * obj.scaleX,      y: beginPos.y + obj.height * obj.scaleY    };    return (      point.offsetX >= beginPos.x &&      point.offsetY >= beginPos.y &&      point.offsetX <= endPos.x &&      point.offsetY <= endPos.y    );  }  async initElectronAnimation() {    const fps = 15;    let now;    let then = Date.now();    const interval = 1000 / fps;    let delta;    const animate = () => {      fabric.util.requestAnimFrame(animate);      now = Date.now();      delta = now - then;      if (delta > interval) {        then = now - (delta % interval);        //do animation business      }      this.myCanvas.renderAll();    };    animate();  }  initHammerAnimation(param: any) {    const initParam = {      left: this.hammerGroup.left,      top: this.hammerGroup.top,      angle: this.hammerGroup.angle,    };    const hammerLineAnim = new TweenMax(initParam, 0.1, {      left: param.left,      top: param.top,      angle: -90,      onUpdate: () => {        this.hammerGroup.left = initParam.left;        this.hammerGroup.top = initParam.top;        this.hammerGroup.angle = initParam.angle;        this.myCanvas.renderAll();      },      onCompleted: () => {        setTimeout(() => {          hammerLineAnim.reverse();        }, 2000);      }    });    hammerLineAnim.play();  }  //记录答对总数  recordCorrect(messeage: any) {    if (messeage.hitNo === messeage.correctNo) {      //正确打中      this.correctCount++;    } else {      //记录答题数    }  }  currentProgress() {  }  //评级（星）  evaluationStar() {    /*    *一星：（1-6）    * 二星：(7-12)    * 三星：（13-15）    * */  }  //暂停或恢复动画  pauseAndResumeAnimation(isPause: boolean) {    return isPause;  }  reset() {}}