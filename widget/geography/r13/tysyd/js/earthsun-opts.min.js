var GL = GL || {}, pdWGL = pdWGL || {};
!function () {
    function t(t, e) {
        var i = e.x - t.x, r = e.y - t.y;
        return Math.abs(i) < 1e-6 ? Math.abs(r) < 1e-6 ? 0 : r < 0 ? -90 : 90 : Math.atan2(r, i) * D
    }

    function e(t, e) {
        var i = e.z - t.z;
        if (Math.abs(i) < 1e-6) return 0;
        var r = Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));
        return Math.abs(r) < 1e-6 ? i < 0 ? -90 : 90 : Math.atan2(i, r) * D
    }

    function i(t) {
        var e = Object.prototype.toString.call(t);
        return "[object Array]" == e || "[object Float32Array]" == e
    }

    function r(t) {
        var e = Object.prototype.toString.call(t);
        return "[object Number]" == e || "[object Boolean]" == e
    }

    function a() {
        var t, e, i = new pd3D.Matrix, r = new pd3D.Matrix, a = new pd3D.Matrix, n = [], o = [], s = !1;
        M.MODELVIEW = 1 | x, M.PROJECTION = 2 | x, M.modelviewMatrix = new pd3D.Matrix, M.projectionMatrix = new pd3D.Matrix, M.getModelviewProjectionMatrix = function () {
            return s && (a = pd3D.Matrix.multiply(M.projectionMatrix, M.modelviewMatrix, a), s = !1), a
        }, M.matrixMode = function (i) {
            switch (i) {
                case M.MODELVIEW:
                    t = M.modelviewMatrix, e = o;
                    break;
                case M.PROJECTION:
                    t = M.projectionMatrix, e = n;
                    break;
                default:
                    throw new TypeError("invalid matrix mode " + i)
            }
        }, M.loadIdentity = function () {
            pd3D.Matrix.identity(t), s = !0
        }, M.loadMatrix = function (e) {
            for (var i = e.m, r = t.m, a = 0; a < 16; a++) r[a] = i[a];
            s = !0
        }, M.multMatrix = function (e) {
            M.loadMatrix(pd3D.Matrix.multiply(t, e, r))
        }, M.perspective = function (t, e, r, a) {
            M.multMatrix(pd3D.Matrix.perspective(t, e, r, a, i))
        }, M.frustum = function (t, e, r, a, n, o) {
            M.multMatrix(pd3D.Matrix.frustum(t, e, r, a, n, o, i))
        }, M.ortho = function (t, e, r, a, n, o) {
            M.multMatrix(pd3D.Matrix.ortho(t, e, r, a, n, o, i))
        }, M.scale = function (t, e, r) {
            1 == arguments.length ? pd.isNumeric(t) ? M.multMatrix(pd3D.Matrix.scale(t, t, t, i)) : Array.isArray(t) && M.multMatrix(pd3D.Matrix.scale(+t[0] || 0, +t[1] || 0, +t[2] || 0, i)) : 3 == arguments.length && M.multMatrix(pd3D.Matrix.scale(+t || 0, +e || 0, +r || 0, i))
        }, M.translate = function (t, e, r) {
            M.multMatrix(pd3D.Matrix.translate(t, e, r, i))
        }, M.rotate = function (t, e, r, a) {
            M.multMatrix(pd3D.Matrix.rotate(t, e, r, a, i))
        }, M.lookAt = function (t, e, r, a, n, o, s, l, h) {
            M.multMatrix(pd3D.Matrix.lookAt(t, e, r, a, n, o, s, l, h, i))
        }, M.pushMatrix = function () {
            e.push(Array.prototype.slice.call(t.m))
        }, M.popMatrix = function () {
            var i = e.pop();
            t = pd3D.Matrix.fromArray(i, t), s = !0
        }, M.project = function (t, e, i, r, a, n) {
            r = r || M.modelviewMatrix, a = a || M.projectionMatrix, n = n || M.getParameter(M.VIEWPORT);
            var o = a.transformPoint(r.transformPoint(new pd3D.Vector(t, e, i)));
            return new pd3D.Vector(n[0] + n[2] * (.5 * o.x + .5), n[1] + n[3] * (.5 * o.y + .5), .5 * o.z + .5)
        }, M.unproject = function (t, e, a, n, o, s) {
            n = n || M.modelviewMatrix, o = o || M.projectionMatrix, s = s || M.getParameter(M.VIEWPORT);
            var l = new pd3D.Vector((t - s[0]) / s[2] * 2 - 1, (e - s[1]) / s[3] * 2 - 1, 2 * a - 1);
            return Matrix.inverse(pd3D.Matrix.multiply(o, n, i), r).transformPoint(l)
        }, M.cleanup = function () {
            P && P.endRender()
        }, M.matrixMode(M.MODELVIEW)
    }

    function n() {
        function t(t) {
            M.onmousemove && M.onmousemove(t)
        }

        function e(t) {
            (M = d).onmousedown && M.onmousedown(t)
        }

        function i(t) {
            (M = d).onmousedrag && M.onmousedrag(t)
        }

        function r(t) {
            (M = d).onmouseup && M.onmouseup(t)
        }

        function a(t) {
            (M = d).onmousewheel && M.onmousewheel(t)
        }

        function a(t) {
            (M = d).onmousewheel && M.onmousewheel(t)
        }

        function n(t) {
            (M = d).ondoubletap && M.ondoubletap(t)
        }

        function h(t) {
            (M = d).onlongpress && M.onlongpress(t)
        }

        var d = M;
        d.frameIndex = 0, l(document, "keydown", function (t) {
            if (GL.keys.SHIFT = t.shiftKey, GL.keys.CONTROL = t.ctrlKey, GL.keys.META = t.metaKey, GL.keys.ALT = t.altKey, M.onkeydown && M.onkeydown(t), !t.altKey && !t.ctrlKey && !t.metaKey) {
                var e = o(t.keyCode);
                e && (GL.keys[e] = !0), GL.keys[t.keyCode] || GL.keyCount++, GL.keys[t.keyCode] = !0, s(t)
            }
        }), l(document, "keyup", function (t) {
            if (GL.keys.SHIFT = t.shiftKey, GL.keys.CONTROL = t.ctrlKey, GL.keys.META = t.metaKey, GL.keys.ALT = t.altKey, M.onkeyup && M.onkeyup(t), 27 == t.keyCode && GL.keyCount > 1) {
                GL.keyCount = 0;
                for (var e in GL.keys) +e > 0 && GL.keys[e] && GL.keyCount++
            }
            if (!t.altKey && !t.ctrlKey && !t.metaKey) {
                var i = o(t.keyCode);
                i && (GL.keys[i] = !1), GL.keys[t.keyCode] && GL.keyCount--, GL.keys[t.keyCode] = !1, s(t)
            }
        }), pdDOM.Interaction.makeInteractive(M.canvas, {
            onmove: t,
            onpress: e,
            ondrag: i,
            onrelease: r,
            ondoubletap: n,
            onlongpress: h,
            onscroll: a
        })
    }

    function o(t) {
        return _[t] || (t >= 65 && t <= 90 ? String.fromCharCode(t) : null)
    }

    function s(t, e) {
        t.getModifierState && (e = e || "CapsLock", GL.keys[e] = t.getModifierState(e))
    }

    function l(t, e, i) {
        t.addEventListener(e, i)
    }

    function h(t, e, i) {
        t.removeEventListener(e, i)
    }

    function d() {
        !function (t) {
            M.makeCurrent = function () {
                M = t
            }
        }(M);
        var t = !0, e = !0;
        M.setCullFace = function (i) {
            null == i && (i = t), e != i && (i ? M.enable(M.CULL_FACE) : M.disable(M.CULL_FACE), e = i)
        }, M.setCullFaceDefault = function (e) {
            arguments.length > 0 && (t = !!e, M.setCullFace())
        };
        var i = [], r = M.getParameter(M.ALIASED_LINE_WIDTH_RANGE);
        M.minLineWidth = r[0], M.maxLineWidth = r[1], M.activeLineWidth = 1, M.readActiveLineWidth = function () {
            return M.activeLineWidth = M.getParameter(M.LINE_WIDTH), M.activeLineWidth
        }, M.pushLineWidth = function (t) {
            i.push(M.activeLineWidth), i.length >= 1024 && (1024 == i.length && console.warn("WARNING: GL line width stack getting excessively large."), i.length > 2048 && i.shift()), t && t > 0 && (M.activeLineWidth = t, M.lineWidth(t))
        }, M.popLineWidth = function () {
            var t = i.length > 0 ? i.pop() : 1;
            t && t > .1 && (M.activeLineWidth = t, M.lineWidth(t))
        }, M.getCanvasLineWidthThin = function () {
            return pdDOM.devicePixelRatio < 1.25 ? .75 : pdDOM.devicePixelRatio < 2.25 ? 1.5 : 2
        }, M.getCanvasLineWidth = function () {
            return pdDOM.devicePixelRatio
        }, M.getCanvasLineWidthThick = function () {
            return pdDOM.devicePixelRatio < 1.25 ? 1.55 : pdDOM.devicePixelRatio < 2.25 ? 2.5 : 4
        }, M.getCanvasLineWidthThicker = function () {
            return pdDOM.devicePixelRatio < 1.25 ? 3 : pdDOM.devicePixelRatio < 2.25 ? 5 : 6
        }, M.frameIndex = 0, M.animationQueue = pdDOM.getGlobalAnimationQueue(), M.animate = function () {
            function t(t, i) {
                return (M = e).onupdate && (M.onupdate(t, i) || a) && (a = !1, M.frameIndex = i, M.ondraw && M.ondraw()), !1
            }

            var e = M;
            return M.animationQueue.add(t), M.animationQueue.start(), M.animationQueue
        }, M.fullscreen = function (t) {
            function e() {
                M.canvas.width = window.innerWidth - r - a, M.canvas.height = window.innerHeight - i - n, M.viewport(0, 0, M.canvas.width, M.canvas.height), M.orbitalView ? M.orbitalView.applyProjection() : !t.camera && "camera" in t || (M.matrixMode(M.PROJECTION), M.loadIdentity(), M.perspective(t.fov || 90, M.canvas.width / M.canvas.height, t.near || .1, t.far || 1e3), M.matrixMode(M.MODELVIEW)), M.onresize && M.onresize(), M.ondraw && M.ondraw()
            }

            var i = (t = t || {}).paddingTop || 0, r = t.paddingLeft || 0, a = t.paddingRight || 0,
                n = t.paddingBottom || 0;
            if (!document.body) throw"document.body doesn't exist yet (call gl.fullscreen() from window.onload() or from inside the <body> tag)";
            document.body.appendChild(M.canvas), document.body.style.overflow = "hidden", M.canvas.style.position = "absolute", M.canvas.style.left = r + "px", M.canvas.style.top = i + "px", M.canvas.style.msTouchAction = "none", M.canvas.style.touchAction = "none", l(window, "resize", e), e()
        };
        var a = !0;
        M.QUADS = 7, M.QUAD_STRIP = 8, M.HALF_FLOAT = M.HALF_FLOAT || 36193, M.update = function () {
            a = !0
        }, M.useOrbitalView = function (t) {
            M.orbitalView = new GL.OrbitalView(t)
        }, M.disableContextMenu = function (t) {
            function e(t) {
                return t.preventDefault(), t.stopPropagation(), !1
            }

            M.canvas && (t ? l(M.canvas, "contextmenu", e) : h(M.canvas, "contextmenu", e))
        }
    }

    function u(t) {
        return t in T || (T[t] = M.getExtension(t)), T[t]
    }

    function c(t, e) {
        return t = pd.toNumber(t, e), t < 0 ? e : t
    }

    function m(t, e) {
        var i, r = t.length, a = "";
        for (i = 0; i < r; ++i) t[i].vertHead && (a += t[i].vertHead);
        for (a += GL.ShaderComponent.mainFunc + GL.ShaderComponent.position.vertMain, i = 0; i < r; ++i) t[i].vertMain && (a += t[i].vertMain);
        a += GL.ShaderComponent.endFunc;
        var n = "";
        for (i = 0; i < r; ++i) t[i].fragHead && (n += t[i].fragHead);
        for (n += GL.ShaderComponent.mainFunc, i = 0; i < r; ++i) t[i].fragMain && (n += t[i].fragMain);
        if (e && e.length) for (i = 0, r = e.length; i < r; ++i) e[i].fragColor && (n += e[i].fragColor); else for (i = 0; i < r; ++i) t[i].fragColor && (n += t[i].fragColor);
        return n += GL.ShaderComponent.endFunc, new GL.Shader(a, n)
    }

    function p(t, e) {
        this._shader.uniforms({
            color: e < M.TRIANGLES ? t.defaultLineColor : t.defaultColor,
            useVertexColors: !(!t || !t.hasVertexColors)
        })
    }

    function f(t, e) {
        this._shader.uniforms({
            useTexture: !(!this._texture || !t.coords),
            color: e < M.TRIANGLES ? t.defaultLineColor : t.defaultColor,
            useVertexColors: !(!t || !t.hasVertexColors)
        })
    }

    function g() {
        return null == W && (W = new GL.Shader("varying vec4 vWorldPosition;\nvoid main() {\n    gl_Position = vWorldPosition = gl_ModelViewProjectionMatrix * gl_Vertex;\n}\n", "varying vec4 vWorldPosition;\nvoid main() {\n    float depth = vWorldPosition.z / vWorldPosition.w;\n    gl_FragColor = vec4(depth * 0.5 + 0.5);\n}\n")), W
    }

    function v(t, e, i) {
        for (var r; null !== (r = t.exec(e));) i(r)
    }

    var M, x = 305397760, y = Math.PI / 180, D = 180 / Math.PI;
    GL.version = "0.1.2", GL.keys = {}, GL.keyCount = 0;
    var w;
    GL.create = function (t) {
        var e = (t = t || {}).canvas;
        e || ((e = document.createElement("canvas")).height = t.height || 600, e.width = t.width || 800), "alpha" in t || (t.alpha = !1);
        try {
            M = e.getContext("webgl", t)
        } catch (t) {
        }
        try {
            M = M || e.getContext("experimental-webgl", t)
        } catch (t) {
        }
        if (!M) throw"WebGL is either not supported or is disabled.";
        return w = [M.TRIANGLES, M.LINES, M.POINTS], a(), n(), d(), M.enable(M.DEPTH_TEST), M.frontFace(M.CCW), M.enable(M.CULL_FACE), M.cullFace(M.BACK), M.enable(M.POLYGON_OFFSET_FILL), M.polygonOffset(1, 1), M.enable(M.BLEND), M.blendFuncSeparate(M.SRC_ALPHA, M.ONE_MINUS_SRC_ALPHA, M.ONE, M.ONE_MINUS_SRC_ALPHA), M
    };
    var _ = {
        8: "BACKSPACE",
        9: "TAB",
        13: "ENTER",
        16: "SHIFT",
        27: "ESCAPE",
        32: "SPACE",
        37: "LEFT",
        38: "UP",
        39: "RIGHT",
        40: "DOWN"
    };
    GL.OrbitalView = function (t) {
        return t = t || {}, this.defaultTarget = t.defaultTarget || new pd3D.Vector(0, 0, 0), this.defaultDistance = pd.toNumber(t.defaultDistance, 8), this.defaultAzi = pd.toNumber(t.defaultAzi, 60), this.defaultAlt = pd.toNumber(t.defaultAlt, 30), this.defaultFOV = pd.toNumber(t.defaultFOV, 45), this.zoomByDollying = pd.toBoolean(t.zoomByDollying, !1), this.animationSpeed = pd.toNumber(t.animationSpeed, 2), this.farFieldFactor = pd.toNumber(t.farFieldFactor, 2.5), this.farFieldMin = pd.toNumber(t.farFieldMin, 0), this.kbdNav = {
            active: !1,
            moveInOut: 0,
            moveLeftRight: 0,
            moveUpDown: 0,
            lookLeftRight: 0,
            lookUpDown: 0,
            slowDown: .9,
            speedUp: .03
        }, this.orbitMode = !0, this.handlePointerMove = t.handlePointerMove || null, this.handlePointerDown = t.handlePointerDown || null, this.handlePointerDrag = t.handlePointerDrag || null, this.handlePointerUp = t.handlePointerUp || null, this.callbackOnChange = t.callbackOnChange || null, this.target = new pd3D.Vector(this.defaultTarget.x, this.defaultTarget.y, this.defaultTarget.z), this.cameraDistance = this.defaultDistance, this.cameraAzi = this.defaultAzi, this.cameraAlt = this.defaultAlt, this.cameraFOV = this.defaultFOV, this.camera = new pd3D.Vector(0, this.defaultDistance, 0), this.eyePos = new pd3D.Vector(0, this.defaultDistance, 0), this.zoomFactor = 1, this.mouseWheelIncrement = 1, this.aspectRatio = M.canvas.height > 0 ? M.canvas.width / M.canvas.height : 1, this.snapGrid = pd.toNumber(t.snapGrid, 0), this.hasChanged = M.PROJECTION, this._unprojectMatrix = new pd3D.Matrix, this._unprojectViewport = [0, 0, 640, 480], this._unprojectValid = !1, this._localProjectionMatrix = null, this._localModelViewMatrix = null, this._localHUD = !1, this._zoomFactorMin = pd.toNumber(t.zoomFactorMin, .01), this._inertiaAction = 0, this._inertiaThresholdTime = 50, this._inertiaThresholdDelta = 2, this._inertiaDampingFactor = .9, this._inertiaMinimumValue = .05, this._inertiaTimeStamp = 0, this._inertiaDeltaX = 0, this._inertiaDeltaY = 0, this._inertiaZoom = 0, this._animateSourceView = null, this._animateTargetView = null, this._animating = !1, this.initialise(), this
    }, GL.OrbitalView.prototype = {
        getFieldOfViewFactor: function () {
            var t = pd.constrainTo(this.cameraFOV, .1, 160), e = .25 / (this.zoomFactor * Math.tan(.25 * t * y));
            return pd.constrainTo(e, .01, 1e4)
        }, apply: function (t) {
            var e = this.getFieldOfViewFactor();
            (t || this.hasChanged > M.MODELVIEW) && this.applyProjection(e), this._localHUD = !1, M.matrixMode(M.MODELVIEW), M.loadIdentity();
            var i = this.cameraAzi * y, r = pd.constrainTo(this.cameraAlt, -89.99, 89.99) * y,
                a = this.cameraDistance * Math.cos(r), n = a * Math.cos(i), o = a * Math.sin(i),
                s = this.cameraDistance * Math.sin(r);
            return this.camera.init(this.target.x + n * e, this.target.y + o * e, this.target.z + s * e), this.eyePos.init(this.target.x + n, this.target.y + o, this.target.z + s), M.lookAt(this.camera.x, this.camera.y, this.camera.z, this.target.x, this.target.y, this.target.z, 0, 0, 1), this.hasChanged && (this.callbackOnChange && this.callbackOnChange(this), this.hasChanged = 0), this
        }, applyProjection: function (t) {
            var e = M.canvas.width, i = M.canvas.height;
            M.matrixMode(M.PROJECTION), M.loadIdentity(), this.aspectRatio = i > 0 ? e / i : 1, this._unprojectViewport[2] = e, this._unprojectViewport[3] = i, t = pd.toNumber(t, this.getFieldOfViewFactor());
            var r = this.farFieldFactor / pd.constrainTo(this.zoomFactor, .001, 1) * this.defaultDistance,
                a = t * this.cameraDistance;
            return M.perspective(pd.constrainTo(this.cameraFOV, .1, 160), this.aspectRatio, Math.max(a - r, .0025 * this.defaultDistance), a + Math.max(r, this.farFieldMin)), this._unprojectValid = !1, M.setCullFace(), this
        }, startOverlay2D: function () {
            var t = M.canvas.width, e = M.canvas.height;
            return this._localProjectionMatrix = pd3D.Matrix.clone(M.projectionMatrix, this._localProjectionMatrix), this._localModelViewMatrix = pd3D.Matrix.clone(M.modelviewMatrix, this._localModelViewMatrix), this._localHUD = !0, M.matrixMode(M.PROJECTION), M.loadIdentity(), M.ortho(.5, t + .5, .5, e + .5, -100, 100), M.matrixMode(M.MODELVIEW), M.loadIdentity(), this
        }, endOverlay2D: function () {
            return pd3D.Matrix.clone(this._localProjectionMatrix, M.projectionMatrix), pd3D.Matrix.clone(this._localModelViewMatrix, M.modelviewMatrix), this._localHUD = !1, this
        }, copyViewDataTo: function (t, e) {
            return t || (t = {}), e || (e = this), null != e.defaultAzi && (t.defaultAzi = e.defaultAzi), null != e.defaultAlt && (t.defaultAlt = e.defaultAlt), null != e.defaultFOV && (t.defaultFOV = e.defaultFOV), null != e.defaultDistance && (t.defaultDistance = e.defaultDistance), null != e.cameraAzi && (t.cameraAzi = e.cameraAzi), null != e.cameraAlt && (t.cameraAlt = e.cameraAlt), null != e.cameraFOV && (t.cameraFOV = e.cameraFOV), null != e.cameraDistance && (t.cameraDistance = e.cameraDistance), pd.isNumeric(e.zoom) && (t.zoomFactor = e.zoom), null != e.zoomFactor && (t.zoomFactor = e.zoomFactor), null != e.farFieldFactor && (t.farFieldFactor = e.farFieldFactor), null != e.farFieldMin && (t.farFieldMin = e.farFieldMin), null != e.snapGrid && (t.snapGrid = e.snapGrid), null != e.defaultTarget && (Array.isArray(e.defaultTarget) ? t.defaultTarget = pd3D.Vector.fromArray(e.defaultTarget) : e.defaultTarget instanceof pd3D.Vector && (t.defaultTarget ? t.defaultTarget.init(e.defaultTarget) : t.defaultTarget = new pd3D.Vector(e.defaultTarget))), null != e.target && (Array.isArray(e.target) ? t.target = pd3D.Vector.fromArray(e.target) : e.target instanceof pd3D.Vector && (t.target ? t.target.init(e.target) : t.target = new pd3D.Vector(e.target))), null != e.camera && (Array.isArray(e.camera) ? t.camera = pd3D.Vector.fromArray(e.camera) : e.camera instanceof pd3D.Vector && (t.camera ? t.camera.init(e.camera) : t.camera = new pd3D.Vector(e.camera))), t
        }, interpolateBetween: function (i, r, a) {
            if (r && i) {
                var n = 1 - (a = pd.constrainTo(a, 0, 1));
                null != r.defaultDistance ? (this.defaultDistance = n * i.defaultDistance + a * r.defaultDistance, this.cameraDistance = n * i.cameraDistance + a * r.defaultDistance) : null != r.cameraDistance && (this.cameraDistance = n * i.cameraDistance + a * r.cameraDistance), null != r.defaultAzi ? (this.defaultAzi = n * i.defaultAzi + a * r.defaultAzi, this.cameraAzi = n * i.cameraAzi + a * r.defaultAzi) : null != r.cameraAzi && (this.cameraAzi = n * i.cameraAzi + a * r.cameraAzi), null != r.defaultAlt ? (this.defaultAlt = n * i.defaultAlt + a * r.defaultAlt, this.cameraAlt = n * i.cameraAlt + a * r.defaultAlt) : null != r.cameraAlt && (this.cameraAlt = n * i.cameraAlt + a * r.cameraAlt), null != r.defaultFOV ? (this.defaultFOV = n * i.defaultFOV + a * r.defaultFOV, this.cameraFOV = n * i.cameraFOV + a * r.defaultFOV) : null != r.cameraFOV && (this.cameraFOV = n * i.cameraFOV + a * r.cameraFOV), null != r.zoomFactor && (this.zoomFactor = Math.max(this._zoomFactorMin, n * i.zoomFactor + a * r.zoomFactor)), null != r.farFieldFactor && (this.farFieldFactor = n * i.farFieldFactor + a * r.farFieldFactor), null != r.farFieldMin && (this.farFieldMin = n * i.farFieldMin + a * r.farFieldMin), null != r.snapGrid && (this.snapGrid = n * i.snapGrid + a * r.snapGrid), null != r.defaultTarget ? (this.defaultTarget.x = n * i.target.x + a * r.defaultTarget.x, this.defaultTarget.y = n * i.target.y + a * r.defaultTarget.y, this.defaultTarget.z = n * i.target.z + a * r.defaultTarget.z, this.target.init(this.defaultTarget)) : null != r.target && (this.target.x = n * i.target.x + a * r.target.x, this.target.y = n * i.target.y + a * r.target.y, this.target.z = n * i.target.z + a * r.target.z), null != r.camera && (this.camera.x = n * i.camera.x + a * r.camera.x, this.camera.y = n * i.camera.y + a * r.camera.y, this.camera.z = n * i.camera.z + a * r.camera.z, this.cameraDistance = this.camera.distanceTo(this.target), this.cameraAlt = e(this.camera, this.target), this.cameraAzi = t(this.camera, this.target)), this.hasChanged = M.PROJECTION, this._unprojectValid = !1
            }
            return this
        }, animateTo: function (t, e) {
            function i(t) {
                return (a += r.animationSpeed * pd.constrainTo(t, .001, .2)) > 1 && (a = 1), r.interpolateBetween(r._animateSourceView, r._animateTargetView, pd.Easing.inOutSine(a)), e && e(r, a), M.update(), a > .999 && (r._animating = !1, r._animateTargetView = null, !0)
            }

            if (!this._animating) {
                var r = this, a = 0;
                this._animateSourceView = this.copyViewDataTo(this._animateSourceView), this._animateTargetView = this.copyViewDataTo(null, t), this._animating = !0, M.animationQueue.addOrReplace(i).start()
            }
            return this
        }, setView: function (t) {
            t = t || {};
            var t = {target: this.defaultTarget, cameraDistance: this.defaultDistance, zoomFactor: 1};
            return this.copyViewDataTo(t, t), this.interpolateBetween(this, t, 1), this._unprojectValid = !1, M.update(), this
        }, setCamera: function (t, e, i, r) {
            return pd.isNumeric(t) && (t = pd.wrapAt(t, -180, 180), pd.closeTo(this.cameraAzi, t, .01) || (this.hasChanged = M.MODELVIEW, this.cameraAzi = t)), pd.isNumeric(e) && (e = pd.constrainTo(e, -90, 90), pd.closeTo(this.cameraAlt, e, .01) || (this.hasChanged = M.MODELVIEW, this.cameraAlt = e)), pd.isNumeric(i) && (i = pd.constrainTo(i, 0, 160), pd.closeTo(this.cameraFOV, i, .01) || (this.hasChanged = M.PROJECTION, this.cameraFOV = i)), pd.isNumeric(r) && (r = pd.constrainTo(r, .001, 1e3), pd.closeTo(this.zoomFactor, r, 1e-4) || (this.zoomFactor = Math.max(this._zoomFactorMin, r), this.hasChanged = M.PROJECTION)), this.hasChanged && (this._unprojectValid = !1, this._animating = !1, M.update()), 0 != this.hasChanged
        }, reset: function (t, e) {
            return this._unprojectValid = !1, this._animating = !1, t ? (this.cameraAzi = this.defaultAzi, this.cameraAlt = this.defaultAlt, this.cameraFOV = this.defaultFOV, this.hasChanged = M.PROJECTION, M.update()) : this.animateTo({
                cameraAzi: this.defaultAzi,
                cameraAlt: this.defaultAlt,
                cameraFOV: this.defaultFOV,
                cameraDistance: this.defaultDistance,
                target: this.defaultTarget,
                zoomFactor: 1
            }, e), this
        }, center: function (t, e) {
            t = t || {};
            var i = {target: this.defaultTarget, cameraDistance: this.defaultDistance, zoomFactor: 1};
            return this.copyViewDataTo(i, t), this._unprojectValid = !1, this._animating = !1, this.orbitMode = !0, t.noAnimation ? (this.interpolateBetween(this, i, 1), M.update()) : this.animateTo(i, e), this
        }, isCenter: function () {
            return (!this.zoomByDollying || this.cameraDistance == this.defaultDistance) && (this.target.equals(this.defaultTarget) && 1 == this.zoomFactor)
        }, redraw: function () {
            return M.update(), this
        }, getPointSize: function () {
            return .01 * this.defaultDistance
        }, getVectorToCamera: function (t, e, i) {
            arguments.length < 1 && (t = this.target.x, e = this.target.y, i = this.target.z);
            var r = this.camera.x - t, a = this.camera.y - e, n = this.camera.z - i, o = r * r + a * a + n * n;
            return o > 0 && (r *= o = 1 / Math.sqrt(o), a *= o, n *= o), [r, a, n]
        }, checkUnprojectMatrix: function (t) {
            return this._unprojectValid && !t || (this._localHUD ? pd3D.Matrix.inverse(pd3D.Matrix.multiply(this._localProjectionMatrix, this._localModelViewMatrix), this._unprojectMatrix) : pd3D.Matrix.inverse(pd3D.Matrix.multiply(M.projectionMatrix, M.modelviewMatrix), this._unprojectMatrix), this._unprojectValid = !0), this
        }, modelToCanvas: function (t, e) {
            var i, r = this._unprojectViewport;
            return this.checkUnprojectMatrix(), this._localHUD ? (i = this._localProjectionMatrix.transformPoint(this._localModelViewMatrix.transformPoint(new pd3D.Vector(e[0], e[1], e[2]))), t[0] = r[0] + r[2] * (.5 * i.x + .5), t[1] = r[1] + r[3] * (.5 * i.y + .5), t[2] = .5 * i.z + .5) : (i = M.projectionMatrix.transformPoint(M.modelviewMatrix.transformPoint(new pd3D.Vector(e[0], e[1], e[2]))), t[0] = (r[0] + r[2] * (.5 * i.x + .5)) / pdDOM.devicePixelRatio, t[1] = (r[3] - (r[1] + r[3] * (.5 * i.y + .5))) / pdDOM.devicePixelRatio, t[2] = .5 * i.z + .5), t
        }, canvasToModel: function (t, e, i) {
            this.checkUnprojectMatrix();
            var r = this._unprojectViewport;
            return t *= pdDOM.devicePixelRatio, e = r[3] - e * pdDOM.devicePixelRatio, this._unprojectMatrix.transformPoint(new pd3D.Vector((t - r[0]) / r[2] * 2 - 1, (e - r[1]) / r[3] * 2 - 1, 2 * i - 1))
        }, zoom: function (t) {
            return t *= .5, this.zoomFactor = Math.max(this._zoomFactorMin, this.zoomFactor + t), this.zoomByDollying && (this.cameraDistance = this.defaultDistance / this.zoomFactor), this.hasChanged = M.PROJECTION, this._unprojectValid = !1, M.update(), this
        }, walk: function (t) {
            var e = this.target.subtract(this.camera).normalize().multiply(.25 * t * this.cameraDistance * this.getFieldOfViewFactor());
            return this.camera.init(this.camera.x + e.x, this.camera.y + e.y, this.camera.z + e.z), this.target.init(this.target.x + e.x, this.target.y + e.y, this.target.z + e.z), this.hasChanged = M.PROJECTION, this._unprojectValid = !1, this.orbitMode = !1, M.update(), this
        }, rotate: function (t, e) {
            if (this.cameraAzi = pd.wrapAt(this.cameraAzi - t, -180, 180), this.cameraAlt = Math.max(-90, Math.min(90, this.cameraAlt + e)), !this.orbitMode) {
                var i = this.camera.distanceTo(this.target), r = pd.wrapAt(this.cameraAzi + 180, -180, 180);
                pd3D.Vector.sphericalToCartesian3D(r * y, -this.cameraAlt * y, i, this.target), pd3D.Vector.add(this.target, this.camera, this.target)
            }
            return this.hasChanged = M.MODELVIEW, this._unprojectValid = !1, M.update(), this
        }, pan: function (t, e, i) {
            return;
            var r = !1, a = .25 * this.defaultDistance / this.zoomFactor,
                n = this.target.subtract(this.camera).normalize();
            if (Math.abs(e) > 1e-4) {
                e *= a;
                var o = (s = pd3D.Vector.UnitZ.cross(n).normalize()).cross(n).normalize().multiply(e);
                this.target.init(this.target.x - o.x, this.target.y - o.y, this.target.z - o.z), this.camera.init(this.camera.x - o.x, this.camera.y - o.y, this.camera.z - o.z), r = !0
            }
            if (Math.abs(t) > 1e-4) {
                t *= a;
                var s = pd3D.Vector.UnitZ.cross(n).normalize().multiply(t);
                this.target.init(this.target.x + s.x, this.target.y + s.y, this.target.z + s.z), this.camera.init(this.camera.x + s.x, this.camera.y + s.y, this.camera.z + s.z), r = !0
            }
            return r && i && (this.hasChanged = M.MODELVIEW, this._unprojectValid = !1, M.update()), this
        }, clearInertia: function () {
            return this._inertiaAction = 0, this._inertiaTimeStamp = 0, this._inertiaDeltaX = 0, this._inertiaDeltaY = 0, this._inertiaZoom = 0, this
        }, updateView: function (t) {
            if (1 == this._inertiaAction) this.rotate(.25 * this._inertiaDeltaX, .25 * this._inertiaDeltaY); else if (2 == this._inertiaAction) this.pan(.0075 * this._inertiaDeltaX, .0075 * this._inertiaDeltaY, !0); else if (3 == this._inertiaAction) this.zoom(this._inertiaZoom); else if (4 == this._inertiaAction) this.pan(.0075 * this._inertiaDeltaX, .0075 * this._inertiaDeltaY, !1), t && this.rotate(t, 0), this.zoom(this._inertiaZoom); else if (5 == this._inertiaAction) {
                var e = pd.constrainTo(this.cameraFOV - 150 * this._inertiaZoom, 0, 160);
                e != this.cameraFOV && (this.cameraFOV = e, this.zoom(this.zoomFactor * this._inertiaZoom))
            }
            return this
        }, updateInertia: function () {
            return this._inertiaAction > 0 && (Math.abs(this._inertiaDeltaX) > this._inertiaMinimumValue || Math.abs(this._inertiaDeltaY) > this._inertiaMinimumValue || Math.abs(this._inertiaZoom) > 1e-4) ? (this._inertiaDeltaX = this._inertiaDeltaX * this._inertiaDampingFactor, this._inertiaDeltaY = this._inertiaDeltaY * this._inertiaDampingFactor, this._inertiaZoom = this._inertiaZoom * this._inertiaDampingFactor, this.updateView(), !1) : (this.clearInertia(), !0)
        }, handleKbdNavigation: function (t) {
            var e = !1;
            if (GL.keyCount || this.kbdNav.active) if (this.orbitMode) (GL.keys.CapsLock || GL.keys.SHIFT) && (t *= 5), (GL.keys.A || GL.keys.D || GL.keys.Q || GL.keys.Z) && (this.pan(t * ((GL.keys.A || 0) - (GL.keys.D || 0)), t * ((GL.keys.Q || 0) - (GL.keys.Z || 0)), !0), e = !0), (GL.keys.LEFT || GL.keys.RIGHT || GL.keys.UP || GL.keys.DOWN) && (this.rotate(25 * t * ((GL.keys.LEFT || 0) - (GL.keys.RIGHT || 0)), 25 * t * ((GL.keys.UP || 0) - (GL.keys.DOWN || 0))), e = !0), (GL.keys.W || GL.keys.S) && (this.walk(t * this.kbdNav.speedUp * ((GL.keys.W || 0) - (GL.keys.S || 0))), e = !0); else {
                var i = this.kbdNav, r = i.slowDown, a = i.speedUp, n = .5;
                if ((GL.keys.CapsLock || GL.keys.SHIFT) && (n = 5), GL.keys.W || GL.keys.S ? (i.moveInOut += a * ((GL.keys.W || 0) - (GL.keys.S || 0)), i.moveInOut = pd.constrainTo(i.moveInOut, -n, n)) : i.moveInOut *= r, GL.keys.A || GL.keys.D ? (i.moveLeftRight += a * ((GL.keys.A || 0) - (GL.keys.D || 0)), i.moveLeftRight = pd.constrainTo(i.moveLeftRight, -n, n)) : i.moveLeftRight *= r, GL.keys.Q || GL.keys.Z ? (i.moveUpDown += a * ((GL.keys.Q || 0) - (GL.keys.Z || 0)), i.moveUpDown = pd.constrainTo(i.moveUpDown, -n, n)) : i.moveUpDown *= r, GL.keys.LEFT || GL.keys.RIGHT ? (i.lookLeftRight += 25 * a * ((GL.keys.RIGHT || 0) - (GL.keys.LEFT || 0)), i.lookLeftRight = pd.constrainTo(i.lookLeftRight, -100 * n, 100 * n)) : i.lookLeftRight *= r, GL.keys.UP && GL.keys.DOWN ? i.lookUpDown = this.cameraAlt / t * -.1 : GL.keys.UP || GL.keys.DOWN ? (i.lookUpDown += 15 * a * ((GL.keys.DOWN || 0) - (GL.keys.UP || 0)), i.lookUpDown = pd.constrainTo(i.lookUpDown, -100 * n, 100 * n)) : i.lookUpDown *= r, i.active = !1, (Math.abs(i.moveLeftRight) > 1e-4 || Math.abs(i.moveUpDown) > 1e-4) && (this.pan(.5 * t * i.moveLeftRight, .5 * t * i.moveUpDown, !0), e = i.active = !0), Math.abs(i.lookLeftRight) > 1e-4 || Math.abs(i.lookUpDown) > 1e-4) {
                    if (this.cameraFOV < 1) {
                        var o = Math.max(.05, this.cameraFOV);
                        this.pan(t * o * -i.lookLeftRight, t * o * -i.lookUpDown, !0)
                    } else this.rotate(t * i.lookLeftRight, t * i.lookUpDown);
                    e = i.active = !0
                }
                Math.abs(i.moveInOut) > 1e-4 && (this.cameraFOV < 1 ? this.zoom(t * i.moveInOut) : this.walk(t * i.moveInOut), e = i.active = !0)
            }
            return e
        }, initialise: function () {
            var t = this, e = -1, i = !1, r = 0;
            return M.onmousemove = function (e) {
                // console.info('opt-e',e);
                t.handlePointerMove && t.handlePointerMove(e)
            }, M.onmousedown = function (a) {
                t.clearInertia(), r = a.touchCount, t.handlePointerDown && (i = t.handlePointerDown(a)), e = a.button
            }, M.onmousedrag = function (a) {
                var n = a.button;
                if (a.button < 0 && (n = a.button = e), r < a.touchCount && (r = a.touchCount), !(i && t.handlePointerDrag && t.handlePointerDrag(a))) if (t._inertiaAction = 0, 0 == n || 2 == n && !a.touchCount) if (a.ctrlKey || a.metaKey) a.shiftKey ? (t._inertiaAction = 5, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaZoom = .0015 * -(t._inertiaDeltaX - t._inertiaDeltaY), t.updateView()) : (t._inertiaAction = 3, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaZoom = .005 * (t._inertiaDeltaX - t._inertiaDeltaY), t.updateView()); else if (a.shiftKey) t._inertiaAction = 2, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaZoom = 0, t.updateView(); else {
                    var o = t.orbitMode ? 1 : pd.mapAndConstrainTo(t.cameraFOV, 0, 90, .001, 1);
                    t._inertiaAction = 1, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = o * a.dragX, t._inertiaDeltaY = o * a.dragY, t._inertiaZoom = 0, t.updateView()
                } else 1 == n ? (t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaAction = 4, t._inertiaZoom = 1.5 * (a.scale - 1), Math.abs(t._inertiaZoom) > .25 && (t._inertiaZoom = 0, a.rotation = 0), t.updateView(a.rotation)) : 2 == n && (a.touchCount > 2 ? (t._inertiaAction = 2, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaZoom = 0, t.updateView()) : (t._inertiaAction = 1, t._inertiaTimeStamp = a.timeStamp, t._inertiaDeltaX = a.dragX, t._inertiaDeltaY = a.dragY, t._inertiaZoom = 0, t.updateView()))
            }, M.onmouseup = function (r) {
                function a() {
                    return t.updateInertia()
                }

                i && t.handlePointerUp && t.handlePointerUp(r) || (i = !1, pdDOM.Interaction.hasMoved(5 * pdDOM.devicePixelRatio) && r.timeStamp - t._inertiaTimeStamp < t._inertiaThresholdTime && (Math.abs(t._inertiaDeltaX) > t._inertiaThresholdDelta || Math.abs(t._inertiaDeltaY) > t._inertiaThresholdDelta || Math.abs(t._inertiaZoom) > .01) && M.animationQueue.addOrReplace(a).start(), e = -1)
            }, M.onmousewheel = function (e) {
                if (e.delta) {
                    var i = e.delta < 0 ? -1 : 1;
                    e.shiftKey ? i *= 10 : (e.ctrlKey || e.metaKey) && (i *= .1), e.timeStamp - t._inertiaTimeStamp < t._inertiaThresholdTime ? (t.mouseWheelIncrement += .1, i >= 0 ? i += t.mouseWheelIncrement : i -= t.mouseWheelIncrement) : t.mouseWheelIncrement = 0, t._inertiaTimeStamp = e.timeStamp, t.zoom(.05 * i)
                }
            }, this
        }
    };
    var A = 0, T = {};
    GL.Texture = function (t, e, i) {
        i = i || {}, A || (A = M.getParameter(M.MAX_COMBINED_TEXTURE_IMAGE_UNITS)), this.width = pd.toInteger(t, 64), this.height = pd.toInteger(e, 64), this.unit = pd.toInteger(i.unit, 0), this.type = pd.toInteger(i.type, M.UNSIGNED_BYTE), this.format = pd.toInteger(i.format, M.RGBA), this.type == M.FLOAT ? (u("OES_texture_float") || console.warn("ERROR: Device or browser does not support 'OES_texture_float'."), u("OES_texture_float_linear") || (i.filter = M.NEAREST)) : this.type == M.HALF_FLOAT && (u("OES_texture_half_float") || console.warn("ERROR: Device or browser does not support 'OES_texture_half_float'."), u("OES_texture_half_float_linear") || (i.filter = M.NEAREST)), i.imageData || (i.imageData = null), this.textureId = M.createTexture(), M.activeTexture(M.TEXTURE0 + this.unit), M.bindTexture(M.TEXTURE_2D, this.textureId), M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL, !0), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_MAG_FILTER, i.filter || i.magFilter || M.LINEAR), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_MIN_FILTER, i.filter || i.minFilter || M.LINEAR), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_WRAP_S, i.wrap || i.wrapS || M.CLAMP_TO_EDGE), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_WRAP_T, i.wrap || i.wrapT || M.CLAMP_TO_EDGE), M.texImage2D(M.TEXTURE_2D, 0, this.format, this.width, this.height, 0, this.format, this.type, i.imageData), this.bound = !1
    };
    var L, C, b, S = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    GL.Texture.prototype = {
        bind: function (t) {
            (t = t || this.unit || 0) >= 0 && t < 16 ? S[t] != this.textureId && (M.activeTexture(M.TEXTURE0 + t), M.bindTexture(M.TEXTURE_2D, this.textureId), S[t] = this.textureId) : (M.activeTexture(M.TEXTURE0 + t), M.bindTexture(M.TEXTURE_2D, this.textureId)), this.bound = !0
        }, unbind: function (t) {
            (t = t || this.unit || 0) >= 0 && t < 16 ? S[t] == this.textureId && (M.activeTexture(M.TEXTURE0 + t), M.bindTexture(M.TEXTURE_2D, null), S[t] = -1) : (M.activeTexture(M.TEXTURE0 + t), M.bindTexture(M.TEXTURE_2D, null)), this.bound = !1
        }, drawTo: function (t, e) {
            e = e || {};
            var i = M.getParameter(M.VIEWPORT);
            M.viewport(0, 0, this.width, this.height), b = b || M.createFramebuffer(), M.bindFramebuffer(M.FRAMEBUFFER, b), M.framebufferTexture2D(M.FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_2D, this.textureId, 0), !1 !== e.depth && (C = C || M.createRenderbuffer(), M.bindRenderbuffer(M.RENDERBUFFER, C), this.width == C.width && this.height == C.height || (C.width = this.width, C.height = this.height, M.renderbufferStorage(M.RENDERBUFFER, M.DEPTH_COMPONENT16, this.width, this.height)), M.framebufferRenderbuffer(M.FRAMEBUFFER, M.DEPTH_ATTACHMENT, M.RENDERBUFFER, C)), t && t(), M.bindFramebuffer(M.FRAMEBUFFER, null), M.bindRenderbuffer(M.RENDERBUFFER, null), M.viewport(i[0], i[1], i[2], i[3])
        }, swapWith: function (t) {
            var e;
            e = t.textureId, t.textureId = this.textureId, this.textureId = e, e = t.width, t.width = this.width, this.width = e, e = t.height, t.height = this.height, this.height = e
        }
    };
    var E = null;
    GL.Texture.placeholder = function () {
        return E || (E = new GL.Texture(1, 1, {imageData: new Uint8Array([0, 0, 0, 0])})), E
    }, GL.Texture.fromImage = function (t, e) {
        e = e || {};
        var i = new GL.Texture(t.width, t.height, e);
        try {
            M.texImage2D(M.TEXTURE_2D, 0, i.format, i.format, i.type, t)
        } catch (t) {
            throw"file:" == window.location.protocol ? new Error('Image not loaded for security reasons (serve this page over "http://" instead)') : new Error("Image not loaded for security reasons (image must originate from the same domain as this page or use Cross-Origin Resource Sharing)")
        }
        return e.minFilter && e.minFilter != M.NEAREST && e.minFilter != M.LINEAR && M.generateMipmap(M.TEXTURE_2D), i
    }, GL.Texture.fromURL = function (t, e) {
        L = L || function () {
            var t = document.createElement("canvas").getContext("2d");
            t.canvas.width = t.canvas.height = 128;
            for (var e = 0; e < t.canvas.height; e += 16) for (var i = 0; i < t.canvas.width; i += 16) t.fillStyle = 16 & (i ^ e) ? "#FFF" : "#DDD", t.fillRect(i, e, 16, 16);
            return t.canvas
        }();
        var i = GL.Texture.fromImage(L, e), r = new Image, a = M;
        return r.onload = function () {
            a.makeCurrent(), GL.Texture.fromImage(r, e).swapWith(i)
        }, r.src = t, i
    };
    var P = null;
    GL.Material = function (t) {
        t = t || {}, pd3D.Material.call(this, t), this._mode = pd.toInteger(t.mode, M.TRIANGLES), this._shader = t.shader || GL.Material.DefaultShader(), this._shadowMap = t.shadowMap || null, this._textureUnit = t.textureUnit || -1, this._texture = t.texture || null, this._uniforms = t.uniforms || {}, this._callbackOnDrawMesh = null, this._cachedUniforms = null, this._rendering = !1, this._shadowMap && (this._uniforms.shadowMap = 0), this._texture && (this._uniforms.texture = this._textureUnit)
    }, GL.Material.prototype = Object.create(pd3D.Material.prototype), GL.Material.prototype.constructor = GL.Material, GL.Material.prototype.shader = function (t) {
        return 0 == arguments.length ? this._shader : (this._shader = t, this)
    }, GL.Material.prototype.uniform = function (t, e) {
        if (1 == arguments.length) return this._uniforms[t];
        if (arguments.length >= 2 && (this._uniforms[t] = e, this._cachedUniforms)) {
            if (!this._shader) throw'Attempted to set uniform "' + t + '" before assigning a valid shader.';
            var i = this._cachedUniforms[t];
            this._cachedUniforms[t] = this._shader.createCachedUniform(t, e, i), this._rendering && this._shader.setCachedUniformValue(this._cachedUniforms[t])
        }
        return this
    }, GL.Material.prototype.uniforms = function (t) {
        return 0 == arguments.length ? this._uniforms : (this._uniforms = t || {}, this._cachedUniforms = null, this)
    }, GL.Material.prototype.createUniformCache = function () {
        var t = {}, e = this._uniforms, i = this._shader;
        for (var r in e) e.hasOwnProperty(r) && (t[r] = i.createCachedUniform(r, e[r], t[r]));
        return this._cachedUniforms = t, this
    }, GL.Material.prototype.getCachedUniform = function (t) {
        return this._cachedUniforms || this.createUniformCache(), this._cachedUniforms[t]
    }, GL.Material.prototype.setCachedUniform = function (t, e) {
        return e && (this._cachedUniforms || this.createUniformCache(), this._cachedUniforms[t] = e), this
    }, GL.Material.prototype.setCachedUniforms = function (t) {
        var e = {}, i = this._uniforms, r = this._shader;
        for (var a in i) i.hasOwnProperty(a) && (e[a] = a in t ? t[a] : r.createCachedUniform(a, i[a]));
        return this._cachedUniforms = e, this
    }, GL.Material.prototype.pushUniform = function (t, e) {
        return GL.Material.pushUniform(this, t, e), this
    }, GL.Material.prototype.popUniform = function () {
        return GL.Material.popUniform(), this
    }, GL.Material.prototype.texture = function (t, e) {
        return 0 == arguments.length ? this._texture : (this._texture = t, this._textureUnit = e > 0 ? e : 1, this._texture ? this._uniforms.texture = this._textureUnit : delete this._uniforms.texture, this)
    }, GL.Material.prototype.shadowMap = function (t) {
        return 0 == arguments.length ? this._shadowMap : (this._shadowMap = t, this._shadowMap ? this._uniforms.shadowMap = 0 : delete this._uniforms.shadowMap, this)
    }, GL.Material.prototype.mode = function (t) {
        return 0 == arguments.length ? this._mode : (this._mode = t, this)
    };
    var O = -1;
    GL.Material.prototype.isRendering = function () {
        return this._rendering
    }, GL.Material.prototype.startRender = function () {
        return P && P.id == this.id || (P && P.endRender(), this._shadowMap && this._shadowMap.bind(0), this._textureUnit > 0 && (this._texture ? this._texture.bind(this._textureUnit) : GL.Texture.placeholder().bind(this._textureUnit)), this._cachedUniforms || this.createUniformCache(), this._shader.setCachedUniformValues(this._cachedUniforms), this._shader.prepareMatrices(), this._rendering = !0, P = this), this
    }, GL.Material.prototype.endRender = function () {
        return P = null, this._rendering = !1, this
    }, GL.Material.prototype.unbindTextures = function () {
        return this._texture && this._texture.unbind(this._textureUnit), this._shadowMap && this._shadowMap.unbind(0), this
    }, GL.Material.prototype._renderMesh = function (t, e, i) {
        return i || (i = GL.Shader.getIndexBufferName(e)), this._callbackOnDrawMesh && this._callbackOnDrawMesh(t, e), e >= M.TRIANGLES && null != t.noCullFace ? M.setCullFace(!t.noCullFace) : t.lineWidth > .1 && (O = t.lineWidth, M.pushLineWidth(t.lineWidth)), t.callbackOnDraw && t.callbackOnDraw(t, e, this), this._shader.renderPrimitive(t.vertexBuffers, t.indexBuffers[i], e), O > 0 && (O = -1, M.popLineWidth()), this
    }, GL.Material.prototype.renderMeshes = function (t, e) {
        if (this._shader && t) {
            var i, r, a, n = Array.isArray(t) ? t : [t];
            if (this._rendering || this.startRender(), this._cachedUniforms || (this.createUniformCache(), this._shader.setCachedUniformValues(this._cachedUniforms)), e === pd3D.RENDER_ALL && (e = w), Array.isArray(e)) {
                for (var o = e, s = 0, l = n.length; s < l; ++s) if ((i = n[s]) && i.visible) for (var h = 0; h < o.length; ++h) e = c(o[h], this._mode), r = i[a = GL.Shader.getIndexBufferName(e)], (!e || r && r.length) && this._renderMesh(i, e, a)
            } else {
                e = c(e, this._mode), a = GL.Shader.getIndexBufferName(e);
                for (var s = 0, l = n.length; s < l; ++s) r = (i = n[s])[a], i && i.visible && (!e || r && r.length) && this._renderMesh(i, e, a)
            }
            M.setCullFace()
        }
        return this
    }, GL.Material.prototype.renderMeshPrimitives = function (t) {
        if (this._shader && t) {
            var e, i = Array.isArray(t) ? t : [t];
            this._rendering || this.startRender(), this._cachedUniforms || (this.createUniformCache(), this._shader.setCachedUniformValues(this._cachedUniforms));
            for (var r = 0, a = i.length; r < a; ++r) (e = i[r]) && e.visible && e.primitives && (this._callbackOnDrawMesh && this._callbackOnDrawMesh(e, 0), null != e.noCullFace && M.setCullFace(!e.noCullFace), e.lineWidth > .1 && (O = e.lineWidth, M.pushLineWidth(e.lineWidth)), this._shader.renderMultiplePrimitives(e.vertexBuffers, e.indexBuffers.points, e.primitives), O > 0 && (O = -1, M.popLineWidth()))
        }
        return M.setCullFace(), this
    }, GL.Material.prototype.renderSurfaces = function (t) {
        return this.renderMeshes(t, M.TRIANGLES)
    }, GL.Material.prototype.renderOutlines = function (t) {
        return this.renderMeshes(t, M.LINES)
    }, GL.Material.prototype.renderPoints = function (t) {
        return this.renderMeshes(t, M.POINTS)
    }, GL.Material.prototype.renderNode3D = function (t, e) {
        if (this.startRender(), Array.isArray(t)) for (var i = 0, r = t.length; i < r; ++i) t[i].drawWithMaterial(this, e); else t.drawWithMaterial(this, e);
        return this.endRender(), this
    }, GL.Material.prototype.draw = function (t, e) {
        return this._shader && t && (this.startRender(), this.renderMeshes(t, e), this.endRender()), this
    }, GL.Material.prototype.drawSurface = function (t) {
        return this.draw(t, M.TRIANGLES)
    }, GL.Material.prototype.drawOutline = function (t) {
        return this.draw(t, M.LINES)
    }, GL.Material.prototype.drawPoints = function (t) {
        return this.draw(t, M.POINTS)
    }, GL.Material.prototype.drawAll = function (t) {
        return this.draw(t, pd3D.RENDER_ALL)
    };
    var N = [];
    GL.Material.pushUniform = function (t, e, i) {
        var r = {}, a = t._uniforms;
        if (a.hasOwnProperty(e) && a[e] != i) {
            if (r.material = t, r.old_value = a[e], r.old_cache = null, r.name = e, t._cachedUniforms) if (t._cachedUniforms.hasOwnProperty(e)) {
                var n = t._cachedUniforms[e];
                r.old_cache = {name: n.name, value: n.value, method: n.method, isMatrix: n.isMatrix, stale: n.stale}
            } else r.old_cache = t._shader.createCachedUniform(e, r.old_value);
            t.uniform(e, i)
        }
        N.push(r)
    }, GL.Material.popUniform = function () {
        if (N.length > 0) {
            var t = N.pop(), e = t.material;
            e && e._uniforms.hasOwnProperty(t.name) && (e._uniforms[t.name] = t.old_value, e._cachedUniforms && t.old_cache && (e._cachedUniforms[t.name] = t.old_cache, e._rendering && e._shader.setCachedUniformValue(t.old_cache)))
        }
    }, GL.ShaderComponent = {
        mainFunc: "\nvoid main() {\n",
        endFunc: "\n}\n",
        position: {
            vertHead: "",
            vertMain: "\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n",
            fragHead: "",
            fragMain: ""
        },
        POINT_SIZE_UNIFORM: {
            vertHead: "\nuniform float pointSize;\n",
            vertMain: "\n    gl_PointSize = pointSize;\n",
            fragHead: "",
            fragMain: "",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.pointSize = pd.toNumber(t.uniforms.pointSize, 1)
            }
        },
        POINT_SIZE_ATTRIBUTE: {
            vertHead: "\nattribute float pointSize;\n",
            vertMain: "\n    gl_PointSize = pointSize;\n",
            fragHead: "",
            fragMain: ""
        },
        COLOR_UNIFORM: {
            vertHead: "",
            vertMain: "",
            fragHead: "\nuniform vec4 color;\nuniform float opacity;\n",
            fragMain: "\n    float alpha = clamp(opacity * color.a, 0.0, 1.0);\n    gl_FragColor = vec4(color.rgb, alpha);\n    if (alpha < 0.001)\n        discard;\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [1, 1, 1, 1], t.uniforms.opacity = pd.toNumber(t.uniforms.opacity, 1)
            }
        },
        COLOR_ATTRIBUTE: {
            vertHead: "\nuniform vec4 color;\nuniform bool useVertexColors;\nvarying vec4 vColor;\n",
            vertMain: "\n    vColor = (useVertexColors == true) ? gl_Color : color;\n",
            fragHead: "\nuniform float opacity;\nvarying vec4 vColor;\n",
            fragMain: "\n    float alpha = clamp(opacity * vColor.a, 0.0, 1.0);\n    gl_FragColor = vec4(vColor.rgb, alpha);\n    if (alpha < 0.001)\n        discard;\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [1, 1, 1, 1], t.uniforms.opacity = pd.toNumber(t.uniforms.opacity, 1), t.useMeshColors = !0
            }
        },
        COLOR_BLINNPHONG: {
            vertHead: "\nuniform vec4 color;\nuniform bool useVertexColors;\nuniform vec3 sunPosition;\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec3 vLight;\nvarying vec4 vColor;\n",
            vertMain: "\n    vColor = (useVertexColors == true) ? gl_Color : color;\n    vec4 vtx = gl_ModelViewMatrix * gl_Vertex;\n    vVertex = vec3(vtx) / vtx.w;\n    vNormal = gl_NormalMatrix * gl_Normal;\n    vLight = sunPosition - vVertex;\n",
            fragHead: "\nuniform float opacity;\nuniform float shininess;\nuniform float sunIntensity;\nuniform vec3 specularColor;\nuniform vec3 ambientColor;\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec3 vLight;\nvarying vec4 vColor;\n",
            fragMain: "\n    float intensity = sunIntensity;\n    float specularCoefficient = 0.0;\n    vec3 normal = normalize(vNormal);\n    vec3 lightDir = normalize(vLight);\n    float alpha = clamp(opacity * vColor.a, 0.0, 1.0);\n    float diffuseCoefficient = max(0.0, dot(lightDir, normal));\n    if (diffuseCoefficient > 0.0) {\n        vec3 viewDir = normalize(-vVertex);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(normal, halfDir), 0.0);\n        specularCoefficient = pow(specAngle, shininess);\n    }\n\n    vec3 diffuse = (diffuseCoefficient * vColor.rgb);\n    vec3 specular = (specularCoefficient * specularColor);\n    vec3 ambient = (ambientColor * vColor.rgb);\n",
            fragColor: "\n    vec3 color = clamp(ambient + (intensity * (diffuse + specular)), 0.0, 1.0);\n\n    gl_FragColor = vec4(color, alpha);\n    if (alpha < 0.001) {\n        discard;\n    }\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.sunPosition = t.uniforms.sunPosition || [1, 1, 1], t.uniforms.ambientColor = t.uniforms.ambientColor || [.75, .75, .75], t.uniforms.specularColor = t.uniforms.specularColor || [.85, .85, .85], t.uniforms.sunIntensity = pd.toNumber(t.uniforms.sunIntensity, 1), t.uniforms.shininess = pd.toNumber(t.uniforms.shininess, 75), t.uniforms.opacity = pd.toNumber(t.uniforms.opacity, 1), t.useMeshColors = !0
            }
        },
        SHADOW_MAP: {
            vertHead: "\nuniform mat4 shadowMatrix;\nvarying vec4 vCoords;\n",
            vertMain: "\n    vCoords = shadowMatrix * gl_Position;\n",
            fragHead: "\nuniform vec3 shadowColor;\nuniform sampler2D shadowMap;\nuniform float shadowOpacity;\nvarying vec4 vCoords;\n",
            fragMain: "\n    if (diffuseCoefficient > 0.0) {\n        if (vCoords.w > 0.0) {\n            float depth = 0.0;\n            vec2 sample = ((vCoords.xy / vCoords.w) * 0.5) + 0.5;\n            if (clamp(sample, 0.0, 1.0) == sample) {\n                float sampleDepth = texture2D(shadowMap, sample).r;\n                depth = (sampleDepth == 1.0) ? 1.0e12 : sampleDepth;\n            }\n            if (depth > 0.0) {\n                float shading = clamp(300.0 * (-0.002 + ((vCoords.z / vCoords.w) * 0.5) + 0.5 - depth), 0.0, 1.0);\n                if (length(shadowColor) > 0.01) {\n                    float mix_factor = intensity * shading * ((shadowOpacity > 0.0) ? shadowOpacity : 0.5);\n                    specular = mix(specular, shadowColor, mix_factor);\n                    diffuse = mix(diffuse, shadowColor, mix_factor);\n                    ambient = mix(ambient, shadowColor, mix_factor);\n                }\n                intensity *= (1.0 - shading);\n                if (shadowOpacity > 0.0) {\n                    alpha = max(alpha, min(shadowOpacity * shading, sunIntensity));\n                }\n            }\n        }\n    } else {\n        intensity = 0.0;\n    }\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.shadowColor = t.uniforms.shadowColor || [0, 0, 0], t.uniforms.shadowOpacity = pd.toNumber(t.uniforms.shadowOpacity, -1), t.uniforms.shadowMatrix = t.uniforms.shadowMatrix || null
            }
        },
        TEXTURE: {
            vertHead: "\nvarying vec4 vTexCoords;\n",
            vertMain: "\n    vTexCoords = gl_TexCoord;\n",
            fragHead: "\nuniform sampler2D texture;\nvarying vec4 vTexCoords;\n",
            fragMain: "",
            fragColor: "\n    gl_FragColor *= (alpha * texture2D(texture, vTexCoords.xy));\n",
            checkUniforms: function (t) {
                t.useTexture = !0
            }
        }
    }, GL.Material.compose = function (t, e, i) {
        (t = t || {}).shader || (t.shader = m(e, i));
        for (var r = 0, a = e.length; r < a; ++r) e[r].checkUniforms && e[r].checkUniforms(t);
        var n = new GL.Material(t);
        return t.callback ? n._callbackOnDrawMesh = t.callback : t.useMeshColors && (t.useTexture ? n._callbackOnDrawMesh = f : n._callbackOnDrawMesh = p), n
    };
    var R = null;
    GL.Material.FixedColorVariablePointSize = function (t) {
        (t = t || {}).uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [.5, .5, .5, 1], t.name = t.name || "FixedColorVariablePointSize", t.mode = pd.toInteger(t.mode, M.POINTS), t.shader = R;
        var e = GL.Material.compose(t, [GL.ShaderComponent.POINT_SIZE_ATTRIBUTE, GL.ShaderComponent.COLOR_UNIFORM]);
        return R || (R = e._shader), e
    };
    var F = null;
    GL.Material.FixedColorUniformPointSize = function (t) {
        (t = t || {}).uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [.2, .2, .2, 1], t.name = t.name || "FixedColorUniformPointSize", t.shader = F;
        var e = GL.Material.compose(t, [GL.ShaderComponent.POINT_SIZE_UNIFORM, GL.ShaderComponent.COLOR_UNIFORM]);
        return F || (F = e._shader), e
    };
    var G = null;
    GL.Material.TexturedFixedColorUniformPointSize = function (t) {
        (t = t || {}).uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [.2, .2, .2, 1], t.name = t.name || "TexturedFixedColorUniformPointSize", t.shader = G, t.uniforms.useTexture = !0;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_UNIFORM, GL.ShaderComponent.TEXTURE]);
        return G || (G = e._shader), e
    };
    var I = null;
    GL.Material.VariableColorUniformPointSize = function (t) {
        (t = t || {}).uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [0, 0, 0, 1], t.name = t.name || "VariableColorUniformPointSize", t.shader = I;
        var e = GL.Material.compose(t, [GL.ShaderComponent.POINT_SIZE_UNIFORM, GL.ShaderComponent.COLOR_ATTRIBUTE]);
        return I || (I = e._shader), e
    };
    var V = null;
    GL.Material.TexturedVariableColorUniformPointSize = function (t) {
        (t = t || {}).uniforms = t.uniforms || {}, t.uniforms.color = t.uniforms.color || [0, 0, 0, 1], t.name = t.name || "TexturedVariableColorUniformPointSize", t.shader = V;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_ATTRIBUTE, GL.ShaderComponent.TEXTURE]);
        return V || (V = e._shader), e
    };
    var U = null;
    GL.Material.DefaultShader = function () {
        return null == U && (U = m([GL.ShaderComponent.COLOR_BLINNPHONG])), U
    }, GL.Material.BlinnPhongColor = function (t) {
        (t = t || {}).name = t.name || "BlinnPhongColor", t.shader = U;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_BLINNPHONG]);
        return U || (U = e._shader), e
    };
    var k = null;
    GL.Material.TexturedBlinnPhongColor = function (t) {
        (t = t || {}).name = t.name || "TexturedBlinnPhongColor", t.shader = k;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_BLINNPHONG, GL.ShaderComponent.TEXTURE]);
        return k || (k = e._shader), e
    };
    var z = null;
    GL.Material.BlinnPhongColorShadow = function (t) {
        (t = t || {}).name = t.name || "BlinnPhongColorShadow", t.shader = z;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_BLINNPHONG, GL.ShaderComponent.SHADOW_MAP]);
        return z || (z = e._shader), e
    };
    GL.Material.TexturedBlinnPhongColorShadow = function (t) {
        (t = t || {}).name = t.name || "TexturedBlinnPhongColorShadow", t.shader = null;
        var e = GL.Material.compose(t, [GL.ShaderComponent.COLOR_BLINNPHONG, GL.ShaderComponent.SHADOW_MAP, GL.ShaderComponent.TEXTURE]);
        return z || (z = e._shader), e
    };
    var W = null;
    GL.Material.DepthMapShader = function (t) {
        return t = t || {}, t.name = t.name || "DepthMapShader", t.shader = g(), new GL.Material(t)
    }, GL.Material.BlinnPhongWithGrid = function (t) {
        (t = t || {}).name = t.name || "BlinnPhongWithGrid" + (t.useShadowMap ? "WithShadows" : "");
        var e = {
            vertHead: "\nvarying vec3 vNrm;\nvarying float vDist;\nvarying vec3 vPos;\n",
            vertMain: "\n    vNrm = gl_Normal.xyz;\n    vDist = gl_Position.w;\n    vPos = gl_Vertex.xyz;\n",
            fragHead: "\nuniform float modelSize;\nuniform float gridMinor;\nuniform float gridMajor;\nuniform vec4 gridColor;\n\nvarying vec3 vNrm;\nvarying float vDist;\nvarying vec3 vPos;\n\nfloat lineWidth = 0.0;\n\nfloat map(float value, float from1, float to1, float from2, float to2) {\n    float v = ((value - from1) / (to1 - from1) * (to2 - from2)) + from2;\n    return clamp(v, from2, to2);\n}\n\nfloat gridEffect(float nrm_1, float pos_1, float nrm_2, float pos_2) {\n    float grid1 = 2.5 * (1.0 - abs(nrm_1)) * (mod(pos_1, gridMinor) / lineWidth);\n    float grid2 = 2.5 * (1.0 - abs(nrm_2)) * (mod(pos_2, gridMinor) / lineWidth);\n    float grid3 = (1.0 - abs(nrm_1)) * (mod(pos_1, gridMajor) / lineWidth);\n    float grid4 = (1.0 - abs(nrm_2)) * (mod(pos_2, gridMajor) / lineWidth);\n    float g_max = min(max(grid1, grid2), max(grid3, grid4));\n    return (g_max > 0.99) ? 0.0 : clamp(1.0 - (g_max * g_max), 0.0, 1.0);\n}\n\nfloat gridFactor(in vec3 nrm, in vec3 pos) {\n    float _xy = gridEffect(nrm.x, pos.x, nrm.y, pos.y);\n    float _yz = gridEffect(nrm.y, pos.y, nrm.z, pos.z);\n    float _xz = gridEffect(nrm.x, pos.x, nrm.z, pos.z);\n    _xy = (abs(nrm.z) > 0.5) ? 0.0 : _xy;\n    _yz = (abs(nrm.x) > 0.5) ? 0.0 : _yz;\n    _xz = (abs(nrm.y) > 0.5) ? 0.0 : _xz;\n    return max(_xy, max(_yz, _xz));\n}\n",
            fragMain: "",
            fragColor: "\n    lineWidth = 0.00175 * vDist;\n    float grid_factor = gridColor.a * gridFactor(vNrm, vPos);\n    grid_factor = map(lineWidth, modelSize, 0.0, 0.0, grid_factor);\n    color = mix(color, gridColor.xyz, grid_factor);\n    gl_FragColor = vec4(color, alpha);\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.modelSize = t.uniforms.modelSize || 1, t.uniforms.gridMajor = t.uniforms.gridMajor || 1e3, t.uniforms.gridMinor = t.uniforms.gridMinor || 200, Array.isArray(t.uniforms.gridColor) ? t.uniforms.gridColor.length < 4 && (t.uniforms.gridColor[3] = 1) : t.uniforms.gridColor = [0, 0, 0, 1]
            }
        }, i = [GL.ShaderComponent.COLOR_BLINNPHONG];
        return t.useShadowMap && i.push(GL.ShaderComponent.SHADOW_MAP), i.push(e), GL.Material.compose(t, i)
    }, GL.Material.RectangularBlockWithGrid = function (t) {
        t = t || {};
        var e = {
            vertHead: "\nvarying vec3 vNrm;\nvarying vec3 vPos;\n",
            vertMain: "\n    vNrm = gl_Normal.xyz;\n    vPos = gl_Vertex.xyz;\n",
            fragHead: "\nuniform float lineWidth;\nuniform float edgeEffect;\nuniform float gridMinor;\nuniform float gridMajor;\nuniform vec3 gridColor;\n\nvarying vec3 vNrm;\nvarying vec3 vPos;\n\nconst vec3 darkColor = vec3(0.0, 0.0, 0.0);\n\nfloat gridEffect(float nrm_1, float pos_1, float nrm_2, float pos_2) {\n    float grid1 = 2.5 * (1.0 - abs(nrm_1)) * (mod(pos_1, gridMinor) / lineWidth);\n    float grid2 = 2.5 * (1.0 - abs(nrm_2)) * (mod(pos_2, gridMinor) / lineWidth);\n    float grid3 = (1.0 - abs(nrm_1)) * (mod(pos_1, gridMajor) / lineWidth);\n    float grid4 = (1.0 - abs(nrm_2)) * (mod(pos_2, gridMajor) / lineWidth);\n    float g_max = min(max(grid1, grid2), max(grid3, grid4));\n    return (g_max > 0.95) ? 0.0 : clamp(1.0 - g_max, 0.0, 1.0);\n}\n\nfloat gridFactor(in vec3 nrm, in vec3 pos) {\n    float _xy = gridEffect(nrm.x, pos.x, nrm.y, pos.y);\n    float _yz = gridEffect(nrm.y, pos.y, nrm.z, pos.z);\n    float _xz = gridEffect(nrm.x, pos.x, nrm.z, pos.z);\n    _xy = (abs(nrm.z) > 0.5) ? 0.0 : _xy;\n    _yz = (abs(nrm.x) > 0.5) ? 0.0 : _yz;\n    _xz = (abs(nrm.y) > 0.5) ? 0.0 : _xz;\n    return max(_xy, max(_yz, _xz));\n}\n",
            fragMain: "\n    float darken = 0.0;\n    if ((abs(vNrm.z) < 0.5) || (abs(vPos.z) > edgeEffect)) {\n        darken = 1.0 - clamp(vPos.z / edgeEffect, 0.0, 1.0);\n    }\n",
            fragColor: "\n    color = mix(color, darkColor, 0.35 * (1.0 - (0.5 * ambientColor)) * darken * darken);\n    float grid_factor = (lineWidth > 1e-3) ? 0.35 * gridFactor(vNrm, vPos) : 0.0;\n    color = mix(color, gridColor, grid_factor);\n    gl_FragColor = vec4(color, alpha);\n",
            checkUniforms: function (t) {
                t.uniforms = t.uniforms || {}, t.uniforms.lineWidth = t.uniforms.lineWidth || 1, t.uniforms.edgeEffect = t.uniforms.edgeEffect || 1e3, t.uniforms.gridColor = t.uniforms.gridColor || [0, 0, 0], t.uniforms.gridMajor = t.uniforms.gridMajor || 1e3, t.uniforms.gridMinor = t.uniforms.gridMinor || 200
            }
        }, i = [GL.ShaderComponent.COLOR_BLINNPHONG];
        return t.useShadowMap && i.push(GL.ShaderComponent.SHADOW_MAP), i.push(e), GL.Material.compose(t, i)
    }, pd3D.Node.prototype.drawWithMaterial = function (t, e) {
        if (this.visible && t) {
            this.callbackOnDraw && this.callbackOnDraw(this, e, t), this.transformMatrix && (M.pushMatrix(), M.multMatrix(this.transformMatrix), t._rendering && t._shader.prepareMatrices());
            for (var i in this.geometry) this.geometry.hasOwnProperty(i) && t.renderMeshes(this.geometry[i].meshes, e);
            for (var r, a = 0, n = this.children.length; a < n; a++) (r = this.children[a]) && r.drawWithMaterial && r.drawWithMaterial(t, e);
            this.transformMatrix && M.popMatrix()
        }
        return this
    }, pd3D.Node.prototype._render = function (t) {
        this.callbackOnDraw && this.callbackOnDraw(this, t), this.transformMatrix && (M.pushMatrix(), M.multMatrix(this.transformMatrix));
        for (var e in this.geometry) if (this.geometry.hasOwnProperty(e)) {
            var i = this.geometry[e];
            i.material.draw(i.meshes, t)
        }
        for (var r, a = 0, n = this.children.length; a < n; a++) (r = this.children[a]) && r.draw && r.draw(t);
        return this.transformMatrix && M.popMatrix(), this
    }, pd3D.Node.prototype.drawOutlines = function (t) {
        return t ? this.drawWithMaterial(t, M.LINES) : this.visible && this._render(M.LINES), this
    }, pd3D.Node.prototype.drawSurfaces = function (t) {
        return t ? this.drawWithMaterial(t, M.TRIANGLES) : this.visible && this._render(M.TRIANGLES), this
    }, pd3D.Node.prototype.draw = function (t) {
        return this.visible && this._render(t), this
    }, GL.CachedUniform = function (t) {
        t = t || {}, this.name = t.name || "", this.value = t.value || null, this.method = t.method || null, this.isMatrix = pd.toBoolean(t.isMatrix, !1), this.stale = pd.toBoolean(t.stale, !0)
    }, GL.CachedUniform.createOrUpdate = function (t, e, r) {
        if (r || (r = new GL.CachedUniform), r.stale = !0, r.name = t, e instanceof pd3D.Vector ? e = [e.x, e.y, e.z] : e instanceof pd3D.Matrix && (e = e.m), i(e)) switch (e.length) {
            case 1:
                r.method = M.uniform1fv, r.value = new Float32Array(e);
                break;
            case 2:
                r.method = M.uniform2fv, r.value = new Float32Array(e);
                break;
            case 3:
                r.method = M.uniform3fv, r.value = new Float32Array(e);
                break;
            case 4:
                r.method = M.uniform4fv, r.value = new Float32Array(e);
                break;
            case 9:
                r.isMatrix = !0, r.method = M.uniformMatrix3fv, r.value = new Float32Array([e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]]);
                break;
            case 16:
                r.isMatrix = !0, r.method = M.uniformMatrix4fv, r.value = new Float32Array([e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]]);
                break;
            default:
                throw'Cannot pre-process uniform "' + t + '" of length ' + e.length
        } else if ("boolean" == typeof e) r.method = M.uniform1i, r.value = !0 === e ? 1 : 0; else {
            if (!pd.isNumeric(e)) throw'Attempted to set uniform "' + t + '" to invalid value ' + e;
            r.method = M.uniform1f, r.value = e
        }
        return r
    }, GL.CachedUniform.createOrUpdateTexture = function (t, e, i) {
        return i || (i = new GL.CachedUniform), i.name = t, i.value = pd.toInteger(e, 1), i.method = M.uniform1i, i.isMatrix = !1, i.stale = !0, i
    };
    var B = "pd_web", H = -1;
    GL.Shader = function (t, e) {
        function i(t) {
            if (!/\s/.test(t)) {
                var e = document.getElementById(t);
                return e ? e.text : t
            }
            return t
        }

        function r(t, e) {
            var i = {}, r = /^((\s*\/\/.*\n|\s*#extension.*\n)+)\^*$/.exec(e);
            return e = r ? r[1] + t + e.substr(r[1].length) : t + e, v(/\bgl_\w+\b/g, t, function (t) {
                t in i || (e = e.replace(new RegExp("\\b" + t + "\\b", "g"), B + t), i[t] = !0)
            }), e
        }

        function a(t, e) {
            var i = M.createShader(t);
            if (M.shaderSource(i, e), M.compileShader(i), !M.getShaderParameter(i, M.COMPILE_STATUS)) throw"compile error: " + M.getShaderInfoLog(i);
            return i
        }

        var n = "uniform mat3 gl_NormalMatrix;\nuniform mat4 gl_ModelViewMatrix;\nuniform mat4 gl_ProjectionMatrix;\nuniform mat4 gl_ModelViewProjectionMatrix;\nuniform mat4 gl_ModelViewMatrixInverse;\nuniform mat4 gl_ProjectionMatrixInverse;\nuniform mat4 gl_ModelViewProjectionMatrixInverse;\n",
            o = (t = i(t)) + (e = i(e)), s = {};
        if (v(/\b(gl_[^;]*)\b;/g, n, function (t) {
                var e = t[1];
                if (-1 != o.indexOf(e)) {
                    var i = e.replace(/[a-z_]/g, "");
                    s[i] = B + e
                }
            }), -1 != o.indexOf("ftransform") && (s.MVPM = B + "gl_ModelViewProjectionMatrix"), this.usedMatrices = s, t = r("uniform mat3 gl_NormalMatrix;\nuniform mat4 gl_ModelViewMatrix;\nuniform mat4 gl_ProjectionMatrix;\nuniform mat4 gl_ModelViewProjectionMatrix;\nuniform mat4 gl_ModelViewMatrixInverse;\nuniform mat4 gl_ProjectionMatrixInverse;\nuniform mat4 gl_ModelViewProjectionMatrixInverse;\nattribute vec4 gl_Vertex;\nattribute vec4 gl_TexCoord;\nattribute vec3 gl_Normal;\nattribute vec4 gl_Color;\n", t), e = r("precision highp float;\nuniform mat3 gl_NormalMatrix;\nuniform mat4 gl_ModelViewMatrix;\nuniform mat4 gl_ProjectionMatrix;\nuniform mat4 gl_ModelViewProjectionMatrix;\nuniform mat4 gl_ModelViewMatrixInverse;\nuniform mat4 gl_ProjectionMatrixInverse;\nuniform mat4 gl_ModelViewProjectionMatrixInverse;\n", e), this.program = M.createProgram(), M.attachShader(this.program, a(M.VERTEX_SHADER, t)), M.attachShader(this.program, a(M.FRAGMENT_SHADER, e)), M.linkProgram(this.program), !M.getProgramParameter(this.program, M.LINK_STATUS)) throw"link error: " + M.getProgramInfoLog(this.program);
        this.attributes = {}, this.uniformLocations = {};
        var l = {};
        v(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, t + e, function (t) {
            l[t[2]] = 1
        }), this.isSampler = l
    }, GL.Shader.prototype = {
        makeCurrent: function () {
            return H != this.program && (H = this.program, M.useProgram(this.program)), this
        }, createCachedUniform: function (t, e, i) {
            return pd.isInteger(e) && this.isSampler[t] ? GL.CachedUniform.createOrUpdateTexture(t, e, i) : GL.CachedUniform.createOrUpdate(t, e, i)
        }, setCachedUniformValue: function (t) {
            var e = t.name, i = this.uniformLocations[e];
            return i || (i = M.getUniformLocation(this.program, e), this.uniformLocations[e] = i), i && (t.isMatrix ? t.method.call(M, i, !1, t.value) : t.method.call(M, i, t.value)), t.stale = !1, this
        }, setCachedUniformValues: function (t) {
            this.makeCurrent();
            for (var e in t) this.setCachedUniformValue(t[e]);
            return this
        }, uniforms: function (t) {
            this.makeCurrent();
            for (var e in t) {
                var a = this.uniformLocations[e];
                if (a || (a = M.getUniformLocation(this.program, e), this.uniformLocations[e] = a), a) {
                    var n = t[e];
                    if ("function" == typeof n && (n = n()), n instanceof pd3D.Vector ? n = [n.x, n.y, n.z] : n instanceof pd3D.Matrix && (n = n.m), i(n)) switch (n.length) {
                        case 1:
                            M.uniform1fv(a, new Float32Array(n));
                            break;
                        case 2:
                            M.uniform2fv(a, new Float32Array(n));
                            break;
                        case 3:
                            M.uniform3fv(a, new Float32Array(n));
                            break;
                        case 4:
                            M.uniform4fv(a, new Float32Array(n));
                            break;
                        case 9:
                            M.uniformMatrix3fv(a, !1, new Float32Array([n[0], n[3], n[6], n[1], n[4], n[7], n[2], n[5], n[8]]));
                            break;
                        case 16:
                            M.uniformMatrix4fv(a, !1, new Float32Array([n[0], n[4], n[8], n[12], n[1], n[5], n[9], n[13], n[2], n[6], n[10], n[14], n[3], n[7], n[11], n[15]]));
                            break;
                        default:
                            throw"don't know how to load array uniform \"" + e + '" of length ' + n.length
                    } else if ("boolean" == typeof n) M.uniform1i(a, !0 === n ? 1 : 0); else {
                        if (!r(n)) throw'attempted to set uniform "' + e + '" to invalid value ' + n;
                        (this.isSampler[e] ? M.uniform1i : M.uniform1f).call(M, a, n)
                    }
                }
            }
            return this
        }, prepareMatrices: function () {
            this.makeCurrent();
            var t = {}, e = this.usedMatrices;
            if (e.MVM && (t[e.MVM] = M.modelviewMatrix), (e.MVMI || e.NM) && (t[e.MVMI] = M.modelviewMatrix.inverse()), e.PM && (t[e.PM] = M.projectionMatrix), e.PMI && (t[e.PMI] = M.projectionMatrix.inverse()), e.MVPM && (t[e.MVPM] = M.getModelviewProjectionMatrix()), e.MVPMI && (t[e.MVPMI] = M.getModelviewProjectionMatrix().inverse()), e.NM) {
                var i = t[e.MVMI].m;
                t[e.NM] = [i[0], i[4], i[8], i[1], i[5], i[9], i[2], i[6], i[10]]
            }
            this.lastFrameIndex = M.frameIndex;
            for (var r in t) {
                var a, n = this.uniformLocations[r];
                n || (n = M.getUniformLocation(this.program, r), this.uniformLocations[r] = n), n && ((a = t[r]) instanceof pd3D.Matrix && (a = a.m), a && (9 == a.length ? M.uniformMatrix3fv(n, !1, new Float32Array([a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]])) : 16 == a.length && M.uniformMatrix4fv(n, !1, new Float32Array([a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]]))))
            }
            return this
        }, prepareAttributes: function (t) {
            var e = 0;
            for (var i in t) {
                var r = t[i],
                    a = this.attributes[i] || M.getAttribLocation(this.program, i.replace(/^(gl_.*)$/, B + "$1"));
                a >= 0 && r.buffer && (this.attributes[i] = a, M.bindBuffer(M.ARRAY_BUFFER, r.buffer), M.enableVertexAttribArray(a), M.vertexAttribPointer(a, r.buffer.spacing, M.FLOAT, !1, 0, 0), e = r.buffer.length / r.buffer.spacing)
            }
            for (var i in this.attributes) i in t || M.disableVertexAttribArray(this.attributes[i]);
            return e
        }, renderPrimitive: function (t, e, i) {
            var r = this.prepareAttributes(t);
            return !r || e && !e.buffer || (e ? (M.bindBuffer(M.ELEMENT_ARRAY_BUFFER, e.buffer), M.drawElements(i, e.buffer.length, M.UNSIGNED_SHORT, 0)) : M.drawArrays(i, 0, r)), this
        }, renderMultiplePrimitives: function (t, e, i) {
            var r = this.prepareAttributes(t);
            if (r && (!e || e.buffer)) {
                var a;
                if (e) {
                    M.bindBuffer(M.ELEMENT_ARRAY_BUFFER, e.buffer);
                    for (var n = 0, o = i.length; n < o; ++n) (a = i[n]).mode && a.stop > a.start && a.stop <= e.buffer.length && M.drawElements(a.mode, a.stop - a.start, M.UNSIGNED_SHORT, 2 * a.start)
                } else for (var n = 0, o = i.length; n < o; ++n) (a = i[n]).mode && a.stop > a.start && a.stop <= r && M.drawArrays(a.mode, a.start, a.stop - a.start)
            }
            return this
        }, draw: function (t, e) {
            return t && t.visible && (e = pd.isNumeric(e) ? e : M.TRIANGLES, this.prepareMatrices(), this.renderPrimitive(t.vertexBuffers, t.indexBuffers[GL.Shader.getIndexBufferName(e)], e)), this
        }, destroy: function () {
            if (this.program) {
                for (var t = 0, e = M.getAttachedShaders(this.program).length; t < e; ++t) M.detachShader(this.program, shader[t]), M.deleteShader(shader[t]);
                M.deleteProgram(this.program)
            }
            return this
        }
    }, GL.Shader.getIndexBufferName = function (t) {
        switch (t = pd.isNumeric(t) ? t : M.TRIANGLES) {
            case M.POINTS:
                return "points";
            case M.LINES:
            case M.LINE_LOOP:
            case M.LINE_STRIP:
                return "lines";
            case M.TRIANGLES:
            case M.TRIANGLE_STRIP:
            case M.TRIANGLE_FAN:
                return "triangles";
            default:
                return "index"
        }
    }, GL.Shader.fromURL = function (t, e) {
        var i = function (t) {
            var e = new XMLHttpRequest;
            if (e.open("GET", t, !1), e.send(null), 200 !== e.status) throw"could not load " + t;
            return e.responseText
        }, r = i(t), a = i(e);
        return new GL.Shader(r, a)
    }, GL.Shader.from = function (t, e) {
        try {
            return new GL.Shader(t, e)
        } catch (i) {
            return GL.Shader.fromURL(t, e)
        }
    }
}(), pdWGL.SubSolar3D = function (t, e) {
    function i() {
        A = pd3D.Vector.fromArray(l).length();
        var t = E.solarArrow;
        t.triangles.length = 0, t.vertices.length = 0, t.lines.length = 0;
        var e = .04 * s * _, i = pd3D.Font.weight();
        if (pd3D.Font.weight(500), w > .1) {
            var a = 1.1 * s * _, n = .02 * s * _;
            t.color(f), t.addVertex([l[0], l[1], l[2]]), t.addVertex([l[0], l[1], l[2] + a]), a -= w * n, t.addVertex([l[0], l[1] - n, l[2] + a]), t.addVertex([l[0], l[1] + n, l[2] + a]), t.lines.push([0, 1]), t.lines.push([1, 2]), t.lines.push([1, 3]), a = 1.115 * s * _, pd3D.Matrix.scale(e, e, e, P), pd3D.Matrix.translate(l[0], l[1], l[2] + a, O), O.multiplyBy(pd3D.Matrix.rotate(-90, 0, 1, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.LEFT, pd.Align.CENTER, O, t)
        } else t.color(f), t.addVertex([l[0], l[1], l[2]]), t.addVertex([l[0], l[1], l[2] + s]), t.color([f[0], f[1], f[2], 0]), t.addVertex([l[0], l[1], l[2] + 10 * s]), t.lines.push([0, 1]), t.lines.push([1, 2]);
        t.compile(), E.solarSphere.vertices = E.solarSphere.vertices.map(function (t) {
            return pd3D.Vector.fromArray(t).normalize().scale(s * _ * .005).toArray()
        }), E.solarSphere.compile();
        var o = E.baseDiagram;
        o.triangles.length = 0, o.vertices.length = 0, o.lines.length = 0;
        for (var d, u, c = 0, m = h.year(), p = 2 * Math.PI, g = Math.PI / 36, v = 1.015 * s, M = 1.075 * s, y = 1.045 * s, D = p + .25 * g, L = 0, C = 0, b = 0; b < D; b += g) d = Math.sin(b), u = Math.cos(b), o.vertices.push([l[0] + s * d, l[1] + s * u, l[2]]), L % 9 ? (o.vertices.push([l[0] + v * d, l[1] + v * u, l[2]]), C % 2 || (o.triangles.push([c - 2, c, c - 1]), o.triangles.push([c - 1, c, c + 1]))) : (C = 0, L % 18 ? o.vertices.push([l[0] + y * d, l[1] + y * u, l[2]]) : o.vertices.push([l[0] + M * d, l[1] + M * u, l[2]])), b > 0 && (o.lines.push([c, c + 1]), o.lines.push([c - 2, c]), o.lines.push([c - 1, c + 1])), C++, L++, c += 2;
        o.lines.push([0, 72]), o.lines.push([36, 108]), o.compile();
        var N = E.baseDiagramText;
        N.vertices.length = 0, N.lines.length = 0;
        var R, F;
        e = .02 * s, pd3D.Matrix.scale(e, e, e, P);
        for (b = -135; b <= 180; b += 45) R = (90 - b) * pd.Const.DEG2RAD, F = b % 90 ? 1.075 * s : 1.1 * s, pd3D.Matrix.translate(l[0] + F * Math.sin(R), l[1] + F * Math.cos(R), l[2], O), O.multiplyBy(pd3D.Matrix.rotate(90 + b, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText(b.toFixed(0) + "`", pd.Align.CENTER, pd.Align.CENTER, O, N);
        N.compile();
        var G = E.annualShell;
        G.triangles.length = 0, G.vertices.length = 0;
        for (var I, V, U = 0, k = 0, z = 0, W = 0, B = 0, H = [171, 211, 231, 252, 272, 292, 313, 354], c = H.length - 1; c >= 0; c--) {
            if (V = H[c], T.setDayOfYear(Math.round(V), m).calculate(), T.getHourlySunPathAsPositions3D(.25, S, 1.0025 * s, !1, G), 0 == z && (z = G.vertices.length), U > 0) {
                B = U, W = k;
                for (j = 1; j < z - 1; j++) G.triangles.push([W, B, B + 1]), G.triangles.push([B + 1, W + 1, W]), W++, B++;
                G.triangles.push([W, B, U]), G.triangles.push([U, k, W]), k = U
            }
            for (var j = U, X = G.vertices.length; j < X; j++) I = G.vertices[j], G.normals.push([I[0] / s, I[1] / s, I[2] / s]);
            U = G.vertices.length
        }
        G.compile();
        var Y = E.currentAnalemma;
        Y.vertices.length = 0, Y.lines.length = 0, T.setDayMonthYear(21, 5, m).calculate(), T.setTimeOfDay(T.solarNoon()), T.getAnalemmaSunPathAsPositions3D(x, S, s, !1, Y), Y.compile();
        var K = E.tropicsLines;
        K.vertices.length = 0, K.lines.length = 0;
        for (var Z, J, Q, q = 0, $ = 23.43731 * pd.Const.DEG2RAD, tt = s * Math.cos($), et = s * Math.sin($), b = 0; b < D; b += g) Z = l[0] + tt * Math.sin(b), J = l[1] - tt * Math.cos(b), K.vertices.push([Z, J, l[2] - et]), K.vertices.push([Z, J, l[2] + et]), (q += 2) >= 4 && (K.lines.push([q - 4, q - 2]), K.lines.push([q - 3, q - 1]));
        Z = l[0], J = l[1] - 1.125 * tt, Q = l[2] + (et + 1.75 * e), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(90, 0, 0, 1)), O.multiplyBy(pd3D.Matrix.rotate(90, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.RIGHT, pd.Align.CENTER, O, K), J = l[1] - 1.1 * tt, K.vertices.push([Z, J, Q]), q = K.vertices.length, J = l[1] - 1.05 * tt, K.vertices.push([Z, J, Q]), K.lines.push([q - 1, q]), q++, J = l[1] - 1.01 * tt, Q = l[2] + et + .01 * tt, K.vertices.push([Z, J, Q]), K.lines.push([q - 1, q]), q++, Z = l[0], J = l[1] - 1.125 * tt, Q = l[2] - (et + 1.75 * e), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(90, 0, 0, 1)), O.multiplyBy(pd3D.Matrix.rotate(90, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.RIGHT, pd.Align.CENTER, O, K), J = l[1] - 1.1 * tt, K.vertices.push([Z, J, Q]), q = K.vertices.length, J = l[1] - 1.05 * tt, K.vertices.push([Z, J, Q]), K.lines.push([q - 1, q]), q++, J = l[1] - 1.01 * tt, Q = l[2] - et - .02 * tt, K.vertices.push([Z, J, Q]), K.lines.push([q - 1, q]), q++, K.compile();
        var it = E.circleLines;
        it.vertices.length = 0, it.lines.length = 0;
        var rt = 66.5605 * pd.Const.DEG2RAD, at = s * Math.cos(rt), nt = s * Math.sin(rt);
        q = 0;
        for (b = 0; b < D; b += g) Z = l[0] + at * Math.sin(b), J = l[1] - at * Math.cos(b), it.vertices.push([Z, J, l[2] - nt]), it.vertices.push([Z, J, l[2] + nt]), (q += 2) >= 4 && (it.lines.push([q - 4, q - 2]), it.lines.push([q - 3, q - 1]));
        Z = l[0], J = l[1] - 1.25 * at, Q = l[2] + (nt + 2 * e), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(90, 0, 0, 1)), O.multiplyBy(pd3D.Matrix.rotate(90, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.RIGHT, pd.Align.CENTER, O, it), J = l[1] - 1.2 * at, it.vertices.push([Z, J, Q]), q = it.vertices.length, J = l[1] - 1.1 * at, it.vertices.push([Z, J, Q]), it.lines.push([q - 1, q]), q++, J = l[1] - 1.03 * at, Q = l[2] + nt + .03 * at, it.vertices.push([Z, J, Q]), it.lines.push([q - 1, q]), q++, Z = l[0], J = l[1] - 1.25 * at, Q = l[2] - (nt + 2 * e), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(90, 0, 0, 1)), O.multiplyBy(pd3D.Matrix.rotate(90, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.RIGHT, pd.Align.CENTER, O, it), J = l[1] - 1.2 * at, it.vertices.push([Z, J, Q]), q = it.vertices.length, J = l[1] - 1.1 * at, it.vertices.push([Z, J, Q]), it.lines.push([q - 1, q]), q++, J = l[1] - 1.03 * at, Q = l[2] - nt - .03 * at, it.vertices.push([Z, J, Q]), it.lines.push([q - 1, q]), q++, it.compile();
        var ot = E.twilightLines;
        ot.vertices.length = 0, ot.lines.length = 0;
        var st = E.declinationPlane;
        st.vertices.length = 0, st.lines.length = 0;
        var lt = 0, ht = -.83333 * pd.Const.DEG2RAD, dt = s * Math.cos(ht), ut = s * Math.sin(ht),
            ct = -6 * pd.Const.DEG2RAD, mt = s * Math.cos(ct), pt = s * Math.sin(ct), ft = -12 * pd.Const.DEG2RAD,
            gt = s * Math.cos(ft), vt = s * Math.sin(ft), Mt = -18 * pd.Const.DEG2RAD, xt = s * Math.cos(Mt),
            yt = s * Math.sin(Mt);
        g *= .125, q = 0;
        for (b = 0; b < D; b += g) Z = l[0] + s * Math.sin(b), J = l[1] + s * Math.cos(b), ot.vertices.push([Z, J, l[2]]), Z = l[0] + mt * Math.sin(b), J = l[1] - mt * Math.cos(b), ot.vertices.push([Z, J, l[2] + pt]), Z = l[0] + gt * Math.sin(b), J = l[1] - gt * Math.cos(b), ot.vertices.push([Z, J, l[2] + vt]), Z = l[0] + xt * Math.sin(b), J = l[1] - xt * Math.cos(b), ot.vertices.push([Z, J, l[2] + yt]), (q += 4) % 8 || (ot.lines.push([q - 8, q - 4]), ot.lines.push([q - 7, q - 3]), ot.lines.push([q - 6, q - 2]), ot.lines.push([q - 5, q - 1]), Z = l[0] + dt * Math.sin(b), J = l[1] + dt * Math.cos(b), st.vertices.push([Z, J, l[2] + ut]), lt > 0 && st.lines.push([lt - 1, lt]), lt++);
        var Dt = 1.25 * s;
        q = st.vertices.length, Z = l[0] + Dt, J = l[1] + Dt, Q = l[2] + ut, st.vertices.push([Z, J, Q]), J = l[1] - Dt, st.vertices.push([Z, J, Q]), Z = l[0] - Dt, st.vertices.push([Z, J, Q]), J = l[0] + Dt, st.vertices.push([Z, J, Q]), st.lines.push([lt + 0, lt + 1]), st.lines.push([lt + 1, lt + 2]), st.lines.push([lt + 2, lt + 3]), st.lines.push([lt + 3, lt + 0]), c = 0;
        for (var wt = 0, _t = Math.floor(q / 4), j = 0; j < q; j++) j > 0 && st.triangles.push([j - 1, j, lt + wt]), ++c > _t && (st.triangles.push([lt + wt, j, lt + wt + 1]), wt++, c = 0);
        st.triangles.push([lt + 3, 0, lt]), q = st.vertices.length, e = .0175 * s, pd3D.Matrix.scale(e, e, e, P), Z = l[0], J = l[1] + .501 * (dt + mt), Q = l[2] + .5 * (ut + pt), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(-93, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.CENTER, pd.Align.CENTER, O, ot), J = l[1] + .501 * (mt + gt), Q = l[2] + .5 * (pt + vt), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(-98, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.CENTER, pd.Align.CENTER, O, ot), J = l[1] + .501 * (gt + xt), Q = l[2] + .5 * (vt + yt), pd3D.Matrix.translate(Z, J, Q, O), O.multiplyBy(pd3D.Matrix.rotate(-105, 1, 0, 0)), O.multiplyBy(P), pd3D.Font.addText("", pd.Align.CENTER, pd.Align.CENTER, O, ot), ot.compile(), st.compile();
        var At = E.currentSunPath;
        At.vertices.length = 0, At.lines.length = 0, q = 0;
        for (b = 0; b < D; b += g) Z = l[0] + s * Math.sin(b), Q = l[2] + s * Math.cos(b), At.vertices.push([Z, l[1], Q]), ++q % 2 || At.lines.push([q - 1, q]);
        At.compile(), pd3D.Font.weight(i), r()
    }

    function r() {
        b.reset().rotate(h.timezoneCorrection() / 24 * 360, 0, -1, 0), a()
    }

    function a() {
        T.setDayOfYear(h.dayOfYear(), h.year());
        var t = T.declinationAngle() * pd.Const.DEG2RAD, e = Math.sin(t) * s, i = Math.cos(t);
        C.reset().translate(0, e, 0).scale(i, i, i)
    }

    var n = this, o = t, s = (e = e || {}).radius || 1e3, l = e.center || [0, 0, 0],
        h = e.solarPosition || new pd.SolarPosition, d = e.thinLineWidth || (pdDOM.devicePixelRatio < 1.25 ? .75 : 1.5),
        u = e.thickLineWidth || (pdDOM.devicePixelRatio < 1.25 ? 1.55 : 2.5),
        c = e.colorCurrentDateTime || [1, 0, 0, 1], m = e.colorDiagramLines || [1, 1, 1, 1],
        p = e.colorDiagramText || [.8, .8, .8, 1], f = e.colorSolarArrow || [.7, .7, .4, 1],
        g = e.colorSunPathLines || [.8, .5, .1, 1], v = e.colorSunPathMesh || [1, 1, 0, .1],
        M = e.colorTropicsLines || [1, 1, 0, 1], x = pd.constrainTo(e.dayIncrement || 2, 1, 30),
        y = e.monthlyLinesDay || 21, D = e.arrowScale || 1, w = e.arrowStyle || 0, _ = e.arrowSize || 1.5, A = 0,
        T = (new pd.SolarPosition).setLocation(0, 0, 0), L = new pd3D.MatrixAccumulator, C = new pd3D.MatrixAccumulator,
        b = new pd3D.MatrixAccumulator, S = [0, 0, 0], E = {
            annualShell: new pd3D.Mesh({normals: !0, lines: !0}),
            baseDiagram: new pd3D.Mesh({triangles: !0, lines: !0}),
            baseDiagramText: new pd3D.Mesh({triangles: !1, lines: !0, noCullFace: !0}),
            monthlySunPaths: new pd3D.Mesh({triangles: !1, lines: !0, visible: !1}),
            currentSunPath: new pd3D.Mesh({triangles: !1, lines: !0}),
            currentAnalemma: new pd3D.Mesh({triangles: !1, lines: !0}),
            solarArrow: new pd3D.Mesh({triangles: !0, colors: !0, lines: !0, noCullFace: !0}),
            solarSphere: new pd3D.Shapes.sphere({radius: .0125 * s}),
            declinationPlane: new pd3D.Mesh({triangles: !0, lines: !0, noCullFace: !0}),
            declinationAngle: new pd3D.Mesh({triangles: !0, lines: !0, points: !0, noCullFace: !0}),
            twilightLines: new pd3D.Mesh({triangles: !0, lines: !0}),
            tropicsLines: new pd3D.Mesh({triangles: !0, lines: !0}),
            circleLines: new pd3D.Mesh({triangles: !0, lines: !0})
        }, P = new pd3D.Matrix, O = new pd3D.Matrix, N = new pd3D.Matrix, R = new pd3D.Matrix, F = new pd3D.Matrix,
        G = GL.Material.VariableColorUniformPointSize(),
        I = GL.Material.FixedColorUniformPointSize({uniforms: {pointSize: 5}});
    this.components = function () {
        return E
    }, this.showAll = function () {
        return E.annualShell.show(!0), E.baseDiagram.show(!0), E.baseDiagramText.show(!0), E.monthlySunPaths.show(!0), E.currentSunPath.show(!0), E.currentAnalemma.show(!0), E.solarArrow.show(!0), E.solarSphere.show(!0), E.declinationPlane.show(!0), E.twilightLines.show(!0), E.tropicsLines.show(!0), E.circleLines.show(!0), n
    }, this.radius = function (t) {
        return arguments.length ? (s = t, i(), n) : s
    }, this.thinLineWidth = function (t) {
        return arguments.length ? (d = t, n) : d
    }, this.thickLineWidth = function (t) {
        return arguments.length ? (u = t, n) : u
    }, this.center = function (t) {
        return arguments.length ? (l = t, i(), n) : l
    }, this.solarPosition = function (t) {
        return arguments.length ? (h = t, r(), n) : h
    }, this.monthlyLinesDay = function (t) {
        return arguments.length ? (y = pd.constrainTo(parseInt(t, 10), 1, 31), n) : y
    }, this.relativeSunDirection = function () {
        return L.toMatrix()
    }, this.arrowScale = function (t) {
        return arguments.length ? (D = parseFloat(t), n) : D
    }, this.colorCurrentDateTime = function (t) {
        if (!arguments.length) return c;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return c = t, n
    }, this.colorDiagramLines = function (t) {
        if (!arguments.length) return m;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return m = t, n
    }, this.colorDiagramText = function (t) {
        if (!arguments.length) return p;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return p = t, n
    }, this.colorSolarArrow = function (t) {
        if (!arguments.length) return f;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return f = t, n
    }, this.colorSunPathLines = function (t) {
        if (!arguments.length) return g;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return g = t, n
    }, this.colorSunPathMesh = function (t) {
        if (!arguments.length) return v;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return v = t, n
    }, this.handleLocationChange = function () {
        r()
    }, this.handleDateChange = function () {
        a()
    }, this.handleTimeChange = function (t) {
        pd3D.Matrix.translate(l[0] + t.x * s, l[1] + t.y * s, l[2] + t.z * s, F), pd3D.Matrix.rotate((12 - h.clockTime() - h.timezoneCorrection() + .03) / 24 * 360, 0, 1, 0, R), pd3D.Matrix.rotate(h.hourAngle(), 0, 1, 0, N), L.init(N).rotate(h.declinationAngle(), -1, 0, 0);
        var e = E.declinationAngle;
        e.triangles.length = 0, e.vertices.length = 0, e.points.length = 0, e.lines.length = 0;
        var i, r = 0, a = 1.4 * s, n = Math.PI / 720, o = h.declinationAngle(), d = o * pd.Const.DEG2RAD,
            u = Math.min(0, d) - 2 * n, c = Math.max(0, d) + 2 * n, m = .5 * d;
        Math.abs(o) < 9 && (o >= 0 ? (c = d + 9 * pd.Const.DEG2RAD, m = d + 5 * pd.Const.DEG2RAD) : (u = d - 9 * pd.Const.DEG2RAD, m = d - 6 * pd.Const.DEG2RAD));
        for (var p = u; p < c; p += n) i = l[1] + a * Math.sin(p), z = l[2] + a * Math.cos(p), e.vertices.push([l[0], i, z]), p += n, i = l[1] + a * Math.sin(p), z = l[2] + a * Math.cos(p), e.vertices.push([l[0], i, z]), r += 2, e.lines.push([r - 2, r - 1]);
        i = l[1] + a * Math.sin(d), z = l[2] + a * Math.cos(d), e.vertices.push([l[0], i, z]), e.points.push([r++]), i = l[1], z = l[2] + a, e.vertices.push([l[0], i, z]), e.points.push([r++]), e.vertices.push([l[0], l[1], l[2]]), e.vertices.push([l[0], l[1], l[2] + 1.05 * a]), e.lines.push([r, r + 1]);
        var f = .025 * s;
        pd3D.Matrix.scale(f, f, f, P), i = l[1] + a * Math.sin(m), z = l[2] + a * Math.cos(m), pd3D.Matrix.translate(l[0], i, z, O), O.multiplyBy(pd3D.Matrix.rotate(-90, 0, 1, 0)), O.multiplyBy(pd3D.Matrix.rotate(-90, 0, 0, 1)), O.multiplyBy(pd3D.Matrix.rotate(m * pd.Const.RAD2DEG, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText(o.toFixed(2) + "`", pd.Align.CENTER, pd.Align.BOTTOM, O, e), e.compile()
    };
    var V = 2 * Math.PI / 365.25;
    return this.calculateHeliocentricOrbitAngle = function (t, e) {
        return (14 + t + e * (1 / 24)) * V
    }, this.calculateHeliocentricOrbitVector = function (t, e) {
        var i = (14 + t + e * (1 / 24)) * V, r = Math.cos(i);
        return [(r > 0 ? .9671268894171 : 1.03399048350596) * r, Math.sin(i), 0]
    }, this.calculateHeliocentricOrbitPosition = function (t, e, i) {
        var r = this.calculateHeliocentricOrbitVector(t, e);
        return r[0] *= i, r[1] *= i, r
    }, this.generateHeliocentricOrbitPath = function (t, e) {
        var i, r, a, n, o, s = 0, l = solar.isLeapYear() ? 1 : 0;
        o = l ? [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 365] : [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 364];
        for (y = 0; y < 12; y++) {
            r = 1.04;
            for (var h = o[y]; h < o[y + 1]; h++) D = this.calculateHeliocentricOrbitVector(s, 0), a = t.addVertex([D[0] * e, D[1] * e, 0]), n = t.addVertex([D[0] * e * r, D[1] * e * r, 0]), r = 1.015, t.addLine(a, n), s++
        }
        var d = this.calculateHeliocentricOrbitPosition(2, 0, e),
            u = this.calculateHeliocentricOrbitPosition(185, 0, e);
        a = t.addVertex([.25 * d[0], .25 * d[1], 0]), n = t.addVertex([1.07 * d[0], 1.07 * d[1], 0]), t.addLine(a, n), a = t.addVertex([.25 * u[0], .25 * u[1], 0]), n = t.addVertex([1.07 * u[0], 1.07 * u[1], 0]), t.addLine(a, n);
        var c = 1.15 * e;
        a = t.addVertex(S);
        var m = this.calculateHeliocentricOrbitVector(79 + l, 0);
        n = t.addVertex([m[0] * c, m[1] * c, 0]), t.addLine(a, n);
        var p = this.calculateHeliocentricOrbitVector(264 + l, 0);
        n = t.addVertex([p[0] * c, p[1] * c, 0]), t.addLine(a, n);
        var f = this.calculateHeliocentricOrbitVector(171 + l, 0);
        n = t.addVertex([f[0] * c, f[1] * c, 0]), t.addLine(a, n);
        var g = this.calculateHeliocentricOrbitVector(354 + l, 0);
        n = t.addVertex([g[0] * c, g[1] * c, 0]), t.addLine(a, n);
        var v = .0175 * e, M = .65 * e;
        pd3D.Matrix.scale(v, v, v, P), pd3D.Font.lineSpacing(1.25), pd3D.Font.weight(550), pd3D.Matrix.translate(.65 * d[0], .65 * d[1], 0, O), O.multiplyBy(pd3D.Matrix.rotate(16, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("PERIHELION\n147,098,291 km", pd.Align.CENTER, pd.Align.CENTER, O, t), pd3D.Matrix.translate(.65 * u[0], .65 * u[1], 0, O), O.multiplyBy(pd3D.Matrix.rotate(196, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("APHELION\n152,098,233 km", pd.Align.CENTER, pd.Align.CENTER, O, t), pd3D.Matrix.translate(m[0] * M, m[1] * M, 0, O), O.multiplyBy(pd3D.Matrix.rotate(92, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("21 MAR", pd.Align.CENTER, pd.Align.BOTTOM, O, t), pd3D.Matrix.translate(p[0] * M, p[1] * M, 0, O), O.multiplyBy(pd3D.Matrix.rotate(275, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("22 SEP", pd.Align.CENTER, pd.Align.BOTTOM, O, t), pd3D.Matrix.translate(f[0] * M, f[1] * M, 0, O), O.multiplyBy(pd3D.Matrix.rotate(183, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("21 JUN", pd.Align.CENTER, pd.Align.BOTTOM, O, t), pd3D.Matrix.translate(g[0] * M, g[1] * M, 0, O), O.multiplyBy(pd3D.Matrix.rotate(4, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText("21 DEC", pd.Align.CENTER, pd.Align.BOTTOM, O, t), pd3D.Font.lineSpacing(1), M = 1.05 * e;
        for (var x = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"], y = 0; y < 12; y++) {
            i = (14 + (s = Math.round(.5 * (o[y] + o[y + 1])))) * V * (180 / Math.PI);
            var D = this.calculateHeliocentricOrbitVector(s, 0);
            pd3D.Matrix.translate(D[0] * M, D[1] * M, 0, O), O.multiplyBy(pd3D.Matrix.rotate(i + 90, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText(x[y], pd.Align.CENTER, pd.Align.CENTER, O, t)
        }
        pd3D.Font.weight(500)
    }, this.generateHeliocentricSeasonsMesh = function (t, e, i) {
        if (i !== t.southernHemisphere) {
            var r, a, n, o, s, l, h, d, u, c, m, p, f = solar.isLeapYear() ? 1 : 0, g = .7 * e, v = [0, 0, 0, 0];
            p = i ? [{day: 15, color: [1, .5, .5, .5], season: "SUMMER"}, {
                day: 105,
                color: [1, 1, .5, .5],
                season: "AUTUMN"
            }, {day: 196, color: [.5, .5, 1, .5], season: "WINTER"}, {
                day: 288,
                color: [.5, 1, .5, .5],
                season: "SPRING"
            }] : [{day: 15, color: [.5, .5, 1, .5], season: "WINTER"}, {
                day: 105,
                color: [.5, 1, .5, .5],
                season: "SPRING"
            }, {day: 196, color: [1, .5, .5, .5], season: "SUMMER"}, {
                day: 288,
                color: [1, 1, .5, .5],
                season: "AUTUMN"
            }], t.southernHemisphere = i, t.clear();
            for (var M = 0; M <= 366; M += 3) M > 365.25 && (M = 365.25), M < 15 ? (c = pd.mapAndConstrainTo(M, -15, 0, 0, 1), h = p[3].color, d = p[0].color) : M < 105 ? (c = pd.mapAndConstrainTo(M, 30, 90, 0, 1), h = p[0].color, d = p[1].color) : M < 196 ? (c = pd.mapAndConstrainTo(M, 120, 181, 0, 1), h = p[1].color, d = p[2].color) : M < 288 ? (c = pd.mapAndConstrainTo(M, 211, 273, 0, 1), h = p[2].color, d = p[3].color) : (c = pd.mapAndConstrainTo(M, 303, 365, 0, 1), h = p[3].color, d = p[0].color), m = [(1 - c) * h[0] + c * d[0], (1 - c) * h[1] + c * d[1], (1 - c) * h[2] + c * d[2], .5], u = this.calculateHeliocentricOrbitVector(M, 0), n = t.addVertex([u[0] * g, u[1] * g, 0], v), o = t.addVertex([u[0] * e, u[1] * e, 0], m), M > 0 && (t.addTriangle(s, l, o), t.addTriangle(s, o, n)), s = n, l = o;
            var x = .015 * e, y = .96 * e;
            pd3D.Matrix.scale(x, x, x, P);
            for (var D = 0; D < 4; D++) m = p[D].color, r = p[D].day + f, t.color([m[0], m[1], m[2], 1]), a = (14 + r) * V * pd.Const.RAD2DEG + 90, u = this.calculateHeliocentricOrbitVector(r, 0), pd3D.Matrix.translate(u[0] * y, u[1] * y, 0, O), O.multiplyBy(pd3D.Matrix.rotate(a, 0, 0, 1)), O.multiplyBy(P), pd3D.Font.addText(p[D].season, pd.Align.CENTER, pd.Align.CENTER, O, t);
            t.compile()
        }
    }, this.drawDiagram = function () {
        E.baseDiagramText.visible && I.uniform("color", p).drawSurface(E.baseDiagramText), E.baseDiagram.visible && (o.lineWidth(d), I.uniform("color", m).drawOutline(E.baseDiagram), I.uniform("color", p).drawSurface(E.baseDiagram)), (E.circleLines.visible || E.tropicsLines.visible) && (o.pushMatrix(), o.rotate(o.orbitalView.cameraAzi + pd.mapAndConstrainTo(o.orbitalView.cameraFOV, 20, 160, 0, 90) * Math.cos(o.orbitalView.cameraAlt * pd.Const.DEG2RAD), 0, 0, 1), E.tropicsLines.visible && (o.lineWidth(u), I.uniform("color", M).draw(E.tropicsLines, [o.LINES, o.TRIANGLES])), E.circleLines.visible && (o.lineWidth(u), I.uniform("color", m).draw(E.circleLines, [o.LINES, o.TRIANGLES])), o.popMatrix())
    }, this.drawSunPosition = function () {
        (E.twilightLines.visible || E.declinationPlane.visible || E.solarArrow.visible) && (o.pushMatrix(), o.multMatrix(L.toMatrix()), E.twilightLines.visible && (o.lineWidth(d), I.uniform("color", f).drawOutline(E.twilightLines)), E.declinationPlane.visible && (o.lineWidth(u), I.uniform("color", f).drawOutline(E.declinationPlane)), E.solarArrow.visible && (o.lineWidth(u), pd.closeTo(D, 1) || o.scale(D, D, D), w > .1 ? I.uniform("color", f).drawOutline(E.solarArrow) : G.drawOutline(E.solarArrow), I.uniform("color", f).drawSurface(E.solarArrow)), o.popMatrix()), E.currentSunPath.visible && (o.pushMatrix(), o.multMatrix(R), o.lineWidth(u), I.uniform("color", c).drawOutline(E.currentAnalemma), o.popMatrix(), o.pushMatrix(), o.multMatrix(N), E.baseDiagram.visible || I.uniform("color", g).drawOutline([E.currentSunPath]), pd.closeTo(D, 1) || o.scale(D, D, D), I.uniform("color", g).draw(E.declinationAngle, [o.LINES, o.TRIANGLES, o.POINTS]), o.popMatrix())
    }, this.drawSunPathLines = function () {
        (E.monthlySunPaths.visible || E.currentSunPath.visible) && (o.pushMatrix(), A > 1e-9 && o.translate(l[0], l[1], l[2]), o.multMatrix(b.toMatrix()), o.lineWidth(u), E.monthlySunPaths.visible && I.uniform("color", g).drawOutline(E.monthlySunPaths), E.currentSunPath.visible && (o.multMatrix(C.toMatrix()), I.uniform("color", c).drawOutline(E.currentSunPath)), o.popMatrix())
    }, this.drawSunSurface = function () {
        E.annualShell.visible && (o.pushMatrix(), A > 1e-9 && o.translate(l[0], l[1], l[2]), o.multMatrix(b.toMatrix()), o.depthMask(!1), o.setCullFace(!1), I.uniform("color", v).drawSurface(E.annualShell), o.depthMask(!0), o.setCullFace(), o.popMatrix()), (E.twilightLines.visible || E.declinationPlane.visible) && (o.pushMatrix(), o.multMatrix(L.toMatrix()), E.twilightLines.visible && I.uniform("color", f).drawSurface(E.twilightLines), o.depthMask(!1), o.setCullFace(!1), I.uniform("color", [f[0], f[1], f[2], .25 * f[3]]).drawSurface(E.declinationPlane), o.depthMask(!0), o.setCullFace(), o.popMatrix()), E.solarSphere.visible && (o.pushMatrix(), o.multMatrix(F), I.uniform("color", c).drawSurface(E.solarSphere), o.popMatrix())
    }, this.draw = function () {
        this.drawDiagram(), this.drawSunPosition(), this.drawSunPathLines(), this.drawSunSurface()
    }, i(), this
}, pdWGL.SunPath3D = function (t, e) {
    function i(t) {
        return t[0] > 1e-9 || t[0] < -1e-9 || t[1] > 1e-9 || t[1] < -1e-9 || t[2] > 1e-9 || t[2] < -1e-9
    }

    function r() {
        var t = tt.baseAxis;
        t.reuseStart();
        for (var e, i, r, a, n, o, s, l = 1 + x, h = l + D, d = l + 2.5 * D, u = l + 1.5 * D, c = l + 3 * D + .6 * y, m = 0; m <= 360; ++m) e = pd.sinDegrees(m), i = pd.cosDegrees(m), r = m % 5 ? h : m % 15 ? u : d, a = t.addVertex([e, i, 0]), n = t.addVertex([l * e, l * i, 0]), o = t.addVertex([r * e, r * i, 0]), t.addLine(n, o), m > 0 && t.addLine(s, a), s = a;
        t.addLine(t.addVertex([0, -d, 0]), t.addVertex([0, d, 0])), t.addLine(t.addVertex([-d, 0, 0]), t.addVertex([d, 0, 0])), t.reuseEnd(), t.compile();
        var p = tt.baseAxisText;
        p.reuseStart();
        var f = "", v = y;
        pd3D.Font.weight(300), pd3D.Matrix.scale(v, v, v, Q);
        for (m = 0; m < 360; m += M) m % 45 && (pd3D.Matrix.translate(c * pd.sinDegrees(m), c * pd.cosDegrees(m), 0, q), q.multiplyBy(pd3D.Matrix.rotate(-m, 0, 0, 1)), q.multiplyBy(Q), pd3D.Font.addText(m.toString(), pd.Align.CENTER, pd.Align.CENTER, q, p));
        if (pd3D.Font.weight(400), v *= 1.25, F) {
            var w = y * g;
            pd3D.Matrix.scale(1.5 * v, 1.5 * v, 1.5 * v, Q), pd3D.Matrix.translate(0, d + 1.41421 * w + v, 0, q), q.multiplyBy(Q), pd3D.Font.addText("N", pd.Align.CENTER, pd.Align.CENTER, q, p), p.addTriangle(p.addVertex([0, d + 1.41421 * w, 0]), p.addVertex([-w, d, 0]), p.addVertex([w, d, 0]))
        }
        pd3D.Matrix.scale(v, v, v, Q);
        for (m = F ? 45 : 0; m < 360; m += 45) {
            switch (m) {
                case 0:
                    f = "N";
                    break;
                case 45:
                    f = "NE";
                    break;
                case 90:
                    f = "E";
                    break;
                case 135:
                    f = "SE";
                    break;
                case 180:
                    f = "S";
                    break;
                case 225:
                    f = "SW";
                    break;
                case 270:
                    f = "W";
                    break;
                case 315:
                    f = "NW"
            }
            pd3D.Matrix.translate(c * pd.sinDegrees(m), c * pd.cosDegrees(m), 0, q), q.multiplyBy(pd3D.Matrix.rotate(-m, 0, 0, 1)), q.multiplyBy(Q), pd3D.Font.addText(f, pd.Align.CENTER, pd.Align.CENTER, q, p)
        }
        p.reuseEnd(), p.compile()
    }

    function a() {
        if (tt.annualShell.visible) {
            var t = tt.annualShell;
            t.triangles.length = 0, t.vertices.length = 0;
            for (var e, i, r = 0, a = 0, n = w.year(), o = 0, s = 0, l = 0, h = [171, 211, 231, 252, 272, 292, 313, 354], d = h.length - 1; d >= 0; d--) {
                if (i = h[d], j.setDayOfYear(Math.round(i), n).calculate(), j.getHourlySunPathAsPositions3D(.25, Z, 1, !1, t), 0 == o && (o = t.vertices.length), r > 0) {
                    l = r, s = a;
                    for (u = 1; u < o - 1; u++) t.triangles.push([s, l, l + 1]), t.triangles.push([l + 1, s + 1, s]), s++, l++;
                    t.triangles.push([s, l, r]), t.triangles.push([r, a, s]), a = r
                }
                for (var u = r; u < t.vertices.length; u++) e = t.vertices[u], t.normals.push([e[0], e[1], e[2]]);
                r = t.vertices.length
            }
            t.compile()
        }
    }

    function n() {
        if (tt.annualSunPath.visible) {
            var t = tt.annualSunPath, e = w.year();
            t.vertices.length = 0, t.lines.length = 0, j.setDayMonthYear(21, 5, e).calculate(), j.getHourlySunPathAsPositions3D(.25, Z, 1, !0, t);
            j.dayOfYear();
            for (var i in[6, 7, 8, 9, 10]) j.setDayMonthYear(V, i, e).calculate(), j.getHourlySunPathAsPositions3D(I, Z, 1, !1, t);
            j.setDayMonthYear(21, 11, e).calculate(), j.getHourlySunPathAsPositions3D(.25, Z, 1, !0, t), j.dayOfYear();
            for (var r = 0; r < 24; r++) j.setTimeOfDay(r), j.getAnalemmaSunPathAsPositions3D(12 == r ? 4 : G, Z, 1, 12 == r, t);
            t.compile()
        }
    }

    function o() {
        if (tt.solarSphere.visible) {
            var t = tt.solarSphere, e = .01 * g;
            t.vertices = t.vertices.map(function (t) {
                return pd3D.Vector.fromArray(t).normalize().scale(e).toArray()
            }), t.compile()
        }
    }

    function s() {
        if (tt.solarArrow.visible) {
            var t = tt.solarArrow;
            if (t.vertices.length = 0, t.colors.length = 0, t.lines.length = 0, v > .1) {
                var e = 1.5 * g, i = .02 * g;
                t.color(O), t.addVertex([0, 0, 0]), t.addVertex([e, 0, 0]), e -= v * i, t.addVertex([e, 0, -i]), t.addVertex([e, 0, i]), t.lines.push([0, 1]), t.lines.push([1, 2]), t.lines.push([1, 3])
            } else t.color(O), t.addVertex([0, 0, 0]), t.addVertex([1, 0, 0]), t.color([O[0], O[1], O[2], 0]), t.addVertex([10, 0, 0]), t.lines.push([0, 1]), t.lines.push([1, 2]);
            t.compile()
        }
    }

    function l() {
        var t = tt.dailySunPath;
        t.reuseStart(), t.visible ? j.setDayOfYear(w.dayOfYear(), w.year()) : w.latitude() < 0 ? j.setDayOfYear(354, w.year()) : j.setDayOfYear(171, w.year()), j.reuseHourlySunPathAsPositions3D(.25, Z, 1, !0, t);
        var e, i = w.latitude() < 0 ? -1.5 * y : 1.5 * y, r = .2 * i, a = 0, n = t._vtx_index;
        w.latitude() < 0 ? pd3D.Matrix.scale(-y, -y, -y, Q) : pd3D.Matrix.scale(y, y, y, Q);
        for (o = 0; o < n; o += 4) a++ < 24 && (e = t.vertices[o], t.addLine(t.addVertex([e[0], e[1] + r, e[2]]), t.addVertex([e[0], e[1] - r, e[2]])));
        pd3D.Font.weight(400), a = 0;
        for (var o = 0; o < n; o += 4) a < 24 && (e = t.vertices[o], pd3D.Matrix.translate(e[0], e[1] + i, e[2], q), q.multiplyBy(pd3D.Matrix.rotate(180 + a / 24 * 360, 0, -1, 0)), q.multiplyBy(Q), pd3D.Font.addText(a < 10 ? "0" + a : a.toString(), pd.Align.CENTER, pd.Align.CENTER, q, t)), a++;
        t.reuseEnd(), t.compile()
    }

    function h(t, e, i) {
        for (var r, a = 0, n = i.vertexCount(), o = 0; o <= 1; o += .01) r = 1 - o, i.addVertex([r * t[0] + o * e[0], r * t[1] + o * e[1], r * t[2] + o * e[2]]), n++, ++a % 2 && i.addLine(n - 1, n)
    }

    function d() {
        if (K.normalize(), pd3D.Matrix.translate(K.x, K.y, K.z, J), Y.reset().rotate(90 - w.azimuthAngle(), 0, 0, 1).rotate(w.altitudeAngle(), 0, -1, 0), tt.angleLines.visible) {
            var t = tt.angleLines, e = 1.25 * y, i = w.azimuthAngle(), r = w.altitudeAngle(), a = 1.05 + 4 * D + y,
                n = .025;
            t.reuseStart(), t.color(R), pd3D.Matrix.rotate(-i, 0, 0, 1, $), $.multiplyBy(pd3D.Matrix.rotate(-90, 0, 1, 0));
            var o = {
                width: n,
                radius: a,
                center: Z,
                defaultNormal: [0, 0, 1],
                defaultColor: [1, 0, 0, .5],
                fromAngle: 0,
                toAngle: i,
                triangles: !0,
                colors: !0,
                lines: !0
            };
            pd3D.Shapes.circularArrow(o, t), o.center = [0, 0, 0], o.toAngle = r, o.transform = $, pd3D.Shapes.circularArrow(o, t), t.color(S);
            var s = a + n + .1, l = i * pd.Const.DEG2RAD, d = Math.sin(l), u = Math.cos(l), c = [s * d, s * u, 0];
            tt.solarArrow.visible || h(Z, pd3D.Vector.multiply(K, s).toArray(), t), h(Z, [0, s, 0], t), h(Z, c, t), a += n + .6 * e, c[0] = a * Math.sin(.5 * l), c[1] = a * Math.cos(.5 * l), pd3D.Font.weight(400), pd3D.Matrix.scale(e, e, e, Q), pd3D.Matrix.translate(c[0], c[1], c[2], q), q.multiplyBy(pd3D.Matrix.rotate(-.5 * i, 0, 0, 1)), q.multiplyBy(Q), pd3D.Font.addText(i.toFixed(2) + "`", pd.Align.CENTER, pd.Align.CENTER, q, t);
            var m = .5 * (r * pd.Const.DEG2RAD);
            s = a * Math.cos(m), c[0] = s * d, c[1] = s * u, c[2] = a * Math.sin(m), pd3D.Matrix.translate(c[0], c[1], c[2], q), q.multiplyBy(pd3D.Matrix.rotate(-i, 0, 0, 1)), q.multiplyBy(pd3D.Matrix.rotate(.5 * r, 1, 0, 0)), q.multiplyBy(pd3D.Matrix.rotate(-90, 0, 1, 0)), q.multiplyBy(Q), pd3D.Font.addText(r.toFixed(2) + "`", pd.Align.CENTER, pd.Align.CENTER, q, t), t.reuseEnd(), t.compile()
        }
    }

    function u() {
        tt.shading.visible && pd.ShadingData && (k || (k = new pd.ShadingData), k.generateMesh(tt.shading, e.shadingData, H), e.shadingData = null)
    }

    function c() {
        X.reset().rotate(w.latitude(), 1, 0, 0).rotate(w.timezoneCorrection() / 24 * 360, 0, -1, 0), l(), U = !0
    }

    function m(t, e) {
        var i = !1;
        switch (e = !!e, t) {
            case p.Component.AXIS:
                tt.baseAxisText.visible = e, tt.baseAxis.visible = e;
                break;
            case p.Component.ANNUAL_AREA:
                tt.annualShell.visible = e, e && tt.annualShell.vertices.length < 1 && (a(), U || c());
                break;
            case p.Component.ANNUAL_LINES:
                tt.annualSunPath.visible = e, e && tt.annualSunPath.vertices.length < 1 && (n(), U || c());
                break;
            case p.Component.SUN_DIRECTION:
                tt.solarArrow.visible = e, e && tt.solarArrow.vertices.length < 1 && s(), tt.angleLines.visible && d();
                break;
            case p.Component.SUN_ANGLES:
                i = e && !tt.angleLines.visible, tt.angleLines.visible = e, (i || e && tt.angleLines.vertices.length < 1) && d();
                break;
            case p.Component.DIURNAL_SUN_PATH:
                i = e && !tt.dailySunPath.visible, tt.dailySunPath.visible = e, i && (l(), U || c());
                break;
            case p.Component.SUN_POSITION:
                tt.solarSphere.visible = e;
                break;
            case p.Component.SHADING:
                tt.shading.visible != e && (tt.shading.visible = e) && (tt.shading.vertices.length < 1 ? u() : z && p.updateShading());
                break;
            case p.Component.ALL:
                for (var r = p.Component.ALL - 1; r >= 0; r--) m(r, e)
        }
    }

    var p = this, f = (e = e || {}).radius || 1e3, g = e.arrowSize || 1, v = e.arrowStyle || 0, M = e.labelAngle || 15,
        x = e.tickOffset || .0075, y = e.textSize || .015, D = e.tickSize || .01,
        w = e.solarPosition || new pd.SolarPosition, _ = !1 !== e.horizonClipping, A = e.center || [0, 0, 0],
        T = e.lineWidthThin || t.getCanvasLineWidthThin(), L = e.lineWidthThick || t.getCanvasLineWidthThick(),
        C = e.colorDiagramLines || [.4, .4, .4, 1], b = e.colorDiagramText || [.1, .1, .1, 1],
        S = e.colorCurrentDateTime || [1, 0, 0, 1], E = e.colorSunPathLines || [.8, .5, .1, 1],
        P = e.colorSunPathMesh || [1, 1, 0, .1], O = e.colorSolarArrow || [0, 0, .75, 1],
        N = e.colorAngleLines || [1, 0, 0, 1], R = e.colorAngleMesh || [1, 1, 1, .75], F = e.showNorth || !1,
        G = pd.constrainTo(e.dayIncrement || 2, 1, 30), I = pd.constrainTo(e.timeIncrement || .03125, .01, 3),
        V = e.dayForMonthLine || 21, U = !1, k = e.shadingMask || null, z = !1, W = 1, B = .15, H = 1,
        j = (new pd.SolarPosition).setLocation(0, 0, 0), X = new pd3D.MatrixAccumulator, Y = new pd3D.MatrixAccumulator,
        K = new pd3D.Vector, Z = [0, 0, 0], J = new pd3D.Matrix, Q = new pd3D.Matrix, q = new pd3D.Matrix,
        $ = new pd3D.Matrix, tt = {
            baseAxis: new pd3D.Mesh({triangles: !1, lines: !0, noCullFace: !0}),
            baseAxisText: new pd3D.Mesh({triangles: !0, noCullFace: !0}),
            annualShell: new pd3D.Mesh({normals: !0, lines: !0, noCullFace: !0}),
            annualSunPath: new pd3D.Mesh({triangles: !1, lines: !0}),
            solarArrow: new pd3D.Mesh({triangles: !1, colors: !0, lines: !0}),
            angleLines: new pd3D.Mesh({triangles: !0, lines: !0, colors: !0, noCullFace: !0, visible: !1}),
            dailySunPath: new pd3D.Mesh({triangles: !0, lines: !0, noCullFace: !0}),
            solarSphere: new pd3D.Shapes.sphere({normals: !0, radius: .0125}),
            shading: new pd3D.Mesh({triangles: !0, colors: !0, lines: !0, noCullFace: !0})
        },
        et = new GL.Shader("\nuniform mat4 objMatrix;\nvarying vec4 worldPosition;\n\nvoid main() {\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n    worldPosition = objMatrix * gl_Vertex;\n}\n", "\nuniform vec4 color;\nvarying vec4 worldPosition;\n\nvoid main() {\n    gl_FragColor = color;\n    if (worldPosition.z < 0.0)\n        discard;\n}\n"),
        it = new GL.Shader("\nvarying vec3 vNormal;\nvarying vec3 vVertexDir;\n\nvoid main() {\n    vNormal = gl_NormalMatrix * gl_Normal;\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n    vec4 vtx = gl_ModelViewMatrix * gl_Vertex;\n    vVertexDir = vtx.xyz / vtx.w;\n}\n", "\nuniform float sunIntensity;\nvarying vec3 vVertexDir;\nvarying vec3 vNormal;\n\nvoid main() {\n    if (sunIntensity > 0.0) {\n        float viewIncidence = abs(dot(normalize(vVertexDir), normalize(vNormal)));\n        float incidence = (viewIncidence > 0.95) ? 1.0 - (20.0 * (viewIncidence - 0.9499)) : viewIncidence;\n        float opacity = sunIntensity * 0.75 * clamp(pow(incidence, 2.5), 0.0, 1.0);\n        gl_FragColor = vec4(1.0, 1.0, 0.0, opacity);\n    } else {\n        discard;\n    }\n}\n"),
        rt = GL.Material.VariableColorUniformPointSize(), at = GL.Material.FixedColorUniformPointSize(),
        nt = _ ? et : at.shader();
    return this.Component = {
        AXIS: 0,
        ANNUAL_AREA: 1,
        ANNUAL_LINES: 2,
        SUN_DIRECTION: 3,
        SUN_ANGLES: 4,
        DIURNAL_SUN_PATH: 5,
        SUN_POSITION: 6,
        SHADING: 7,
        ALL: 8
    }, tt.baseAxis.visible = void 0 === e.showAxis || !!e.showAxis, tt.baseAxisText.visible = void 0 === e.showAxis || !!e.showAxis, tt.annualShell.visible = void 0 === e.showAnnualArea || !!e.showAnnualArea, tt.annualSunPath.visible = void 0 === e.showAnnualLines || !!e.showAnnualLines, tt.solarArrow.visible = void 0 === e.showSunDirection || !!e.showSunDirection, tt.angleLines.visible = void 0 !== e.showSunAngles && !!e.showSunAngles, tt.dailySunPath.visible = void 0 === e.showSunPath || !!e.showSunPath, tt.solarSphere.visible = void 0 === e.showSunPos || !!e.showSunPos, tt.shading.visible = void 0 !== e.showShading && !!e.showShading, this.show = function () {
        for (var t = 0, e = arguments.length; t < e; t++) m(+arguments[t], !0);
        return p
    }, this.hide = function () {
        for (var t = 0, e = arguments.length; t < e; t++) m(+arguments[t], !1);
        return p
    }, this.isVisible = function (t) {
        switch (t) {
            case p.Component.AXIS:
                return tt.baseAxis.visible;
            case p.Component.ANNUAL_AREA:
                return tt.annualShell.visible;
            case p.Component.ANNUAL_LINES:
                return tt.annualSunPath.visible;
            case p.Component.SUN_DIRECTION:
                return tt.solarArrow.visible;
            case p.Component.SUN_ANGLES:
                return tt.angleLines.visible;
            case p.Component.DIURNAL_SUN_PATH:
                return tt.dailySunPath.visible;
            case p.Component.SUN_POSITION:
                return tt.solarSphere.visible;
            case p.Component.ALL:
                return tt.baseAxis.visible && tt.baseAxisText.visible && tt.annualShell.visible && tt.annualSunPath.visible && tt.solarArrow.visible && tt.angleLines.visible && tt.dailySunPath.visible && tt.solarSphere.visible
        }
        return !1
    }, this.showAll = function () {
        return tt.baseAxis.show(!0), tt.baseAxisText.show(!0), tt.annualShell.show(!0), tt.annualSunPath.show(!0), tt.solarArrow.show(!0), tt.angleLines.show(!0), tt.dailySunPath.show(!0), tt.solarSphere.show(!0), p
    }, this.components = function () {
        return tt
    }, this.setCenterAndRadius = function (t, e) {
        return A = t, f = e, p
    }, this.moveTo = function (t, e, i) {
        return A[0] = t, A[1] = e, A[2] = i, p
    }, this.radius = function (t) {
        return arguments.length ? (f = t, p) : f
    }, this.center = function (t) {
        return arguments.length ? (A = t, p) : A
    }, this.solarPosition = function (t) {
        return arguments.length ? (w = t, c(), p) : w
    }, this.lineWidthThin = function (t) {
        return arguments.length ? (T = t, p) : T
    }, this.lineWidthThick = function (t) {
        return arguments.length ? (L = t, p) : L
    }, this.dayForMonthLine = function (t) {
        if (!arguments.length) return V;
        var e = pd.constrainTo(parseInt(t, 10), 1, 31);
        return e != V && (V = e, n()), p
    }, this.horizonClipping = function (t) {
        return arguments.length ? (_ = !!t, nt = _ ? et : at.shader(), p) : _
    }, this.colorCurrentDateTime = function (t) {
        if (!arguments.length) return S;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return S = t, p
    }, this.colorDiagramLines = function (t) {
        if (!arguments.length) return C;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return C = t, p
    }, this.colorDiagramText = function (t) {
        if (!arguments.length) return b;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return b = t, p
    }, this.colorSolarArrow = function (t) {
        if (!arguments.length) return O;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return O = t, p
    }, this.colorAngleLines = function (t) {
        if (!arguments.length) return N;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return N = t, p
    }, this.colorAngleMesh = function (t) {
        if (!arguments.length) return R;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return R = t, p
    }, this.colorSunPathLines = function (t) {
        if (!arguments.length) return E;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return E = t, p
    }, this.colorSunPathMesh = function (t) {
        if (!arguments.length) return P;
        if (!Array.isArray(t) || 4 != t.length) throw new Error("Color values must be given as [r,g,b,a] arrays.");
        return P = t, p
    }, this.skyFactorLuminance = 0, this.skyFactorUniform = 0, this.shadingMask = function (t) {
        return arguments.length ? ((k = t) || tt.shading.clear(), p) : (k || (k = new pd.ShadingData(e.shadingOptions)), k)
    }, this.getShadingIterator = function () {
        return k ? k.getShadingIterator() : null
    }, this.showSkySegments = function (t) {
        return arguments.length ? (B = t ? .5 : .15, p) : B > .2
    }, this.getShading = function () {
        return k ? k.getData() : null
    }, this.setShadingSegmentValue = function (t, e) {
        return k && k.setSegmentShading(t, e), p
    }, this.setShadingSegmentColor = function (t, e) {
        return k && k.setSegmentColor(t, e), p
    }, this.updateShading = function (t) {
        if (k) if (tt.shading.visible) {
            t && k.generateMesh(tt.shading, null, H);
            var e = k.updateMesh(tt.shading);
            p.skyFactorLuminance = e.skyFactorLuminance, p.skyFactorUniform = e.skyFactorUniform, z = !1
        } else z = !0;
        return p
    }, this.setShading = function (t, e) {
        return k && k.setData(t), e || p.updateShading(), p
    }, this.clearShading = function (t) {
        return k && k.clearData(), t || p.updateShading(), p
    }, this.calculateShading = function (t, e, i) {
        if ("function" != typeof e) throw new Error("ERROR: Calculation callback must be a function.");
        if (t < 0 || t > 90) throw new Error("ERROR: Parameter 'altitude' must be in the range 0 to 90 degrees.");
        return k && k.calculateShading(t, e), i || p.updateShading(), p
    }, this.projectOnDome = function (e) {
        function i(i) {
            return !e && H > 0 ? (H -= 2 * i) < 0 && (H = 0, r = !0) : e && H < 1 && (H += 2 * i) > 1 && (H = 1, r = !0), k.transitionShape(H, tt.shading), t.update(), r
        }

        if (k) {
            var r = !1;
            if (e && H < 1 || !e && H > 0) return t.animationQueue.add(i), !0
        }
        return !1
    }, this.animateShading = function (e) {
        function i(e) {
            return W > 1 && (W = 1, r = !0), k.transitionData(W, tt.shading), t.update(), !1
        }

        if (k && e) {
            var r = !1;
            return k.setData(e), t.animationQueue.add(i), W = 0, !0
        }
        return !1
    }, this.handleLocationChange = function () {
        return c(), p
    }, this.handleDateChange = function () {
        return l(), p
    }, this.handleTimeChange = function (t) {
        return t ? K.init(t) : K.fromArray(w.getSunDirection()), d(), p
    }, this.handleDateTimeChange = function () {
        p.handleDateChange(), p.handleTimeChange()
    }, this.handleNorthChange = function () {
        return p
    }, this.getAABB = function (t) {
        return t && t.min || ((t = {min: new pd3D.Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)}).max = t.min.negative()), t.min.x > A[0] - f && (t.min.x = A[0] - f), t.min.y > A[1] - f && (t.min.y = A[1] - f), t.min.z > A[2] && (t.min.z = A[2]), t.max.x < A[0] + f && (t.max.x = A[0] + f), t.max.y < A[1] + f && (t.max.y = A[1] + f), t.max.z < A[2] + f && (t.max.z = A[2] + f), t
    }, this.drawOutlines = function () {
        t.pushMatrix(), t.pushLineWidth(), i(A) && t.translate(A[0], A[1], A[2]), t.scale(f, f, f);
        var e = w.northOffset();
        return pd.closeTo(e, 0, .001) || t.rotate(-e, 0, 0, 1), tt.baseAxis.visible && (t.lineWidth(T), at.uniform("color", C).drawOutline(tt.baseAxis)), tt.baseAxisText.visible && (pd3D.Font.isTriangulated ? at.uniform("color", b).drawSurface(tt.baseAxisText) : (t.lineWidth(L), at.uniform("color", b).drawOutline(tt.baseAxisText))), tt.solarArrow.visible && (t.pushMatrix(), t.multMatrix(Y.toMatrix()), t.lineWidth(.5 * (L + T)), v > .1 ? at.uniform("color", O).drawOutline(tt.solarArrow) : rt.drawOutline(tt.solarArrow), t.popMatrix()), tt.angleLines.visible && (t.lineWidth(T), at.uniform("color", N).drawOutline(tt.angleLines)), (tt.annualSunPath.visible || tt.dailySunPath.visible) && (t.pushMatrix(), t.multMatrix(X.toMatrix()), nt.uniforms({objMatrix: X.toMatrix()}), tt.annualSunPath.visible && (t.lineWidth(T), nt.uniforms({color: E}).draw(tt.annualSunPath, t.LINES)), tt.dailySunPath.visible && (t.lineWidth(tt.annualSunPath.visible ? L : T), nt.uniforms({color: S}).draw(tt.dailySunPath, t.LINES)), t.popMatrix()), tt.shading.visible && (pd.closeTo(e, 0, .001) || t.rotate(e, 0, 0, 1), t.depthMask(!1), t.lineWidth(T), at.uniform("color", C).pushUniform("opacity", B).drawOutline(tt.shading).popUniform(), rt.pushUniform("opacity", .5).drawSurface(tt.shading).popUniform(), t.depthMask(!0)), t.popLineWidth(), t.popMatrix(), p
    }, this.drawSurfaces = function () {
        t.pushMatrix(), i(A) && t.translate(A[0], A[1], A[2]), t.scale(f, f, f);
        var e = w.northOffset();
        return pd.closeTo(e, 0, .001) || t.rotate(-e, 0, 0, 1), tt.solarSphere.visible && (t.pushMatrix(), t.multMatrix(J), at.uniform("color", S).drawSurface(tt.solarSphere), t.scale(4, 4, 4), t.depthMask(!1), it.uniforms({sunIntensity: pd.mapAndConstrainTo(K.z, .0523359, .1564345, 0, 1)}).draw(tt.solarSphere, t.TRIANGLES), t.depthMask(!0), t.popMatrix()), tt.angleLines.visible && rt.uniform("opacity", 1).drawSurface(tt.angleLines), (tt.annualShell.visible || tt.dailySunPath.visible) && (t.pushMatrix(), t.multMatrix(X.toMatrix()), nt.uniforms({objMatrix: X.toMatrix()}), t.depthMask(!1), t.setCullFace(!1), tt.dailySunPath.visible && nt.uniforms({color: S}).draw(tt.dailySunPath, t.TRIANGLES), tt.annualShell.visible && nt.uniforms({color: P}).draw(tt.annualShell, t.TRIANGLES), t.depthMask(!0), t.setCullFace(), t.popMatrix()), tt.shading.visible && (pd.closeTo(e, 0, .001) || t.rotate(e, 0, 0, 1), t.depthMask(!1), rt.pushUniform("opacity", .5).drawSurface(tt.shading).popUniform(), t.depthMask(!0)), t.popMatrix(), p
    }, this.drawWithMaterial = function (e, i) {
        return i == t.TRIANGLES ? p.drawSurfaces() : i == t.LINES && p.drawOutlines(), p
    }, this.draw = function (e) {
        return e == t.LINES || e == pd3D.RENDER_FIRST ? p.drawOutlines() : p.drawSurfaces(), p
    }, function () {
        r(), a(), n(), o(), s(), d(), u(), (tt.annualShell.visible || tt.annualSunPath.visible) && c()
    }(), this
};
var pdSVG = pdSVG || {};
pdSVG.Slider = function (t) {
    function e(t) {
        return t.toFixed(1)
    }

    function i(t, e) {
        if (e && O > N) {
            t && (t.shiftKey ? e *= F : t.ctrlKey || t.metaKey ? e *= R : e *= G);
            var i;
            i = z ? pd.wrapAt(U + e, N, O) : pd.constrainTo(U + e, N, O), i = t ? t.shiftKey ? pd.snapTo(i, F) : t.ctrlKey || t.metaKey ? pd.snapTo(i, R) : pd.snapTo(i, G) : pd.snapTo(i, G), B ? B(i) : y.setValue(i)
        }
    }

    function r(t) {
        return Q + (t - N) * q
    }

    function a() {
        Z = +Y.width(), J = +Y.height(), K.setAttribute("viewBox", "0 0 " + Z + " " + J), q = (J - 2 * Q) / (O - N), rt = !1
    }

    function n(t, e) {
        e = e || {};
        var i = document.createElementNS(X, t);
        for (var r in e) i.setAttribute(r, e[r]);
        return i
    }

    function o(t, e) {
        var i = n("text", e);
        return i.appendChild(document.createTextNode(t)), i
    }

    function s(t) {
        return 0 == (3 & t) && (t % 100 != 0 || t % 400 == 0)
    }

    function l() {
        rt && a();
        var t, e = .5 * Z;
        if (Y.find("[class*=slider-bkgnd]").empty(), t = r(N) - 12, tt.appendChild(n("rect", {
                class: "bkgnd",
                rx: 5,
                ry: 5,
                x: -4,
                y: 0,
                width: Z + 8,
                height: J
            })), Y.find("[class*=slider-ticks]").empty(), S == y.TYPE_DATE && pd.closeTo(O, 365, 2)) for (var i = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 365], l = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 364], h = s(E) ? i : l, d = 0; d <= 12; d++) {
            if (d > 0) for (var u = (h[d] - h[d - 1]) / 4, c = h[d - 1] + u; c < h[d]; c += u) t = r(c), it.appendChild(n("line", {
                class: "line-tick",
                x1: 5,
                y1: t,
                x2: 10,
                y2: t
            })), it.appendChild(n("line", {class: "line-tick", x1: Z - 10, y1: t, x2: Z - 5, y2: t}));
            t = r(h[d]), it.appendChild(n("line", {
                class: "line-tick",
                x1: 0,
                y1: t,
                x2: 10,
                y2: t
            })), it.appendChild(n("line", {
                class: "line-tick",
                x1: Z - 10,
                y1: t,
                x2: Z,
                y2: t
            })), it.appendChild(o(P(h[d]), {class: "text-tick", "text-anchor": "middle", dy: "0.4em", x: e, y: t}))
        } else for (var m = N; m <= O; m += I) {
            if (m < O) for (var p = m + V; p < m + I; p += V) t = r(p), it.appendChild(n("line", {
                class: "line-tick",
                x1: 5,
                y1: t,
                x2: 10,
                y2: t
            })), it.appendChild(n("line", {class: "line-tick", x1: Z - 10, y1: t, x2: Z - 5, y2: t}));
            t = r(m), it.appendChild(n("line", {
                class: "line-tick",
                x1: 0,
                y1: t,
                x2: 10,
                y2: t
            })), it.appendChild(n("line", {
                class: "line-tick",
                x1: Z - 10,
                y1: t,
                x2: Z,
                y2: t
            })), it.appendChild(o(P(m), {class: "text-tick", "text-anchor": "middle", dy: "0.4em", x: e, y: t}))
        }
        Y.find("[class*=slider-thumb]").empty();
        var f = .5 * (Z - 40),
            g = " M 10 0 l 10 5 l 0 21 a 4 4 0 0 0 4 4 l " + (Z - 40 - 8) + " 0 a 4 4 0 0 0 4 -4 l 0 -21 l 10 -5 l -10 -5 l 0 -21 a 4 4 0 0 0 -4 -4 l -" + (Z - 40 - 8) + " 0 a 4 4 0 0 0 -4 4 l 0 21 Z";
        et.appendChild(n("path", {class: "thumb-large", d: g}));
        var v = .5 * f;
        g = " M " + (20 + v) + " 35 l " + v + " 5 l " + v + " -5 Z M " + (20 + v) + " -35 l " + v + " -5 l " + v + " 5 Z", et.appendChild(n("path", {
            class: "thumb-large",
            d: g
        }));
        var M = b.split("\n");
        M[0] = M[0] || "", M[1] = M[1] || "", et.appendChild(D = o(M[0], {
            class: "text-title-thumb",
            "text-anchor": "middle",
            dy: "0.4em",
            x: e,
            y: -20
        })), et.appendChild(w = o(M[1], {
            class: "text-title-thumb",
            "text-anchor": "middle",
            dy: "0.4em",
            x: e,
            y: -5
        })), _ = et.appendChild(o(P(U), {
            id: "svg-slider-value",
            class: "text-value-thumb",
            "text-anchor": "middle",
            dy: "0.4em",
            x: e,
            y: 15
        })), et.setAttribute("transform", "translate(0," + r(U) + ")")
    }

    function h() {
        a(), l()
    }

    function d() {
        return ot *= ut, nt = z ? pd.wrapAt(nt + ot, N, O) : pd.constrainTo(nt + ot, N, O), B ? B(pd.snapTo(nt, ct)) : y.setValue(pd.snapTo(nt, ct)), pd.closeTo(ot, 0, R)
    }

    function u(t) {
        return t.shiftKey ? F : k || 1 == t.button || t.ctrlKey || t.metaKey ? R : G
    }

    function c() {
        gt && clearTimeout(gt), gt = null, ft && clearInterval(ft), ft = null
    }

    function m() {
        nt = z ? pd.wrapAt(nt + ot, N, O) : pd.constrainTo(nt + ot, N, O);
        var t = pd.snapTo(nt, ct), e = Math.abs(st - r(t));
        e <= pt ? (y.setValue(t), B && B(U), pt = e) : c()
    }

    function p() {
        c(), ft = setInterval(m, C), lt = !0
    }

    function f(t) {
        ct = u(t);
        var e = r(U);
        pd.closeTo(t.y, e, W) || (pt = Math.abs(t.y - e), gt = setTimeout(p, L), ot = t.y < e ? -ct : ct)
    }

    function g(t) {
        t.button >= 0 && t.button < 2 && (mt = 0, st = t.y, dt = 20 * R, nt = U, ot = 0, lt = !1, f(t))
    }

    function v(t) {
        if (t.button >= 0) {
            c();
            var e = t.dragY * pdDOM.pageScale;
            k || 1 == t.button ? (ot = .2 * pd.sign(e) * pd.interpolate(R, F, Math.min(1, (Math.abs(e) - 1) / 50)), t.metaKey = !0) : ot = e / J * (O - N), nt = z ? pd.wrapAt(nt + ot, N, O) : pd.constrainTo(nt + ot, N, O), ct = t.shiftKey ? F : k || 1 == t.button || t.ctrlKey || t.metaKey ? R : G, mt = t.timeStamp, dt = 5 * ct;
            var i = pd.snapTo(nt, ct);
            B ? B(i) : y.setValue(i)
        }
    }

    function M(t) {
        c(), t.timeStamp - mt < ht && Math.abs(ot) > dt && pdDOM.getGlobalAnimationQueue().addOrReplace(d).start()
    }

    function x(t) {
        t.delta && j && (t.metaKey = t.metaKey || k, j(t, -t.delta))
    }

    var y = this;
    this.TYPE_NUMERIC = 0, this.TYPE_DATE = 1, this.TYPE_TIME = 2;
    var D, w, _, A = (t = t || {}).elementId || "svg", T = 0, L = 400, C = pdDOM.isMobile ? 50 : 25, b = "Untitled",
        S = this.TYPE_NUMERIC, E = (new Date).getFullYear(), P = e, O = 100, N = 0, R = .1, F = 10, G = 1, I = 10,
        V = 2, U = 50, k = !1, z = !1, W = 32, B = null, H = null, j = null, X = "http://www.w3.org/2000/svg", Y = $(A),
        K = Y[0], Z = 100, J = 450, Q = 40, q = 1, tt = document.createElementNS(X, "g"),
        et = document.createElementNS(X, "g"), it = document.createElementNS(X, "g"), rt = !0;
    this.show = function (t) {
        return t ? Y.show() : Y.hide(), y
    }, this.width = function (t) {
        return arguments.length ? (Z = parseInt(t, 10), Y.width(Z), y.refresh(), y) : Z
    }, this.height = function (t) {
        return arguments.length ? (J = parseInt(t, 10), Y.height(J), y.refresh(), y) : J
    }, this.throttledRescale = function (t) {
        return arguments.length ? (T = pd.constrainTo(parseInt(t, 10), 0, 5e3), y) : T
    }, this.title = function (t) {
        if (!arguments.length) return b;
        var e = (b = t).split("\n");
        return e.length > 0 && e[0].length > 0 && (D.firstChild.nodeValue = e[0]), e.length > 1 && e[1].length > 0 && (w.firstChild.nodeValue = e[1]), y
    }, this.format = function (t) {
        return arguments.length ? (P = null != t ? t : e, _.firstChild.nodeValue = P(U), y) : P
    }, this.wrap = function (t) {
        return arguments.length ? (z = !!t, y) : z
    }, this.detailMode = function (t) {
        return arguments.length ? (k = !!t, y) : k
    }, this.setYear = function (t) {
        var e = E != t && S == y.TYPE_DATE;
        E = t, e && (O = s(E) ? 365 : 364, a(), l())
    }, this.setValue = function (t) {
        U = z ? pd.wrapAt(parseFloat(t), N, O) : pd.constrainTo(parseFloat(t), N, O), et.setAttribute("transform", "translate(0," + r(U) + ")"), _.firstChild.nodeValue = P(U)
    }, this.set = function (t) {
        P = t.format || e, T = t.throttledRescale || 0, b = t.title || "Untitled", U = void 0 !== t.value ? t.value : .5 * (O - N), N = void 0 !== t.min ? t.min : 0, O = void 0 !== t.max ? t.max : 100, R = t.step || .001 * (O - N), F = t.stepMajor || 100 * R, G = t.stepMinor || 10 * R, I = t.tickMajor || F, V = t.tickMinor || G, E = t.year || (new Date).getFullYear(), S = t.type || y.TYPE_NUMERIC, z = !!t.wrap, S == y.TYPE_DATE && pd.closeTo(O, 365, 2) && (O = s(E) ? 365 : 364), B = t.observable || null, j = t.incrementor || i, H && (H.dispose(), H = null), B && "function" == typeof B && (H = B.subscribe(this.setValue), U = parseFloat(B()), B.incrementor && j == i && (j = B.incrementor)), a(), l()
    };
    var at = null;
    this.rescale = function () {
        T > 4 ? (null != at && clearTimeout(at), at = setTimeout(h, T)) : h()
    }, this.refresh = function () {
        l()
    };
    var nt = 0, ot = 0, st = -1, lt = !1, ht = 50, dt = 2, ut = .85, ct = 1, mt = 0, pt = 0, ft = null, gt = null;
    return pdDOM.Interaction.makeInteractive(K, {
        onpress: g,
        ondrag: v,
        onrelease: M,
        onscroll: x
    }), Y.attr("xmlns", X), Y.attr("class", "svg-slider " + Y.attr("class")), K.style.cursor = "ns-resize", function () {
        Y.empty(), tt.setAttribute("class", "slider-bkgnd"), K.appendChild(tt), it.setAttribute("class", "slider-ticks"), K.appendChild(it), et.setAttribute("class", "slider-thumb"), K.appendChild(et)
    }(), this.set(t), this
};
