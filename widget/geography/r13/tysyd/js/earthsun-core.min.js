var pd = pd || {};
!function () {
    function t(t) {
        return 0 == (3 & t) && (t % 100 != 0 || t % 400 == 0)
    }

    pd.version = "0.1.2", pd.isBrowser = "undefined" != typeof window, pd.Const = {
        EPSILON: 1e-6,
        HALF_PI: .5 * Math.PI,
        TWO_PI: 2 * Math.PI,
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI
    }, pd.Align = {
        CENTER: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTTOM: 4,
        TOP: 8,
        BASELINE: 16,
        TOP_LEFT: 9,
        TOP_RIGHT: 10,
        BOTTOM_LEFT: 5,
        BOTTOM_RIGHT: 6,
        OUTSIDE: 1,
        INSIDE: 2
    }, pd.sign = function (t) {
        return t < 0 ? -1 : 1
    }, pd.isNumeric = function (t) {
        return null != t && !isNaN(parseFloat(t)) && isFinite(t)
    }, pd.isInteger = function (t) {
        return null != t && Math.round(t) === t
    }, pd.toNumber = function (t, e) {
        return t = parseFloat(t), !isNaN(t) && isFinite(t) ? t : e
    }, pd.toInteger = function (t, e) {
        return t = parseFloat(t), !isNaN(t) && isFinite(t) ? Math.round(t) : Math.round(+e)
    }, pd.toBoolean = function (t, e) {
        return null != t ? !!t : !!e
    }, pd.isBetween = function (t, e, r, n) {
        if (r >= e) {
            if (n = n || 0, isNaN(t) || t > r + n) return !1;
            if (t < e - n) return !1
        }
        return !0
    }, pd.isPowerOfTwo = function (t) {
        return 0 == (t & t - 1)
    }, pd.nextPowerOfTwo = function (t) {
        return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
    }, pd.closeTo = function (t, e, r) {
        return r = r || pd.Const.EPSILON, !(isNaN(t) || t > e + r || t < e - r)
    }, pd.constrainTo = function (t, e, r) {
        if (isNaN(t)) return e;
        if (r < e) {
            if (t > e) return e;
            if (t < r) return r
        } else {
            if (t < e) return e;
            if (t > r) return r
        }
        return t
    }, pd.wrapAt = function (t, e, r, n) {
        var i = Math.min(r, e), a = Math.max(r, e);
        if (n && t > a - pd.Const.EPSILON && t < a + pd.Const.EPSILON) return i;
        if (t < i || t > a) {
            var s = a - i;
            return s > 0 ? t = t < i ? a - (i - t) % s : i + (t - i) % s : i
        }
        return t
    }, pd._fastWrap = function (t, e, r) {
        if (t < e || t > r) {
            var n = r - e;
            return n > 0 ? t < e ? r - (e - t) % n : e + (t - e) % n : e
        }
        return t
    }, pd.snapTo = function (t, e) {
        return (e = e || 1) * Math.round(t / e)
    }, pd.roundTo = function (t, e) {
        return +t.toFixed(e)
    }, pd.incrementBy = function (t, e) {
        var r = (e = e || 1) * Math.floor(t / e) + e, n = Math.abs(.1 * e);
        return t > r - n && t < r + n ? r + e : r
    }, pd.mapAndConstrainTo = function (t, e, r, n, i) {
        var a = r - e;
        return Math.abs(a) < pd.Const.EPSILON ? .5 * (n + i) : pd.constrainTo(n + (t - e) / a * (i - n), n, i)
    }, pd.mapTo = function (t, e, r, n, i) {
        var a = r - e;
        return Math.abs(a) < pd.Const.EPSILON ? .5 * (n + i) : n + (t - e) / a * (i - n)
    }, pd.interpolate = function (t, e, r) {
        return t + r * (e - t)
    }, pd.getTickincrement = function (t, e) {
        var r = Math.pow(10, Math.floor(Math.log10(t)));
        r < pd.Const.EPSILON && (r = 1);
        var n = t / r;
        return e = e || 20, n <= .1 * e ? .1 * r : n <= .2 * e ? .2 * r : n <= .5 * e ? .5 * r : n <= e ? r : pd.snapTo(t / e, .1 * r)
    }, pd.randomRange = function (t, e) {
        return Math.random() * (e - t) + t
    }, pd.safeDivide = function (t, e) {
        return Math.abs(e) > pd.Const.EPSILON ? t / e : 0
    }, pd.degreesToRadians = function (t) {
        return t * pd.Const.DEG2RAD
    }, pd.radiansToDegrees = function (t) {
        return t * pd.Const.DEG2RAD
    }, pd.sinDegrees = function (t) {
        return Math.sin(t * pd.Const.DEG2RAD)
    }, pd.cosDegrees = function (t) {
        return Math.cos(t * pd.Const.DEG2RAD)
    };
    var e = 987655555, r = 123455555;
    pd.randomNumber = function (t) {
        return t && (e = 987654321 + t, r = 123456789 - t), r = 36969 * (65535 & r) + (r >> 16) & 4294967295, e = 18e3 * (65535 & e) + (e >> 16) & 4294967295, ((r << 16) + e & 4294967295) / 4294967296 + .5
    }, pd.randomNumberInRange = function (t, e) {
        return pd.randomNumber() * (e - t) + t
    }, pd.toHexColorString = function (t) {
        var e, r = "#";
        return Array.isArray(t) ? ((e = Math.round(255 * t[0])) < 16 && (r += "0"), r += e.toString(16).toUpperCase(), (e = Math.round(255 * t[1])) < 16 && (r += "0"), r += e.toString(16).toUpperCase(), (e = Math.round(255 * t[2])) < 16 && (r += "0"), r += e.toString(16).toUpperCase()) : "None"
    }, pd.parseHexColorString = function (t, e) {
        if (e || (e = [1, 1, 1, 1]), t && t.length > 1) if (t.indexOf("[") >= 0 && t.indexOf("]") >= 0) {
            if ((r = JSON.parse(t)) && Array.isArray(r)) return e[0] = pd.constrainTo(pd.toNumber(r[0], 0), 0, 1), e[1] = pd.constrainTo(pd.toNumber(r[1], 0), 0, 1), e[2] = pd.constrainTo(pd.toNumber(r[2], 0), 0, 1), e[3] = pd.constrainTo(pd.toNumber(r[3], 1), 0, 1), e
        } else {
            t = t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (t, e, r, n) {
                return e + e + r + r + n + n
            });
            var r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
            r && (e[0] = parseInt(r[1], 16) / 255, e[1] = parseInt(r[2], 16) / 255, e[2] = parseInt(r[3], 16) / 255, e[3] = 1)
        }
        return e
    }, pd.setColorArray = function (t, e, r, n, i) {
        if (t = t || [], Array.isArray(e)) {
            var a = e;
            t[0] = +a[0] || 0, t[1] = +a[1] || 0, t[2] = +a[2] || 0, t[3] = pd.toNumber(a[3], 1)
        } else t[0] = +e || 0, t[1] = +r || 0, t[2] = +n || 0, t[3] = pd.toNumber(i, 1);
        return t
    }, pd.startsWith = function (t, e) {
        return 0 === t.indexOf(e)
    }, pd.endsWith = function (t, e) {
        var r = t.length - e.length, n = t.indexOf(e, r);
        return -1 !== n && n === r
    }, pd.toStringWithLeadingZeros = function (t, e) {
        var r = String(t);
        for (e = pd.toInteger(e, 2); r.length < e;) r = "0" + r;
        return r
    }, pd.toStringWithPrecisionRange = function (t, e, r) {
        if (e < 0 || r < 0) throw new Error("ERROR: Minimum and maximum decimal places must be zero or positive.");
        if (t = parseFloat(t), r <= e) return t.toFixed(e);
        var n = t.toFixed(r).split(".");
        if (n.length < 2) return t.toFixed(e);
        var i = n[1].length;
        if (i <= e) return t.toFixed(e);
        for (var a = i - 1; a >= e && "0" == n[1].charAt(a); a--) i--;
        return i > 0 ? n[0] + "." + n[1].slice(0, i) : n[0]
    }, pd.UnitType = {
        DEFAULT: 0,
        METRIC_MM: 1,
        METRIC_SI: 2,
        IMPERIAL: 3
    }, pd.Units = {}, pd.Units.type = pd.UnitType.METRIC_MM, pd.Units.formatFeetAndInches = function (t) {
        var e, r, n, i = "", a = pd.sign(t);
        return e = Math.abs(t) / 25.4 / 12 + .001, r = 12 * (e - Math.floor(e)) + .001, n = 16 * (r - Math.floor(r)) + .001, n = Math.floor(n), r = Math.floor(r), ((e = Math.floor(e)) > 0 || r < .001 && n < .999) && (i += e.toString() + "'"), (r > 0 || n >= 1) && (e > 0 && (i += " "), i += r.toString() + '"'), n >= 1 && (i.length > 0 && (i += " "), i += n % 8 == 0 ? Math.round(n / 8).toString() + "/2" : n % 4 == 0 ? Math.round(n / 4).toString() + "/4" : n % 2 == 0 ? Math.round(n / 2).toString() + "/8" : n.toString() + "/16"), a < 0 ? "-" + i : i
    }, pd.Units.formatDimension = function (t, e, r, n) {
        switch (e = e || pd.Units.type) {
            default:
            case pd.UnitType.METRIC_MM:
                return (!pd.isNumeric(r) || r < 0) && (r = 0), n ? t.toFixed(r) + " mm" : t.toFixed(r);
            case pd.UnitType.METRIC_SI:
                return (!pd.isNumeric(r) || r < 0) && (r = 0), n ? (t / 1e3).toFixed(r + 3) + " m" : (t / 1e3).toFixed(r + 3);
            case pd.UnitType.IMPERIAL:
                return pd.Units.formatFeetAndInches(t)
        }
    }, pd.Units.incrementDimension = function (t, e, r, n) {
        if (r = pd.toNumber(r, 0), e = pd.toNumber(e, 0), n = pd.toNumber(n, 25), e) {
            var i, a;
            return pd.Units.type == pd.UnitType.IMPERIAL ? (a = 1.5875, n > 900 ? (i = 4572, n = 25.4) : n > 300 ? (i = 914.4, n = 25.4) : n > 15 ? (i = 304.8, n = 25.4) : (n = 1.5875, i = 25.4), e = t && t.shiftKey ? Math.abs(e) < 10 ? i * pd.sign(e) : 5 * i * pd.sign(e) : t && (t.ctrlKey || t.metaKey) ? Math.abs(e) < 10 ? a * pd.sign(e) : 4 * a * pd.sign(e) : Math.abs(e) < 10 ? n * pd.sign(e) : i * pd.sign(e)) : (a = .2 * n, i = 10 * n, e = t && t.shiftKey ? Math.abs(e) < 5 ? i * pd.sign(e) : Math.abs(e) < 10 ? 5 * i * pd.sign(e) : 10 * i * pd.sign(e) : t && (t.ctrlKey || t.metaKey) ? Math.abs(e) < 10 ? a * pd.sign(e) : 5 * a * pd.sign(e) : Math.abs(e) < 10 ? n * pd.sign(e) : i * pd.sign(e)), pd.incrementBy(r, e)
        }
    }, pd.Units.formatArea = function (t, e, r) {
        switch (e = e || pd.Units.type) {
            default:
            case pd.UnitType.METRIC_MM:
            case pd.UnitType.METRIC_SI:
                return (!pd.isNumeric(r) || r < 0) && (r = 2), t.toFixed(r) + " m2";
            case pd.UnitType.IMPERIAL:
                return (!pd.isNumeric(r) || r < 0) && (r = 1), (10.76391041671 * t).toFixed(r) + " ft2"
        }
    }, pd.Units.parseDimension = function (t, e) {
        switch (e = e || pd.Units.type, /\'|\"/.test(t) ? e = pd.UnitType.IMPERIAL : t.indexOf("ft") >= 0 || t.indexOf("in") > 0 ? (t = (t = t.replace("ft", "'")).replace("in", '"'), e = pd.UnitType.IMPERIAL) : t.indexOf("mm") > 0 ? e = pd.UnitType.METRIC_MM : t.indexOf("m") > 0 && (e = pd.UnitType.METRIC_SI), e) {
            default:
            case pd.UnitType.METRIC_MM:
                return parseFloat(t);
            case pd.UnitType.METRIC_SI:
                return 1e3 * parseFloat(t);
            case pd.UnitType.IMPERIAL:
                var r = 0, n = 0, i = 0;
                if (t.indexOf("'") >= 0 || t.indexOf('"') >= 0) for (var a = t.split(/([\s\'\"]+)/), s = 0; s < a.length; s += 2) if (a[s].indexOf("/") >= 0) {
                    if ((o = a[s].split("/")).length > 1) {
                        d = parseFloat(o[0]);
                        (h = parseFloat(o[1])) > .1 && (i = d / h)
                    }
                } else s < a.length - 1 && a[s + 1].length > 0 ? a[s + 1].indexOf('"') >= 0 || a[s + 1].indexOf("''") >= 0 || a[s + 1].indexOf(" ") >= 0 && s > 0 ? n = parseFloat(a[s]) : (a[s + 1].indexOf("'") >= 0 || a[s + 1].indexOf(" ") >= 0 && 0 == s) && (r = parseFloat(a[s])) : a[s].length > 0 && (s > 0 || r > 0 ? n = parseFloat(a[s]) : r = parseFloat(a[s])); else for (var a = t.split(" "), s = 0; s < a.length; ++s) if (a[s].length > 0) if (a[s].indexOf("/") >= 0) {
                    var o = a[s].split("/");
                    if (o.length > 1) {
                        var d = parseFloat(o[0]), h = parseFloat(o[1]);
                        h > .1 && (i = d / h)
                    }
                } else s > 0 ? n = parseFloat(a[s]) : r = parseFloat(a[s]);
                return 304.8 * r + 25.4 * n + 25.4 * i
        }
    };
    var n = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
        i = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
        a = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    pd.DateTime = {}, pd.DateTime.generateDateSuffix = function () {
        var t = new Date;
        return t.getFullYear() + "-" + ("0" + (t.getMonth() + 1)).slice(-2) + "-" + ("0" + t.getDate()).slice(-2) + "-" + ("0" + t.getHours()).slice(-2) + ("0" + t.getMinutes()).slice(-2) + "-" + ("0" + t.getSeconds()).slice(-2)
    }, pd.DateTime.getDOY = function (e, r, a) {
        return r = constrainTo(r, 0, 11), (t(a) ? i : n)[r] + e - 1
    }, pd.DateTime.snapToNearestMonth = function (e, r) {
        var a = t(r || (new Date).getFullYear()), s = a ? i : n, o = a ? 365 : 364;
        e = pd.constrainTo(e, 0, o);
        for (var d = 0; d <= 12; ++d) if (e < s[d] + 15) return s[d];
        return o
    }, pd.DateTime.formatDate = function (e, r) {
        var s = t(r || (new Date).getFullYear());
        e = pd.constrainTo(e, 0, s ? 365 : 364);
        for (var o = pd.constrainTo(Math.ceil(e / 30) + 1, 0, 11), d = s ? i : n, h = o; h >= 0; h--) if (e >= d[h]) {
            var u = Math.floor(pd.constrainTo(h, 0, 11)), c = Math.floor(pd.constrainTo(e - d[h] + 1, 1, 31));
            return c < 10 && (c = "0" + c), c + " " + a[u] + " " + (r || "")
        }
        return ""
    }, pd.DateTime.formatAsMMMDD = function (e, r) {
        var s = t(r || (new Date).getFullYear());
        e = pd.constrainTo(e, 0, s ? 365 : 364);
        for (var o = pd.constrainTo(Math.ceil(e / 30) + 1, 0, 11), d = s ? i : n, h = o; h >= 0; h--) if (e >= d[h]) {
            var u = Math.floor(pd.constrainTo(h, 0, 11)), c = Math.floor(pd.constrainTo(e - d[h] + 1, 1, 31));
            return c < 10 && (c = "0" + c), a[u] + c
        }
        return ""
    }, pd.DateTime.formatMonthName = function (t) {
        return t = Math.floor(pd.constrainTo(t, 0, 11)), a[t]
    }, pd.DateTime.formatTime = function (t, e) {
        if (t = pd.wrapAt(t, 0, 24), e) {
            var r = 3600 * Math.abs(t), n = pd.constrainTo(Math.floor(t), 0, 24),
                i = pd.constrainTo(Math.floor(60 * (t - n)), 0, 60),
                a = pd.constrainTo(Math.round(r - (3600 * n + 60 * i)), 0, 60);
            return a > 59.5 && (i = i < 59 ? i + 1 : 0, a = 0), i > 59.5 && (n = n < 23 ? n + 1 : 0, i = 0), n < 10 && (n = "0" + n), i < 10 && (i = "0" + i), a < 10 && (a = "0" + a), sign < 0 ? "-" + n + ":" + i + ":" + a : n + ":" + i + ":" + a
        }
        n = Math.floor(t);
        return (i = pd.constrainTo(Math.round(60 * (t - n)), 0, 60)) > 59.5 && (n = n < 23 ? n + 1 : 0, i = 0), n < 10 && (n = "0" + n), i < 10 && (i = "0" + i), n + ":" + i
    }, pd.DateTime.formatDuration = function (t, e) {
        var r = pd.sign(t);
        if (t = Math.abs(t), e) {
            var n = Math.floor(t), i = 3600 * Math.abs(t), a = pd.constrainTo(Math.floor(60 * (t - n)), 0, 60),
                s = pd.constrainTo(Math.round(i - (3600 * n + 60 * a)), 0, 60);
            return s > 59.5 && (a = a < 59 ? a + 1 : 0, s = 0), a > 59.5 && (n = n < 23 ? n + 1 : 0, a = 0), n < 10 && (n = "0" + n), a < 10 && (a = "0" + a), s < 10 && (s = "0" + s), r < 0 ? "-" + n + ":" + a + ":" + s : n + ":" + a + ":" + s
        }
        n = Math.floor(t);
        return (a = pd.constrainTo(Math.round(60 * (t - n)), 0, 60)) > 59.5 && (n = n < 23 ? n + 1 : 0, a = 0), n < 10 && (n = "0" + n), a < 10 && (a = "0" + a), r < 0 ? "-" + n + ":" + a : n + ":" + a
    }, pd.DateTime.parseTime = function (t) {
        if ("" == t) return null;
        var e = 0, r = 0;
        if (t.indexOf(".") >= 0 && t.indexOf(":") < 0) {
            var n = parseFloat(t);
            r = 60 * (n - (e = Math.floor(n)))
        } else {
            var i = t.match(/(\d+)(:(\d\d))?\s*(p|a?)/i);
            if (null == i) return null;
            if ((e = parseInt(i[1], 10)) > 24) {
                r = e;
                (e = Math.floor(r / 100)) > 0 && (r -= 100 * e), i[3] = r.toString()
            }
            i[4].length > 0 && ("a" == i[4] ? 12 == e && (e = 0) : e < 12 && (e += 12)), r = parseInt(i[3], 10) || 0
        }
        e = pd._fastWrap(e, 0, 24);
        var a = new Date;
        return a.setHours(e), a.setMinutes(r), a.setSeconds(0, 0), a
    }, pd.DateTime.parseTimeToDecimalHours = function (t) {
        var e = pd.DateTime.parseTime(t);
        return e ? pd.constrainTo(e.getHours() + e.getMinutes() / 60, 0, 24) : 0
    }, pd.copyArray = function (t, e, r) {
        r = r || Math.round(Math.min(t.length, e.length));
        for (var n = 0; n < r; ++n) e[n] = t[n]
    }, pd.isArray = Array.isArray || function (t) {
        return !!t && "[object Array]" === Object.prototype.toString.call(t)
    }, pd.isObject = function (t) {
        return null !== t && ("object" == typeof t || "function" == typeof t)
    }, pd.sleepFor = function (t) {
        for (var e = (new Date).getTime(); (new Date).getTime() < e + t;) ;
        return pd
    }, pd.parseCSV = function (t) {
        for (var e, r = [""], n = !1, i = 0, a = 0; a < t.length; a++) if ('"' == (e = t[a]) && n && '"' == t[a + 1]) r[i] += e, ++a; else if ('"' != e) if ("," != e || n) {
            if ("\n" == e && !n) break;
            r[i] += e
        } else r[++i] = ""; else n = !n;
        return r
    }, pd.createCircularLookUpTable = function (t) {
        function e(t) {
            return t = pd._fastWrap(t, 0, 360), t <= 90 ? i[Math.round(t * n)] : t <= 180 ? i[Math.round((180 - t) * n)] : t <= 270 ? -i[Math.round((t - 180) * n)] : -i[Math.round((360 - t) * n)]
        }

        if (t < .001) throw"ERROR: Table increment must be a positive value greater than 0.001 of a degree.";
        var r = this, n = 1 / t, i = [];
        return this.getEntryInDegrees = function (t) {
            return e(t)
        }, this.getEntryInRadians = function (t) {
            return e(t * pd.Const.RAD2DEG)
        }, this.sinDegrees = function (t) {
            return e(t).sin
        }, this.sinDegrees = function (t) {
            return e(t).cos
        }, this.sinRadians = function (t) {
            return e(t * pd.Const.RAD2DEG).sin
        }, this.cosRadians = function (t) {
            return e(t * pd.Const.RAD2DEG).cos
        }, this.interpolateInDegrees = function (t) {
            var e, r = (t = pd._fastWrap(t, 0, 360)) * n, a = i[Math.floor(r)], s = i[Math.ceil(r)],
                o = s.degrees - a.degrees;
            return e = Math.abs(o) < pd.Const.EPSILON ? 0 : (t - a.degrees) / o, [a.sin + (s.sin - a.sin) * e, a.cos + (s.cos - a.cos) * e]
        }, this.interpolateInRadians = function (t) {
            return r.interpolateInDegrees(t * pd.Const.RAD2DEG)
        }, this.incrementCount = function () {
            return i.length - 1
        }, this.incrementRaw = function (t) {
            return [i[t].sin, i[t].cos]
        }, this.increment = function (t) {
            return t = Math.round(pd.constrainTo(t, 0, i.length - 1)), [i[t].sin, i[t].cos]
        }, function (t) {
            i.length = 0;
            for (var e, r = 90 + .5 * t, n = 0; n < r; n += t) e = n * pd.Const.DEG2RAD, i.push({
                degrees: n,
                sin: Math.sin(e),
                cos: Math.cos(e)
            })
        }(t), this
    }, pd.Easing = {
        linear: function (t) {
            return t
        }, inSine: function (t) {
            return Math.sin(t * pd.Const.HALF_PI)
        }, outSine: function (t) {
            return 1 - Math.sin(t * pd.Const.HALF_PI)
        }, inOutSine: function (t) {
            return .5 * (1 + Math.sin(-pd.Const.HALF_PI + t * Math.PI))
        }, inOutSinePow: function (t, e) {
            return e = +e || 2, Math.pow(.5 * (1 + Math.cos(-Math.PI + t * Math.PI)), e)
        }, inQuad: function (t) {
            return t * t
        }, outQuad: function (t) {
            return t * (2 - t)
        }, inOutQuad: function (t) {
            return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
        }, inCubic: function (t) {
            return t * t * t
        }, outCubic: function (t) {
            return --t * t * t + 1
        }, inOutCubic: function (t) {
            return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
        }, inQuart: function (t) {
            return t * t * t * t
        }, outQuart: function (t) {
            return 1 - --t * t * t * t
        }, inOutQuart: function (t) {
            return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
        }, inQuint: function (t) {
            return t * t * t * t * t
        }, outQuint: function (t) {
            return 1 + --t * t * t * t * t
        }, inOutQuint: function (t) {
            return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
        }, inExpo: function (t) {
            return (Math.pow(2, 8 * t) - 1) / 255
        }, outExpo: function (t) {
            return 1 - Math.pow(2, -8 * t)
        }, inOutExpo: function (t) {
            return t < .5 ? (Math.pow(2, 16 * t) - 1) / 510 : 1 - .5 * Math.pow(2, -16 * (t - .5))
        }, inCirc: function (t) {
            return 1 - Math.sqrt(1 - t)
        }, outCirc: function (t) {
            return Math.sqrt(t)
        }, inOutCirc: function (t) {
            return t < .5 ? .5 * (1 - Math.sqrt(1 - 2 * t)) : .5 * (1 + Math.sqrt(2 * t - 1))
        }, inBack: function (t) {
            return t * t * (2.70158 * t - 1.70158)
        }, outBack: function (t) {
            return 1 + --t * t * (2.70158 * t + 1.70158)
        }, inOutBack: function (t) {
            return t < .5 ? t * t * (7 * t - 2.5) * 2 : 1 + --t * t * 2 * (7 * t + 2.5)
        }, inBounce: function (t) {
            var e = t * t;
            return e * e * Math.sin(t * Math.PI * 4.5)
        }, outBounce: function (t) {
            var e = (t - 1) * (t - 1);
            return 1 - e * e * Math.cos(t * Math.PI * 4.5)
        }, inOutBounce: function (t) {
            var e;
            return t < .45 ? 8 * (e = t * t) * e * Math.sin(t * Math.PI * 9) : t < .55 ? .5 + .75 * Math.sin(t * Math.PI * 4) : 1 - 8 * (e = (t - 1) * (t - 1)) * e * Math.sin(t * Math.PI * 9)
        }, outElastic: function (t, e) {
            return e = e || .35, Math.pow(2, -10 * t) * Math.sin((t - e / 4) * (2 * Math.PI) / e) + 1
        }
    }
}();
var pd3D = pd3D || {};
!function () {
    pd3D.RENDER_FIRST = -1, pd3D.RENDER_LAST = -2, pd3D.RENDER_ALL = -99;
    var t = 100;
    pd3D.getUniqueID = function () {
        return t++
    }, pd3D.Mesh = function (t) {
        t = t || {}, this.id = pd3D.getUniqueID(), this.visible = !1 !== t.visible, this.defaultNormal = t.defaultNormal || [0, 0, 1], this.defaultColor = t.defaultColor || [.8, .8, .8, 1], this.defaultLineColor = t.defaultLineColor || this.defaultColor, this.defaultCoord = t.defaultCoord || [0, 0], this.hasVertexNormals = !1, this.hasVertexColors = !1, this.hasVertexCoords = !1, this.hasLines = !1, this.noCullFace = null != t.noCullFace ? !!t.noCullFace : null, this.usageHint = t.dynamic ? 35048 : 35044, this.activeSubMesh = null, this.vertexBuffers = {}, this.indexBuffers = {}, this.addVertexBuffer("vertices", "gl_Vertex"), t.coords && this.addVertexBuffer("coords", "gl_TexCoord"), t.normals && this.addVertexBuffer("normals", "gl_Normal"), t.colors && this.addVertexBuffer("colors", "gl_Color"), !t.triangles && "triangles" in t || this.addIndexBuffer("triangles"), t.points && this.addIndexBuffer("points"), t.lines && this.addIndexBuffer("lines")
    }, pd3D.Mesh.prototype = {
        addVertexBuffer: function (t, e, r) {
            return r = r || this.usageHint, (this.vertexBuffers[e] = new pd3D.Buffer(34962, Float32Array, r)).name = t, this[t] = [], this.hasVertexNormals = void 0 !== this.normals, this.hasVertexColors = void 0 !== this.colors, this.hasVertexCoords = void 0 !== this.coords, this
        }, addIndexBuffer: function (t, e) {
            return e = e || this.usageHint, this.indexBuffers[t] = new pd3D.Buffer(34963, Uint16Array, e), this[t] = [], this.hasLines = void 0 !== this.lines, this
        }, hide: function () {
            return this.visible = !1, this
        }, show: function (t) {
            return this.visible = !1 !== t, this
        }, begin: function (t) {
            if (this.activeSubMesh && pd.toNumber(this.activeSubMesh.mode, -1) >= 0) throw new Error("Mismatched 'gl.begin()' and 'gl.end()' calls.");
            switch (t) {
                case 0:
                    this.points || this.addIndexBuffer("points");
                    break;
                case 1:
                case 2:
                case 3:
                    this.lines || this.addIndexBuffer("lines");
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    this.triangles || this.addIndexBuffer("triangles");
                    break;
                default:
                    throw new TypeError("Given primitive mode is invalid.")
            }
            return null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh), this.activeSubMesh = new pd3D.SubMesh, this.startSubMesh(this.activeSubMesh), this.activeSubMesh.mode = t, this
        }, normal: function (t) {
            switch (arguments.length) {
                case 0:
                    return this.defaultNormal;
                case 1:
                    if (Array.isArray(t) && t.length >= 3) t.length > 3 ? this.defaultNormal = [t[0], t[1], t[2]] : this.defaultNormal = t; else {
                        if (!(t instanceof pd3D.Vector)) throw new TypeError("Invalid vector, must be either a pd3D.Vector() or an [x,y,z] array.");
                        this.defaultNormal = t.toArray()
                    }
                    break;
                case 3:
                case 4:
                    this.defaultNormal = [+arguments[0], +arguments[1], +arguments[2]];
                    break;
                default:
                    throw new Error("Invalid arguments, must be given as x, y and z values.")
            }
            return this
        }, color: function (t) {
            switch (arguments.length) {
                case 0:
                    return this.defaultColor;
                case 2:
                    if (!Array.isArray(t) || t.length < 3) throw new TypeError("Invalid color, must be either an [r,g,b] or an [r,g,b,a] array.");
                    t = [t[0], t[1], t[2], pd.constrainTo(+arguments[1], 0, 1)];
                case 1:
                    if (Array.isArray(t)) if (4 == t.length) this.defaultColor = t; else {
                        if (3 != t.length) throw new TypeError("Invalid color, must be either an [r,g,b] or an [r,g,b,a] array.");
                        this.defaultColor = [+t[0], +t[1], +t[2], 1]
                    } else if (t instanceof pd3D.Vector) this.defaultColor = [t.x, t.y, t.z, 1]; else {
                        if (!((t = (+t).toString(16)).length > 7)) throw new TypeError("Invalid color, must be either an [r,g,b] or an [r,g,b,a] array.");
                        this.defaultColor = [parseInt(t.substring(2, 4), 16) / 255, parseInt(t.substring(4, 6), 16) / 255, parseInt(t.substring(6, 8), 16) / 255, parseInt(t.substring(0, 2), 16) / 255]
                    }
                    break;
                case 3:
                    this.defaultColor = [+arguments[0], +arguments[1], +arguments[2], 1];
                    break;
                case 4:
                    this.defaultColor = [+arguments[0], +arguments[1], +arguments[2], +arguments[3]];
                    break;
                default:
                    throw new TypeError("Invalid arguments, must be given as r, g, b [, a] values.")
            }
            return this
        }, texCoord: function (t) {
            switch (arguments.length) {
                case 0:
                    return this.defaultCoord;
                case 1:
                    if (Array.isArray(t) && t.length >= 2) t.length > 2 ? this.defaultCoord = [t[0], t[1]] : this.defaultCoord = t; else {
                        if (!(t instanceof pd3D.Vector)) throw new TypeError("Invalid vector, must be either a pd3D.Vector() or an [x,y,z] array.");
                        this.defaultCoord = t.toArray(2)
                    }
                    break;
                case 2:
                case 3:
                    this.defaultCoord = [+arguments[0], +arguments[1]];
                    break;
                default:
                    throw new Error("Invalid arguments, must be given as an x, y and z values.")
            }
            return this
        }, vertex: function (t) {
            var e = -1;
            return t && (2 == t.length && (t[2] = 0), this.isReusing && this._vtx_index < this.vertices.length ? (e = this._vtx_index, this.vertices[e] = t, this.hasVertexColors && (this.colors[e] = this.defaultColor), this.hasVertexNormals && (this.normals[e] = this.defaultNormal), this.hasVertexCoords && (this.coords[e] = this.defaultCoord), e = this._vtx_index++) : (e = this.vertices.length, this.vertices.push(t), this.hasVertexColors && this.colors.push(this.defaultColor), this.hasVertexNormals && this.normals.push(this.defaultNormal), this.hasVertexCoords && this.coords.push(this.defaultCoord), this._vtx_index = e + 1)), e
        }, end: function () {
            var t = this.activeSubMesh;
            if (this.endSubMesh(t), !t || -1 == pd.toNumber(t.mode, -1)) throw new Error("Mismatched 'mesh.begin()' and 'mesh.end()' calls.");
            var e = t.vtx_start, r = t.vtx_stop;
            switch (t.mode) {
                case 0:
                    for (i = e; i < r; ++i) this.addPoint(i);
                    break;
                case 1:
                    for (i = e + 1; i < r; i += 2) this.addLine(i - 1, i);
                    break;
                case 2:
                    this.addLine(r - 1, e);
                case 3:
                    for (i = e + 1; i < r; ++i) this.addLine(i - 1, i);
                    break;
                case 4:
                    for (i = e + 2; i < r; i += 3) this.addTriangle(i - 2, i - 1, i);
                    break;
                case 5:
                    for (var n = !0, i = e + 2; i < r; ++i) n ? this.addTriangle(i - 2, i - 1, i) : this.addTriangle(i - 1, i - 2, i), n = !n;
                    break;
                case 6:
                    for (i = e + 2; i < r; ++i) this.addTriangle(e, i - 1, i);
                    break;
                case 7:
                    for (i = e + 3; i < r; i += 4) this.addTriangle(indices[i - 3], indices[i - 2], indices[i - 1]), this.addTriangle(indices[i - 3], indices[i - 1], indices[i]);
                    break;
                case 8:
                    for (i = e + 3; i < r; i += 2) this.addTriangle(indices[i - 3], indices[i - 2], indices[i - 1]), this.addTriangle(indices[i - 3], indices[i - 1], indices[i])
            }
            return this
        }, getVertex: function (t) {
            if ((t = pd.toNumber(t, -1)) < 0 || t >= this.vertices.length) throw new Error("Invalid vertex index, must be a number between zero and `vertices` array length.");
            return this.vertices[t]
        }, reuseStart: function (t) {
            return null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh), this.isReusing = !0, null != t ? (this._vtx_index = +t.vtx_start || 0, this._tri_index = +t.tri_start || 0, this._lin_index = +t.lin_start || 0, this._pts_index = +t.pts_start || 0) : (this._vtx_index = 0, this._tri_index = 0, this._lin_index = 0, this._pts_index = 0), this
        }, addVertex: function (t, e, r, n) {
            var i = -1;
            return t && (2 == t.length && (t[2] = 0), this.isReusing && this._vtx_index < this.vertices.length ? (i = this._vtx_index, this.vertices[i] = t, this.hasVertexColors && (this.colors[i] = e || this.defaultColor), this.hasVertexNormals && (this.normals[i] = r || this.defaultNormal), this.hasVertexCoords && (this.coords[i] = n || this.defaultCoord), this._vtx_index++) : (i = this.vertices.length, this.vertices.push(t), this.hasVertexColors && this.colors.push(e || this.defaultColor), this.hasVertexNormals && this.normals.push(r || this.defaultNormal), this.hasVertexCoords && this.coords.push(n || this.defaultCoord), this._vtx_index = i + 1)), i
        }, addVertexData: function (t) {
            var e = -1;
            if (t) {
                if (!t.pos) throw new TypeError("Vertex data must at least have a valid 'pos' property.");
                2 == t.pos.length && (t.pos[2] = 0), this.isReusing && this._vtx_index < this.vertices.length ? (e = this._vtx_index, this.vertices[e] = t.pos, this.hasVertexColors && (this.colors[e] = t.color || this.defaultColor), this.hasVertexNormals && (this.normals[e] = t.normal || this.defaultNormal), this.hasVertexCoords && (this.coords[e] = t.coord || this.defaultCoord), this._vtx_index++) : (e = this.vertices.length, this.vertices.push(t.pos), this.hasVertexColors && this.colors.push(t.color || this.defaultColor), this.hasVertexNormals && this.normals.push(t.normal || this.defaultNormal), this.hasVertexCoords && this.coords.push(t.coord || this.defaultCoord), this._vtx_index = e + 1)
            }
            return e
        }, addTriangle: function (t, e, r) {
            if (this.isReusing && this._tri_index < this.triangles.length) {
                var n = this.triangles[this._tri_index];
                return n[0] = t, n[1] = e, n[2] = r, this._tri_index++
            }
            return this.triangles.push([t, e, r]), this._tri_index = this.triangles.length, this.triangles.length - 1
        }, addQuad: function (t, e, r, n) {
            var i = this.addTriangle(t, e, r);
            return this.addTriangle(t, r, n), i
        }, addLine: function (t, e) {
            if (this.isReusing && this._lin_index < this.lines.length) {
                var r = this.lines[this._lin_index];
                return r[0] = t, r[1] = e, this._lin_index++
            }
            return this.lines.push([t, e]), this._lin_index = this.lines.length, this.lines.length - 1
        }, addLineStrip: function (t) {
            Array.isArray(t) || (t = arguments);
            for (var e = t.length, r = this.lines.length, n = 1; n < e; ++n) this.addLine(t[n - 1], t[n]);
            return r
        }, addDraftingLine: function (t, e, r) {
            var n = this.addLine(t, e);
            if (r > 0) {
                var i = [this.defaultColor[0], this.defaultColor[1], this.defaultColor[2], 0], a = this.vertices[t],
                    s = this.vertices[e],
                    o = new pd3D.Vector(s[0] - a[0], s[1] - a[1], s[2] - a[2]).normalize().scale(r);
                this.addLine(t, this.addVertex([a[0] - o.x, a[1] - o.y, a[2] - o.z], i)), this.addLine(e, this.addVertex([s[0] + o.x, s[1] + o.y, s[2] + o.z], i))
            }
            return n
        }, addPoint: function (t) {
            return this.isReusing && this._pts_index < this.points.length ? (this.points[this._pts_index] = t, this._pts_index++) : (this.points.push(t), this._pts_index = this.points.length, this.points.length - 1)
        }, addFacet: function (t, e) {
            if (!Array.isArray(e) || !Array.isArray(e[0])) throw new TypeError("Vertices must be given as an array of vector arrays.");
            this.begin(t);
            for (var r = 0, n = e.length; r < n; ++r) this.vertex(e[r]);
            return this.end(), this
        }, reuseEnd: function () {
            return this.vertices && this.vertices.length > this._vtx_index && (this.vertices.length = this._vtx_index), this.hasVertexNormals && this.normals.length > this._vtx_index && (this.normals.length = this._vtx_index), this.hasVertexColors && this.colors.length > this._vtx_index && (this.colors.length = this._vtx_index), this.hasVertexCoords && this.coords.length > this._vtx_index && (this.coords.length = this._vtx_index), this.triangles && this.triangles.length > this._tri_index && (this.triangles.length = this._tri_index), this.lines && this.lines.length > this._lin_index && (this.lines.length = this._lin_index), this.points && this.points.length > this._pts_index && (this.points.length = this._pts_index), this.isReusing = !1, this
        }, hasContent: function () {
            if (this.isReusing) {
                if (this._vtx_index > 0 && (this._tri_index > 0 || this._pts_index > 0 || this._lin_index > 0)) return !0
            } else if (this.vertices && this.vertices.length > 0 && (this.triangles && this.triangles.length > 0 || this.points && this.points.length > 0 || this.lines && this.lines.length > 0)) return !0;
            return !1
        }, vertexCount: function () {
            return this.isReusing ? this._vtx_index : this.vertices ? this.vertices.length : 0
        }, triangleCount: function () {
            return this.isReusing ? this._tri_index : this.triangles ? this.triangles.length : 0
        }, lineCount: function () {
            return this.isReusing ? this._lin_index : this.lines ? this.lines.length : 0
        }, pointCount: function () {
            return this.isReusing ? this._pts_index : this.points ? this.points.length : 0
        }, startSubMesh: function (t) {
            return null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh), t = t || new SubMesh, t.vtx_start = t.vtx_stop = this.vertexCount(), t.tri_start = t.tri_stop = this.triangleCount(), t.lin_start = t.lin_stop = this.lineCount(), t.pts_start = t.pts_stop = this.pointCount(), this.activeSubMesh = t, t
        }, endSubMesh: function (t) {
            return null != (t = t || this.activeSubMesh) && (t.vtx_stop = this.vertexCount(), t.tri_stop = this.triangleCount(), t.lin_stop = this.lineCount(), t.pts_stop = this.pointCount()), this.activeSubMesh = null, t
        }, merge: function (t) {
            if (t) {
                var e, r, n, i = this.vertexCount(), a = this.isReusing;
                a && this.reuseEnd();
                var s = t.vertices, o = this.vertices;
                for (e = 0, r = s.length; e < r; ++e) o.push(s[e]);
                if (this.hasVertexNormals && t.hasVertexNormals) for (s = t.normals, o = this.normals, e = 0, r = s.length; e < r; ++e) o.push(s[e]);
                if (this.hasVertexColors && t.hasVertexColors) for (s = t.colors, o = this.colors, e = 0, r = s.length; e < r; ++e) o.push(s[e]);
                if (this.hasVertexCoords && t.hasVertexCoords) for (s = t.coords, o = this.coords, e = 0, r = s.length; e < r; ++e) o.push(s[e]);
                if (this.triangles && this.triangles.length > 0) for (s = t.triangles, o = this.triangles, e = 0, r = s.length; e < r; ++e) n = s[e], o.push([n[0] + i, n[1] + i, n[2] + i]);
                if (this.lines && this.lines.length > 0) for (s = t.lines, o = this.lines, e = 0, r = s.length; e < r; ++e) n = s[e], o.push([n[0] + i, n[1] + i]);
                if (this.points && this.points.length > 0) for (s = t.points, o = this.points, e = 0, r = s.length; e < r; ++e) o.push(s[e] + i);
                this.vertices && (this._vtx_index = this.vertices.length), this.triangles && (this._tri_index = this.triangles.length), this.lines && (this._lin_index = this.lines.length), this.points && (this._pts_index = this.points.length), this.isReusing = a
            }
            return this
        }, addLineExtensions: function (t, e, r) {
            if (t && t.lines && t.lines.length && e) {
                this.lines || this.addIndexBuffer("lines");
                for (var n, i, a, s, o, d, h, u = new pd3D.Vector, c = t.vertices, l = this.defaultColor, p = [l[0], l[1], l[2], 0], f = t.lines.length, m = 0; m < f; ++m) n = c[(h = t.lines[m])[0]], i = c[h[1]], u.x = i[0] - n[0], u.y = i[1] - n[1], u.z = i[2] - n[2], d = Math.min(e, .2 * u.length()), u.normalize().scale(d), s = this.addVertex(n, l), o = this.addVertex(i, l), r && this.addLine(s, o), a = this.addVertex([n[0] - u.x, n[1] - u.y, n[2] - u.z], p), this.addLine(s, a), a = this.addVertex([i[0] + u.x, i[1] + u.y, i[2] + u.z], p), this.addLine(o, a);
                this.defaultColor = l
            }
            return this
        }, updateOpacity: function (t, e) {
            if (this.colors) {
                for (var r, n = this.colors.length, i = 0; i < n; ++i) (r = this.colors[i]).fade || (r[3] = t);
                e || this.compileBuffer("gl_Color")
            }
            return this
        }, compile: function () {
            if (this.isReusing && this.reuseEnd(), null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh), this.vertices.length > 0) {
                for (var t in this.vertexBuffers) (r = this.vertexBuffers[t]).data = this[r.name], r.compile();
                for (var e in this.indexBuffers) {
                    var r = this.indexBuffers[e];
                    r.data = this[e], r.compile()
                }
            }
            return this
        }, compileBuffer: function (t) {
            this.isReusing && this.reuseEnd(), null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh);
            for (var e = 0, r = arguments.length; e < r; ++e) if (t = arguments[e], this.vertexBuffers[t]) (n = this.vertexBuffers[t]).data = this[n.name], n.compile(); else if (this.indexBuffers[t]) {
                var n = this.indexBuffers[t];
                n.data = this[t], n.compile()
            }
            return this
        }, clear: function () {
            this.isReusing && this.reuseEnd(), null != this.activeSubMesh && this.endSubMesh(this.activeSubMesh), this.vertices && (this.vertices.length = 0), this.normals && (this.normals.length = 0), this.colors && (this.colors.length = 0), this.coords && (this.coords.length = 0), this.triangles && (this.triangles.length = 0), this.points && (this.points.length = 0), this.lines && (this.lines.length = 0);
            for (var t in this.vertexBuffers) this.vertexBuffers[t].data = null;
            for (var e in this.indexBuffers) this.indexBuffers[e].data = null;
            return this
        }, destroy: function () {
            this.clear();
            for (var t in this.vertexBuffers) {
                var e = this.vertexBuffers[t];
                e.buffer && (gl.bindBuffer(34962, e.buffer), gl.bufferData(34962, 1, 35044), gl.deleteBuffer(e.buffer))
            }
            for (var r in this.indexBuffers) {
                var n = this.indexBuffers[r];
                n.buffer && (gl.bindBuffer(34962, n.buffer), gl.bufferData(34962, 1, 35044), gl.deleteBuffer(n.buffer))
            }
            return this.vertexBuffers = {}, this.indexBuffers = {}, this
        }, transform: function (t, e, r, n) {
            var i, a = this.vertexCount();
            r = +r || 0, n = +n || a, r >= a && (r = a - 1), r < 0 && (r = 0);
            for (s = r; s < n; ++s) i = this.vertices[s].slice(), t.applyPointTransformToArray(i), this.vertices[s] = i;
            if (this.normals && this.normals.length == a) {
                e = e || t.inverse().transpose();
                for (var s = r; s < n; ++s) i = this.normals[s].slice(), pd3D.Vector.normaliseArrayInPlace(e.applyVectorTransformToArray(i)), this.normals[s] = i
            }
            return this.compile(), this
        }, transformInPlace: function (t, e, r, n) {
            var i = this.vertexCount();
            r = +r || 0, n = +n || i, r >= i && (r = i - 1), r < 0 && (r = 0);
            for (a = r; a < n; ++a) t.applyPointTransformToArray(this.vertices[a]);
            if (this.normals && this.normals.length == i) {
                e = e || t.inverse().transpose();
                for (var a = r; a < n; ++a) pd3D.Vector.normaliseArrayInPlace(e.applyVectorTransformToArray(this.normals[a]))
            }
            return this.compile(), this
        }, reverseNormals: function (t) {
            return this.normals && (this.isReusing && this.normals.length > this._vtx_index && (this.normals.length = this._vtx_index), this.normals = this.normals.map(function (t) {
                return [-t[0], -t[1], -t[2]]
            }), t || this.compileBuffer("gl_Normal")), this
        }, reverseTriangles: function (t) {
            if (this.triangles) for (var e, r, n = this.triangleCount(), i = 0; i < n; ++i) e = (r = this.triangles[i])[1], r[1] = r[2], r[2] = e;
            return t || this.compile(), this
        }, translate: function (t, e, r, n) {
            return this.vertices && (this.isReusing && this.vertices.length > this._vtx_index && (this.vertices.length = this._vtx_index), this.vertices = this.vertices.map(function (n) {
                return [n[0] + t, n[1] + e, n[2] + r]
            }), n || this.compileBuffer("gl_Vertex")), this
        }, scale: function (t, e, r, n) {
            return this.vertices && (this.isReusing && this.vertices.length > this._vtx_index && (this.vertices.length = this._vtx_index), this.vertices = this.vertices.map(function (n) {
                return [n[0] * t, n[1] * e, n[2] * r]
            }), n || this.compileBuffer("gl_Vertex")), this
        }, swapYZ: function (t) {
            return this.vertices && (this.isReusing && this.vertices.length > this._vtx_index && (this.vertices.length = this._vtx_index), this.vertices = this.vertices.map(function (t) {
                return [t[0], -t[2], t[1]]
            })), this.normals && (this.isReusing && this.normals.length > this._vtx_index && (this.normals.length = this._vtx_index), this.normals = this.normals.map(function (t) {
                return [t[0], -t[2], t[1]]
            })), t || this.compile(), this
        }, computeNormals: function (t) {
            this.normals || this.addVertexBuffer("normals", "gl_Normal"), this.isReusing && this.reuseEnd();
            for (var e = this.vertices.length, r = 0; r < e; r++) this.normals[r] = new pd3D.Vector;
            e = this.triangles.length;
            for (r = 0; r < e; r++) {
                var n = this.triangles[r], i = pd3D.Vector.fromArray(this.vertices[n[0]]),
                    a = pd3D.Vector.fromArray(this.vertices[n[1]]), s = pd3D.Vector.fromArray(this.vertices[n[2]]),
                    o = a.subtract(i).cross(s.subtract(i)).normalize();
                this.normals[n[0]] = this.normals[n[0]].add(o), this.normals[n[1]] = this.normals[n[1]].add(o), this.normals[n[2]] = this.normals[n[2]].add(o)
            }
            e = this.normals.length;
            for (r = 0; r < e; r++) this.normals[r] = this.normals[r].normalize().toArray();
            return t || this.compile(), this
        }, computeWireframe: function (t, e) {
            var r, n, i, a, s, o, d = new pd3D.IndexCounter;
            if (this.isReusing && this.reuseEnd(), t) {
                for (n = this.triangles.length, h = 0; h < n; h++) a = (i = this.triangles[h])[0], s = i[1], o = i[2], d.count([Math.min(a, s), Math.max(a, s)]), d.count([Math.min(s, o), Math.max(s, o)]), d.count([Math.min(o, a), Math.max(o, a)]);
                this.lines || this.addIndexBuffer("lines"), n = d.unique.length;
                for (var h = 0; h < n; h++) d.counter[h] % 2 > 0 && this.lines.push(d.unique[h])
            } else {
                for (n = this.triangles.length, h = 0; h < n; h++) for (i = this.triangles[h], r = 0; r < i.length; r++) a = i[r], s = i[(r + 1) % i.length], d.count([Math.min(a, s), Math.max(a, s)]);
                this.lines || this.addIndexBuffer("lines"), this.lines = d.unique
            }
            return e || this.compile(), this
        }, computeBoundingBox: function () {
            var t, e, r, n;
            this.boundingBox || (this.boundingBox = {}), (t = this.boundingBox).min ? t.min.init(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE) : t.min = new pd3D.Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t.max = pd3D.Vector.negative(t.min, t.max), r = t.min, n = t.max;
            for (var i = 0; i < this.vertices.length; i++) e = this.vertices[i], r.x > e[0] && (r.x = e[0]), r.y > e[1] && (r.y = e[1]), r.z > e[2] && (r.z = e[2]), n.x < e[0] && (n.x = e[0]), n.y < e[1] && (n.y = e[1]), n.z < e[2] && (n.z = e[2]);
            return this
        }, getAABB: function (t) {
            var e, r, n;
            t && t.min || ((t = {min: new pd3D.Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)}).max = t.min.negative()), r = t.min, n = t.max;
            for (var i = 0; i < this.vertices.length; i++) e = this.vertices[i], r.x > e[0] && (r.x = e[0]), r.y > e[1] && (r.y = e[1]), r.z > e[2] && (r.z = e[2]), n.x < e[0] && (n.x = e[0]), n.y < e[1] && (n.y = e[1]), n.z < e[2] && (n.z = e[2]);
            return t
        }, getBoundingSphere: function () {
            for (var t = this.getAABB(), e = {
                center: t.min.add(t.max).divide(2),
                radius: 0
            }, r = 0; r < this.vertices.length; r++) e.radius = Math.max(e.radius, pd3D.Vector.fromArray(this.vertices[r]).subtract(e.center).length());
            return e
        }
    }, pd3D.Mesh.load = function (t, e, r) {
        return "coords" in (e = e || {}) || (e.coords = !!t.coords), "normals" in e || (e.normals = !!t.normals), "colors" in e || (e.colors = !!t.colors), "triangles" in e || (e.triangles = !!t.triangles), "points" in e || (e.points = !!t.points), "lines" in e || (e.lines = !!t.lines), r ? r.clear() : r = new pd3D.Mesh(e), r.vertices = t.vertices, r.coords && (r.coords = t.coords), r.normals && (r.normals = t.normals), r.colors && (r.colors = t.colors), r.triangles && (r.triangles = t.triangles), r.points && (r.points = t.points), r.lines && (r.lines = t.lines), "noCullFace" in t && (r.noCullFace = t.noCullFace), r.compile(), r
    }, pd3D.SubMesh = function () {
        this.vtx_start = 0, this.vtx_stop = 0, this.tri_start = 0, this.tri_stop = 0, this.lin_start = 0, this.lin_stop = 0, this.pts_start = 0, this.pts_stop = 0
    }, pd3D.Buffer = function (t, e, r) {
        this.buffer = null, this.target = t, this.type = e, this.usageHint = r || 35044, this.data = []
    }, pd3D.Buffer.prototype.compile = function (t) {
        var e = [];
        if (this.data.length > 0 && !Array.isArray(this.data[0])) e = this.data; else for (var r = 0; r < this.data.length; r += 1e4) e = Array.prototype.concat.apply(e, this.data.slice(r, r + 1e4));
        var n = this.data.length ? e.length / this.data.length : 0;
        if (n != Math.round(n)) throw"buffer elements not of consistent size, average size is " + n;
        this.buffer = this.buffer || gl.createBuffer(), this.buffer.length = e.length, this.buffer.spacing = n, gl.bindBuffer(this.target, this.buffer), gl.bufferData(this.target, new this.type(e), t || this.usageHint)
    }, pd3D.Vector = function (t, e, r) {
        this.x = 0, this.y = 0, this.z = 0, arguments.length > 0 && (1 == arguments.length ? t instanceof pd3D.Vector ? (this.x = t.x, this.y = t.y, this.z = t.z) : Array.isArray(t) ? (this.x = +t[0] || 0, this.y = +t[1] || 0, this.z = +t[2] || 0) : (t = +t || 0, this.x = t, this.y = t, this.z = t) : (this.x = +t || 0, this.y = +e || 0, this.z = +r || 0))
    }, pd3D.Vector.prototype = {
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }, normalize: function () {
            var t = this.length();
            return t > 0 && (this.x /= t, this.y /= t, this.z /= t), this
        }, move: function (t, e, r) {
            return 1 == arguments.length ? t instanceof pd3D.Vector ? (this.x += t.x, this.y += t.y, this.z += t.z) : Array.isArray(t) ? (this.x += +t[0] || 0, this.y += +t[1] || 0, this.z += +t[2] || 0) : (t = +t || 0, this.x += t, this.y += t, this.z += t) : (this.x += +t || 0, this.y += +e || 0, this.z += +r || 0), this
        }, scale: function (t, e, r) {
            return 1 == arguments.length ? t instanceof pd3D.Vector ? (this.x *= t.x, this.y *= t.y, this.z *= t.z) : Array.isArray(t) ? (this.x *= +t[0] || 0, this.y *= +t[1] || 0, this.z *= +t[2] || 0) : (t = +t || 0, this.x *= t, this.y *= t, this.z *= t) : (this.x *= +t || 0, this.y *= +e || 0, this.z *= +r || 0), this
        }, fromPolarAngles: function (t, e) {
            var r = Math.cos(e);
            return this.init(r * Math.sin(t), r * Math.cos(t), Math.sin(e)), this
        }, fromArray: function (t) {
            return this.x = t[0], this.y = t[1], this.z = t[2], this
        }, init: function (t, e, r) {
            return 1 == arguments.length ? t instanceof pd3D.Vector ? (this.x = t.x, this.y = t.y, this.z = t.z) : Array.isArray(t) ? (this.x = +t[0] || 0, this.y = +t[1] || 0, this.z = +t[2] || 0) : (t = +t || 0, this.x = t, this.y = t, this.z = t) : (this.x = +t || 0, this.y = +e || 0, this.z = +r || 0), this
        }, distanceTo: function (t) {
            var e = t.x - this.x, r = t.y - this.y, n = t.z - this.z;
            return Math.sqrt(e * e + r * r + n * n)
        }, negative: function () {
            return new pd3D.Vector(-this.x, -this.y, -this.z)
        }, add: function (t) {
            return t instanceof pd3D.Vector ? new pd3D.Vector(this.x + t.x, this.y + t.y, this.z + t.z) : new pd3D.Vector(this.x + t, this.y + t, this.z + t)
        }, subtract: function (t) {
            return t instanceof pd3D.Vector ? new pd3D.Vector(this.x - t.x, this.y - t.y, this.z - t.z) : new pd3D.Vector(this.x - t, this.y - t, this.z - t)
        }, multiply: function (t) {
            return t instanceof pd3D.Vector ? new pd3D.Vector(this.x * t.x, this.y * t.y, this.z * t.z) : new pd3D.Vector(this.x * t, this.y * t, this.z * t)
        }, divide: function (t) {
            return t instanceof pd3D.Vector ? new pd3D.Vector(this.x / t.x, this.y / t.y, this.z / t.z) : new pd3D.Vector(this.x / t, this.y / t, this.z / t)
        }, equals: function (t) {
            return this.x == t.x && this.y == t.y && this.z == t.z
        }, dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }, cross: function (t) {
            return new pd3D.Vector(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x)
        }, length: function () {
            return Math.sqrt(this.dot(this))
        }, unit: function () {
            return this.divide(this.length())
        }, min: function () {
            return Math.min(Math.min(this.x, this.y), this.z)
        }, max: function () {
            return Math.max(Math.max(this.x, this.y), this.z)
        }, toAngles: function () {
            return {theta: Math.atan2(this.y, this.x), phi: Math.asin(this.z / this.length())}
        }, toArray: function (t) {
            return t ? [this.x, this.y, this.z].slice(0, t) : [this.x, this.y, this.z]
        }, clone: function () {
            return new pd3D.Vector(this.x, this.y, this.z)
        }
    }, pd3D.Vector.negative = function (t, e) {
        return e = e || new pd3D.Vector, e.x = -t.x, e.y = -t.y, e.z = -t.z, e
    }, pd3D.Vector.add = function (t, e, r) {
        return r = r || new pd3D.Vector, e instanceof pd3D.Vector ? (r.x = t.x + e.x, r.y = t.y + e.y, r.z = t.z + e.z) : (r.x = t.x + e, r.y = t.y + e, r.z = t.z + e), r
    }, pd3D.Vector.subtract = function (t, e, r) {
        return r = r || new pd3D.Vector, e instanceof pd3D.Vector ? (r.x = t.x - e.x, r.y = t.y - e.y, r.z = t.z - e.z) : (r.x = t.x - e, r.y = t.y - e, r.z = t.z - e), r
    }, pd3D.Vector.multiply = function (t, e, r) {
        return r = r || new pd3D.Vector, e instanceof pd3D.Vector ? (r.x = t.x * e.x, r.y = t.y * e.y, r.z = t.z * e.z) : (r.x = t.x * e, r.y = t.y * e, r.z = t.z * e), r
    }, pd3D.Vector.divide = function (t, e, r) {
        return r = r || new pd3D.Vector, e instanceof pd3D.Vector ? (r.x = t.x / e.x, r.y = t.y / e.y, r.z = t.z / e.z) : (r.x = t.x / e, r.y = t.y / e, r.z = t.z / e), r
    }, pd3D.Vector.cross = function (t, e, r) {
        r = r || new pd3D.Vector;
        var n = t.y * e.z - t.z * e.y, i = t.z * e.x - t.x * e.z, a = t.x * e.y - t.y * e.x;
        return r.x = n, r.y = i, r.z = a, r
    }, pd3D.Vector.unit = function (t, e) {
        e = e || new pd3D.Vector;
        var r = t.length();
        return e.x = t.x / r, e.y = t.y / r, e.z = t.z / r, e
    }, pd3D.Vector.fromAngles = function (t, e, r) {
        return r = r || new pd3D.Vector, r.x = Math.cos(t) * Math.cos(e), r.y = Math.sin(t) * Math.cos(e), r.z = Math.sin(e), r
    }, pd3D.Vector.rotateX = function (t, e, r, n) {
        var i = t.y - e.y, a = t.z - e.z, s = Math.cos(r), o = Math.sin(r);
        return n = n || new pd3D.Vector, n.y = i * s - a * o + e.y, n.z = a * s + i * o + e.z, n.x = t.x, n
    }, pd3D.Vector.rotateY = function (t, e, r, n) {
        var i = t.x - e.x, a = t.z - e.z, s = Math.cos(r), o = Math.sin(r);
        return n = n || new pd3D.Vector, n.x = i * s - a * o + e.x, n.z = a * s + i * o + e.z, n.y = t.y, n
    }, pd3D.Vector.rotateZ = function (t, e, r, n) {
        var i = t.x - e.x, a = t.y - e.y, s = Math.cos(r), o = Math.sin(r);
        return n = n || new pd3D.Vector, n.x = i * s - a * o + e.x, n.y = a * s + i * o + e.y, n.z = t.z, n
    }, pd3D.Vector.sphericalToCartesian3D = function (t, e, r, n) {
        var i = Math.cos(t), a = Math.sin(t), s = r * Math.cos(e);
        return n = n || new pd3D.Vector, n.x = s * i, n.y = s * a, n.z = r * Math.sin(e), n
    }, pd3D.Vector.angleBetweenPoints = function (t, e, r) {
        var n = t.distanceTo(e) * t.distanceTo(r),
            i = (e.x - t.x) * (r.x - t.x) + (e.y - t.y) * (r.y - t.y) + (e.z - t.z) * (r.z - t.z),
            a = Math.abs(n) > 1e-12 ? i / n : 0;
        return a >= 1 ? 0 : a <= -1 ? Math.PI : Math.acos(a)
    }, pd3D.Vector.randomDirection = function (t) {
        return pd3D.Vector.fromAngles(Math.random() * Math.PI * 2, Math.asin(2 * Math.random() - 1), t)
    }, pd3D.Vector.min = function (t, e, r) {
        return r = r || new pd3D.Vector, r.x = Math.min(t.x, e.x), r.y = Math.min(t.y, e.y), r.z = Math.min(t.z, e.z), r
    }, pd3D.Vector.max = function (t, e, r) {
        return r = r || new pd3D.Vector, r.x = Math.max(t.x, e.x), r.y = Math.max(t.y, e.y), r.z = Math.max(t.z, e.z), r
    }, pd3D.Vector.lerp = function (t, e, r, n) {
        if (n = n || new pd3D.Vector, r instanceof pd3D.Vector) n.x = (1 - r.x) * t.x + r.x * e.x, n.y = (1 - r.y) * t.y + r.y * e.y, n.z = (1 - r.z) * t.z + r.z * e.z; else {
            var i = +r, a = 1 - i;
            n.x = a * t.x + i * e.x, n.y = a * t.y + i * e.y, n.z = a * t.z + i * e.z
        }
        return n
    }, pd3D.Vector.fromArray = function (t, e) {
        return e = e || new pd3D.Vector, e.x = +t[0] || 0, e.y = +t[1] || 0, e.z = +t[2] || 0, e
    }, pd3D.Vector.normaliseArrayInPlace = function (t) {
        var e = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
        return e > 0 && (t[0] /= e, t[1] /= e, t[2] /= e), t
    }, pd3D.Vector.UnitX = new pd3D.Vector(1, 0, 0), pd3D.Vector.UnitY = new pd3D.Vector(0, 1, 0), pd3D.Vector.UnitZ = new pd3D.Vector(0, 0, 1);
    var e = "undefined" != typeof Float32Array;
    pd3D.Matrix = function () {
        var t = Array.prototype.concat.apply([], arguments);
        t.length || (t = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.m = e ? new Float32Array(t) : t
    }, pd3D.Matrix.prototype = {
        inverse: function (t) {
            return t = t || new pd3D.Matrix, pd3D.Matrix.inverse(this, t)
        }, transpose: function (t) {
            return t = t || new pd3D.Matrix, pd3D.Matrix.transpose(this, t)
        }, multiply: function (t, e) {
            return e = e || new pd3D.Matrix, pd3D.Matrix.multiply(this, t, e)
        }, multiplyBy: function (t, e) {
            return e = e || new pd3D.Matrix, pd3D.Matrix.multiply(this, t, e), this.init(e)
        }, init: function (t) {
            if (null != t) for (var e = this.m, r = t.m, n = 0; n < 16; n++) e[n] = r[n];
            return this
        }, transformPoint: function (t, e) {
            var r = this.m, n = r[12] * t.x + r[13] * t.y + r[14] * t.z + r[15];
            n > -1e-12 && n < 1e-12 && (n = 1);
            var i = (r[0] * t.x + r[1] * t.y + r[2] * t.z + r[3]) / n,
                a = (r[4] * t.x + r[5] * t.y + r[6] * t.z + r[7]) / n,
                s = (r[8] * t.x + r[9] * t.y + r[10] * t.z + r[11]) / n;
            return e ? e.init(i, a, s) : new pd3D.Vector(i, a, s)
        }, transformVector: function (t, e) {
            var r = this.m, n = r[0] * t.x + r[1] * t.y + r[2] * t.z, i = r[4] * t.x + r[5] * t.y + r[6] * t.z,
                a = r[8] * t.x + r[9] * t.y + r[10] * t.z;
            return e ? e.init(n, i, a) : new pd3D.Vector(n, i, a)
        }, copyToColumnMajorArray: function (t) {
            var e = this.m;
            return t = t || new Float32Array(16), t[0] = e[0], t[4] = e[1], t[8] = e[2], t[12] = e[3], t[1] = e[4], t[5] = e[5], t[9] = e[6], t[13] = e[7], t[2] = e[8], t[6] = e[9], t[10] = e[10], t[14] = e[11], t[3] = e[12], t[7] = e[13], t[11] = e[14], t[15] = e[15], t
        }, applyPointTransformToArray: function (t) {
            var e = this.m, r = e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3],
                n = e[4] * t[0] + e[5] * t[1] + e[6] * t[2] + e[7],
                i = e[8] * t[0] + e[9] * t[1] + e[10] * t[2] + e[11],
                a = e[12] * t[0] + e[13] * t[1] + e[14] * t[2] + e[15];
            return Math.abs(a) > 0 ? (t[0] = r / a, t[1] = n / a, t[2] = i / a) : (t[0] = r, t[1] = n, t[2] = i), t
        }, applyVectorTransformToArray: function (t) {
            var e = this.m, r = e[0] * t[0] + e[1] * t[1] + e[2] * t[2], n = e[4] * t[0] + e[5] * t[1] + e[6] * t[2],
                i = e[8] * t[0] + e[9] * t[1] + e[10] * t[2];
            return t[0] = r, t[1] = n, t[2] = i, t
        }
    }, pd3D.Matrix.fromArray = function (t, r) {
        if (!t || 16 != t.length) throw new TypeError("Argument 'array' must be a valid Array containing 16 numeric values.");
        return r = r || new pd3D.Matrix, r.m = e ? new Float32Array(t) : t, r
    }, pd3D.Matrix.clone = function (t, e) {
        if (e = e || new pd3D.Matrix, null != t) for (var r = e.m, n = t.m, i = 0; i < 16; i++) r[i] = n[i];
        return e
    }, pd3D.Matrix.inverse = function (t, e) {
        e = e || new pd3D.Matrix;
        var r = t.m, n = e.m;
        n[0] = r[5] * r[10] * r[15] - r[5] * r[14] * r[11] - r[6] * r[9] * r[15] + r[6] * r[13] * r[11] + r[7] * r[9] * r[14] - r[7] * r[13] * r[10], n[1] = -r[1] * r[10] * r[15] + r[1] * r[14] * r[11] + r[2] * r[9] * r[15] - r[2] * r[13] * r[11] - r[3] * r[9] * r[14] + r[3] * r[13] * r[10], n[2] = r[1] * r[6] * r[15] - r[1] * r[14] * r[7] - r[2] * r[5] * r[15] + r[2] * r[13] * r[7] + r[3] * r[5] * r[14] - r[3] * r[13] * r[6], n[3] = -r[1] * r[6] * r[11] + r[1] * r[10] * r[7] + r[2] * r[5] * r[11] - r[2] * r[9] * r[7] - r[3] * r[5] * r[10] + r[3] * r[9] * r[6], n[4] = -r[4] * r[10] * r[15] + r[4] * r[14] * r[11] + r[6] * r[8] * r[15] - r[6] * r[12] * r[11] - r[7] * r[8] * r[14] + r[7] * r[12] * r[10], n[5] = r[0] * r[10] * r[15] - r[0] * r[14] * r[11] - r[2] * r[8] * r[15] + r[2] * r[12] * r[11] + r[3] * r[8] * r[14] - r[3] * r[12] * r[10], n[6] = -r[0] * r[6] * r[15] + r[0] * r[14] * r[7] + r[2] * r[4] * r[15] - r[2] * r[12] * r[7] - r[3] * r[4] * r[14] + r[3] * r[12] * r[6], n[7] = r[0] * r[6] * r[11] - r[0] * r[10] * r[7] - r[2] * r[4] * r[11] + r[2] * r[8] * r[7] + r[3] * r[4] * r[10] - r[3] * r[8] * r[6], n[8] = r[4] * r[9] * r[15] - r[4] * r[13] * r[11] - r[5] * r[8] * r[15] + r[5] * r[12] * r[11] + r[7] * r[8] * r[13] - r[7] * r[12] * r[9], n[9] = -r[0] * r[9] * r[15] + r[0] * r[13] * r[11] + r[1] * r[8] * r[15] - r[1] * r[12] * r[11] - r[3] * r[8] * r[13] + r[3] * r[12] * r[9], n[10] = r[0] * r[5] * r[15] - r[0] * r[13] * r[7] - r[1] * r[4] * r[15] + r[1] * r[12] * r[7] + r[3] * r[4] * r[13] - r[3] * r[12] * r[5], n[11] = -r[0] * r[5] * r[11] + r[0] * r[9] * r[7] + r[1] * r[4] * r[11] - r[1] * r[8] * r[7] - r[3] * r[4] * r[9] + r[3] * r[8] * r[5], n[12] = -r[4] * r[9] * r[14] + r[4] * r[13] * r[10] + r[5] * r[8] * r[14] - r[5] * r[12] * r[10] - r[6] * r[8] * r[13] + r[6] * r[12] * r[9], n[13] = r[0] * r[9] * r[14] - r[0] * r[13] * r[10] - r[1] * r[8] * r[14] + r[1] * r[12] * r[10] + r[2] * r[8] * r[13] - r[2] * r[12] * r[9], n[14] = -r[0] * r[5] * r[14] + r[0] * r[13] * r[6] + r[1] * r[4] * r[14] - r[1] * r[12] * r[6] - r[2] * r[4] * r[13] + r[2] * r[12] * r[5], n[15] = r[0] * r[5] * r[10] - r[0] * r[9] * r[6] - r[1] * r[4] * r[10] + r[1] * r[8] * r[6] + r[2] * r[4] * r[9] - r[2] * r[8] * r[5];
        for (var i = r[0] * n[0] + r[1] * n[4] + r[2] * n[8] + r[3] * n[12], a = 0; a < 16; a++) n[a] /= i;
        return e
    }, pd3D.Matrix.transpose = function (t, e) {
        e = e || new pd3D.Matrix;
        var r = t.m, n = e.m;
        return n[0] = r[0], n[1] = r[4], n[2] = r[8], n[3] = r[12], n[4] = r[1], n[5] = r[5], n[6] = r[9], n[7] = r[13], n[8] = r[2], n[9] = r[6], n[10] = r[10], n[11] = r[14], n[12] = r[3], n[13] = r[7], n[14] = r[11], n[15] = r[15], e
    }, pd3D.Matrix.multiply = function (t, e, r) {
        var n = t.m, i = e.m;
        if (t === r) {
            (s = [])[0] = n[0] * i[0] + n[1] * i[4] + n[2] * i[8] + n[3] * i[12], s[1] = n[0] * i[1] + n[1] * i[5] + n[2] * i[9] + n[3] * i[13], s[2] = n[0] * i[2] + n[1] * i[6] + n[2] * i[10] + n[3] * i[14], s[3] = n[0] * i[3] + n[1] * i[7] + n[2] * i[11] + n[3] * i[15], s[4] = n[4] * i[0] + n[5] * i[4] + n[6] * i[8] + n[7] * i[12], s[5] = n[4] * i[1] + n[5] * i[5] + n[6] * i[9] + n[7] * i[13], s[6] = n[4] * i[2] + n[5] * i[6] + n[6] * i[10] + n[7] * i[14], s[7] = n[4] * i[3] + n[5] * i[7] + n[6] * i[11] + n[7] * i[15], s[8] = n[8] * i[0] + n[9] * i[4] + n[10] * i[8] + n[11] * i[12], s[9] = n[8] * i[1] + n[9] * i[5] + n[10] * i[9] + n[11] * i[13], s[10] = n[8] * i[2] + n[9] * i[6] + n[10] * i[10] + n[11] * i[14], s[11] = n[8] * i[3] + n[9] * i[7] + n[10] * i[11] + n[11] * i[15], s[12] = n[12] * i[0] + n[13] * i[4] + n[14] * i[8] + n[15] * i[12], s[13] = n[12] * i[1] + n[13] * i[5] + n[14] * i[9] + n[15] * i[13], s[14] = n[12] * i[2] + n[13] * i[6] + n[14] * i[10] + n[15] * i[14], s[15] = n[12] * i[3] + n[13] * i[7] + n[14] * i[11] + n[15] * i[15];
            for (var a = 0; a < 16; ++a) n[a] = s[a]
        } else {
            var s = (r = r || new pd3D.Matrix).m;
            s[0] = n[0] * i[0] + n[1] * i[4] + n[2] * i[8] + n[3] * i[12], s[1] = n[0] * i[1] + n[1] * i[5] + n[2] * i[9] + n[3] * i[13], s[2] = n[0] * i[2] + n[1] * i[6] + n[2] * i[10] + n[3] * i[14], s[3] = n[0] * i[3] + n[1] * i[7] + n[2] * i[11] + n[3] * i[15], s[4] = n[4] * i[0] + n[5] * i[4] + n[6] * i[8] + n[7] * i[12], s[5] = n[4] * i[1] + n[5] * i[5] + n[6] * i[9] + n[7] * i[13], s[6] = n[4] * i[2] + n[5] * i[6] + n[6] * i[10] + n[7] * i[14], s[7] = n[4] * i[3] + n[5] * i[7] + n[6] * i[11] + n[7] * i[15], s[8] = n[8] * i[0] + n[9] * i[4] + n[10] * i[8] + n[11] * i[12], s[9] = n[8] * i[1] + n[9] * i[5] + n[10] * i[9] + n[11] * i[13], s[10] = n[8] * i[2] + n[9] * i[6] + n[10] * i[10] + n[11] * i[14], s[11] = n[8] * i[3] + n[9] * i[7] + n[10] * i[11] + n[11] * i[15], s[12] = n[12] * i[0] + n[13] * i[4] + n[14] * i[8] + n[15] * i[12], s[13] = n[12] * i[1] + n[13] * i[5] + n[14] * i[9] + n[15] * i[13], s[14] = n[12] * i[2] + n[13] * i[6] + n[14] * i[10] + n[15] * i[14], s[15] = n[12] * i[3] + n[13] * i[7] + n[14] * i[11] + n[15] * i[15]
        }
        return r
    }, pd3D.Matrix.identity = function (t) {
        var e = (t = t || new pd3D.Matrix).m;
        return e[0] = e[5] = e[10] = e[15] = 1, e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, t
    }, pd3D.Matrix.perspective = function (t, e, r, n, i) {
        var a = Math.tan(t * Math.PI / 360) * r, s = a * e;
        return pd3D.Matrix.frustum(-s, s, -a, a, r, n, i)
    }, pd3D.Matrix.frustum = function (t, e, r, n, i, a, s) {
        var o = (s = s || new pd3D.Matrix).m;
        return o[0] = 2 * i / (e - t), o[1] = 0, o[2] = (e + t) / (e - t), o[3] = 0, o[4] = 0, o[5] = 2 * i / (n - r), o[6] = (n + r) / (n - r), o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -(a + i) / (a - i), o[11] = -2 * a * i / (a - i), o[12] = 0, o[13] = 0, o[14] = -1, o[15] = 0, s
    }, pd3D.Matrix.ortho = function (t, e, r, n, i, a, s) {
        var o = (s = s || new pd3D.Matrix).m;
        return o[0] = 2 / (e - t), o[1] = 0, o[2] = 0, o[3] = -(e + t) / (e - t), o[4] = 0, o[5] = 2 / (n - r), o[6] = 0, o[7] = -(n + r) / (n - r), o[8] = 0, o[9] = 0, o[10] = -2 / (a - i), o[11] = -(a + i) / (a - i), o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, s
    }, pd3D.Matrix.scale = function (t, e, r, n) {
        var i = (n = n || new pd3D.Matrix).m;
        return i[0] = +t || 0, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = +e || 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = +r || 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, n
    }, pd3D.Matrix.translate = function (t, e, r, n) {
        var i = (n = n || new pd3D.Matrix).m;
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = +t || 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = +e || 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = +r || 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, n
    }, pd3D.Matrix.rotate = function (t, e, r, n, i) {
        if (!t || !e && !r && !n) return pd3D.Matrix.identity(i);
        var a = (i = i || new pd3D.Matrix).m, s = Math.sqrt(e * e + r * r + n * n);
        t *= pd.Const.DEG2RAD, e /= s, r /= s, n /= s;
        var o = Math.cos(t), d = Math.sin(t), h = 1 - o;
        return a[0] = e * e * h + o, a[1] = e * r * h - n * d, a[2] = e * n * h + r * d, a[3] = 0, a[4] = r * e * h + n * d, a[5] = r * r * h + o, a[6] = r * n * h - e * d, a[7] = 0, a[8] = n * e * h - r * d, a[9] = n * r * h + e * d, a[10] = n * n * h + o, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, i
    }, pd3D.Matrix.skew = function (t, e, r) {
        r = r || new pd3D.Matrix;
        var n = Math.tan(e * pd.Const.DEG2RAD), i = r.m;
        switch (i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, t) {
            default:
            case 1:
                i[4] = n;
                break;
            case 2:
                i[8] = n;
                break;
            case 3:
                i[1] = n;
                break;
            case 4:
                i[9] = n;
                break;
            case 5:
                i[2] = n;
                break;
            case 6:
                i[6] = n
        }
        return r
    }, pd3D.Matrix.lookAt = function (t, e, r, n, i, a, s, o, d, h) {
        var u = (h = h || new pd3D.Matrix).m, c = new pd3D.Vector(t, e, r), l = new pd3D.Vector(n, i, a),
            p = new pd3D.Vector(s, o, d), f = c.subtract(l).unit(), m = p.cross(f).unit(), g = f.cross(m).unit();
        return u[0] = m.x, u[1] = m.y, u[2] = m.z, u[3] = -m.dot(c), u[4] = g.x, u[5] = g.y, u[6] = g.z, u[7] = -g.dot(c), u[8] = f.x, u[9] = f.y, u[10] = f.z, u[11] = -f.dot(c), u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, h
    }, pd3D.MatrixAccumulator = function () {
        this.tempMatrix1 = new pd3D.Matrix, this.tempMatrix2 = new pd3D.Matrix, this.resultMatrix = new pd3D.Matrix
    }, pd3D.MatrixAccumulator.prototype.toMatrix = function () {
        return this.resultMatrix
    }, pd3D.MatrixAccumulator.prototype.reset = function () {
        return pd3D.Matrix.identity(this.resultMatrix), this
    }, pd3D.MatrixAccumulator.prototype.scale = function (t, e, r) {
        return 1 == arguments.length ? e = r = t : 2 == arguments.length && (r = 1), pd3D.Matrix.scale(t, e, r, this.tempMatrix1), pd3D.Matrix.multiply(this.resultMatrix, this.tempMatrix1, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.translate = function (t, e, r) {
        return pd3D.Matrix.translate(t, e, r, this.tempMatrix1), pd3D.Matrix.multiply(this.resultMatrix, this.tempMatrix1, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.rotate = function (t, e, r, n) {
        return pd3D.Matrix.rotate(t, e, r, n, this.tempMatrix1), pd3D.Matrix.multiply(this.resultMatrix, this.tempMatrix1, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.inverse = function () {
        return pd3D.Matrix.inverse(this.resultMatrix, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.transpose = function () {
        return pd3D.Matrix.transpose(this.resultMatrix, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.multiply = function (t) {
        return pd3D.Matrix.multiply(this.resultMatrix, t, this.tempMatrix2), this.resultMatrix.init(this.tempMatrix2), this
    }, pd3D.MatrixAccumulator.prototype.init = function (t) {
        return this.resultMatrix.init(t), this
    }, pd3D.MatrixAccumulator.prototype.transformPoint = function (t, e) {
        return this.resultMatrix.transformPoint(t, e)
    }, pd3D.MatrixAccumulator.prototype.transformVector = function (t, e) {
        return this.resultMatrix.transformVector(t, e)
    }, pd3D.PolarMatrix = function () {
        pd3D.Matrix.call(this), this.angleX = 0, this.angleZ = 0, this.isIdentity = !0, this._matrixX = new pd3D.Matrix, this._matrixZ = new pd3D.Matrix, this._matrixX.hasChanged = !1, this._matrixZ.hasChanged = !1, this._matrixX.isIdentity = !0, this._matrixZ.isIdentity = !0
    }, pd3D.PolarMatrix.prototype = Object.create(pd3D.Matrix.prototype), pd3D.PolarMatrix.prototype.constructor = pd3D.PolarMatrix, pd3D.PolarMatrix.prototype._update = function () {
        var t = this.angleX, e = this._matrixX;
        e.hasChanged && (Math.abs(t) > pd.Const.EPSILON ? (pd3D.Matrix.rotate(t, 1, 0, 0, e), e.isIdentity = !1) : (e.isIdentity = !0, pd3D.Matrix.identity(e)));
        var r = this.angleZ, n = this._matrixZ;
        return n.hasChanged && (Math.abs(r) > pd.Const.EPSILON ? (pd3D.Matrix.rotate(r, 0, 0, 1, n), n.isIdentity = !1) : (n.isIdentity = !0, pd3D.Matrix.identity(n))), (e.hasChanged || n.hasChanged) && (n.isIdentity ? e.isIdentity ? (this.isIdentity = !0, pd3D.Matrix.identity(this)) : (pd3D.Matrix.clone(n, this), this.isIdentity = !1) : e.isIdentity ? (pd3D.Matrix.clone(n, this), this.isIdentity = !1) : (pd3D.Matrix.multiply(n, e, this), this.isIdentity = !1), e.hasChanged = !1, n.hasChanged = !1), this
    }, pd3D.PolarMatrix.prototype.setXZ = function (t, e) {
        var r = this._matrixX;
        pd.closeTo(this.angleX, t) || (r.hasChanged = !0, this.angleX = t);
        var n = this._matrixZ;
        return pd.closeTo(this.angleZ, e) || (n.hasChanged = !0, this.angleZ = e), (r.hasChanged || n.hasChanged) && this._update(), this
    }, pd3D.PolarMatrix.prototype.setAziAlt = function (t, e) {
        return this.setXZ(90 - e, 90 + t)
    }, pd3D.PolarMatrix.prototype.multiplyBy = function (t, e) {
        return e = e || new pd3D.Matrix, this.isIdentity || (t ? e = pd3D.Matrix.multiply(t, this, e) : pd3D.Matrix.clone(this, e)), e
    }, pd3D.Transform = function () {
        this.isIdentity = !0, this.hasChanged = !1, this._cachedMatrix = new pd3D.Matrix, Object.defineProperty(this, "m", {
            get: function () {
                return this.hasChanged && this.checkForChanges(), this._cachedMatrix.m
            }
        }), this.getMatrix = function () {
            return this.hasChanged && this.checkForChanges(), this._cachedMatrix
        }, this._xformData = [0, 0, 0, 0, 0, 0, 1, 1, 1], this._cachedData = [0, 0, 0, 0, 0, 0, 1, 1, 1], this._cachedTranslation = new pd3D.Matrix, this._cachedRotation = new pd3D.Matrix, this._cachedScale = new pd3D.Matrix, this._vectorRotation = !1, this._cachedTranslation.isIdentity = !0, this._cachedRotation.isIdentity = !0, this._cachedScale.isIdentity = !0
    }, pd3D.Transform.prototype = Object.create(pd3D.Matrix.prototype), pd3D.Transform.prototype.constructor = pd3D.Transform, pd3D.Transform.prototype.reset = function () {
        var t = this._xformData;
        return t[0] = t[1] = t[2] = 0, t[3] = t[4] = t[5] = 0, t[6] = t[7] = t[8] = 1, this._cachedTranslation.isIdentity = !0, this._cachedRotation.isIdentity = !0, this._cachedScale.isIdentity = !0, this.hasChanged = !0, this
    }, pd3D.Transform.prototype.setTranslation = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or an [tx,ty,tz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        return (Math.abs(t - i[0]) > n || Math.abs(e - i[1]) > n || Math.abs(r - i[2]) > n) && (this.hasChanged = !0), i[0] = t, i[1] = e, i[2] = r, this
    }, pd3D.Transform.prototype.addTranslation = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or a [tx,ty,tz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        return (Math.abs(t) > n || Math.abs(e) > n || Math.abs(r) > n) && (this.hasChanged = !0), i[0] += t, i[1] += e, i[2] += r, this
    }, pd3D.Transform.prototype.setVectorRotation = function (t, e, r, n) {
        var i = pd.Const.EPSILON, a = this._xformData;
        if (t = pd.toNumber(t, 0), 2 == arguments.length) {
            var s = e;
            if (!Array.isArray(s)) throw new TypeError("Parameters must be either three numeric values or a [rx,ry,rz] vector array.");
            e = +s[0] || 0, r = +s[1] || 0, n = +s[2] || 0
        }
        this._vectorAngles || (this._vectorAngles = []), this._vectorAngles[0] = t, this._vectorAngles[1] = e, this._vectorAngles[2] = r, this._vectorAngles[3] = n;
        var o = e * e + r * r + n * n;
        if (o > 0 && (e *= o = 1 / Math.sqrt(o), r *= o, n *= o), e *= t, r *= t, n *= t, !this._vectorRotation) {
            var d = this._cachedData;
            this.hasChanged = !0, d[3] = e - 1, d[4] = r - 1, d[5] = n - 1
        }
        return (Math.abs(e - a[3]) > i || Math.abs(r - a[4]) > i || Math.abs(n - a[5]) > i) && (this.hasChanged = !0), a[3] = e, a[4] = r, a[5] = n, this._vectorRotation = !0, this
    }, pd3D.Transform.prototype.setRotation = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or a [rx,ry,rz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        if (this._vectorRotation) {
            var s = this._cachedData;
            this.hasChanged = !0, s[3] = t - 1, s[4] = e - 1, s[5] = r - 1
        }
        return (Math.abs(t - i[3]) > n || Math.abs(e - i[4]) > n || Math.abs(r - i[5]) > n) && (this.hasChanged = !0), i[3] = t, i[4] = e, i[5] = r, this._vectorRotation = !1, this
    }, pd3D.Transform.prototype.addRotation = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (this._vectorRotation) throw new Error("Cannot acumulate vector rotations, use `setRotation()` to reset to axial mode.");
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or a [rx,ry,rz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        return (Math.abs(t) > n || Math.abs(e) > n || Math.abs(r) > n) && (this.hasChanged = !0), i[3] += t, i[4] += e, i[5] += r, this
    }, pd3D.Transform.prototype.setScale = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or a [sx,sy,sz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        return (Math.abs(t - i[6]) > n || Math.abs(e - i[7]) > n || Math.abs(r - i[8]) > n) && (this.hasChanged = !0), i[6] = t, i[7] = e, i[8] = r, this
    }, pd3D.Transform.prototype.addScale = function (t, e, r) {
        var n = pd.Const.EPSILON, i = this._xformData;
        if (1 == arguments.length) {
            var a = t;
            if (!Array.isArray(a)) throw new TypeError("Parameters must be either three numeric values or a [sx,sy,sz] vector array.");
            t = +a[0] || 0, e = +a[1] || 0, r = +a[2] || 0
        }
        return (Math.abs(t - 1) > n || Math.abs(e - 1) > n || Math.abs(r - 1) > n) && (this.hasChanged = !0), i[6] *= t, i[7] *= e, i[8] *= r, this
    }, pd3D.Transform.prototype.checkForChanges = function () {
        var t, e = !1, r = this._xformData, n = this._cachedData, i = pd.Const.EPSILON;
        if ((Math.abs(n[0] - r[0]) > i || Math.abs(n[1] - r[1]) > i || Math.abs(n[2] - r[2]) > i) && (t = this._cachedTranslation, Math.abs(r[0]) > i || Math.abs(r[1]) > i || Math.abs(r[2]) > i ? (pd3D.Matrix.translate(r[0], r[1], r[2], t), t.isIdentity = !1) : (pd3D.Matrix.identity(t), t.isIdentity = !0), n[0] = r[0], n[1] = r[1], n[2] = r[2], e = !0), Math.abs(n[3] - r[3]) > i || Math.abs(n[4] - r[4]) > i || Math.abs(n[5] - r[5]) > i) {
            var a = !0;
            if (t = this._cachedRotation, this._vectorRotation) {
                var s = this._vectorAngles;
                s && Math.abs(s[0]) > i ? (pd3D.Matrix.rotate(s[0], s[1], s[2], s[3], t), a = !1) : (pd3D.Matrix.identity(t), a = !0)
            } else Math.abs(r[5]) > i && (pd3D.Matrix.rotate(r[5], 0, 0, 1, t), a = !1), Math.abs(r[3]) > i && (a ? pd3D.Matrix.rotate(r[3], 1, 0, 0, t) : pd3D.Matrix.multiply(t, pd3D.Matrix.rotate(r[3], 1, 0, 0), t), a = !1), Math.abs(r[4]) > i && (a ? pd3D.Matrix.rotate(r[4], 0, 1, 0, t) : pd3D.Matrix.multiply(t, pd3D.Matrix.rotate(r[5], 0, 1, 0), t), a = !1);
            t.isIdentity = a, n[3] = r[3], n[4] = r[4], n[5] = r[5], e = !0
        }
        return (Math.abs(n[6] - r[6]) > i || Math.abs(n[7] - r[7]) > i || Math.abs(n[8] - r[8]) > i) && (t = this._cachedScale, Math.abs(r[0] - 1) > i || Math.abs(r[1] - 1) > i || Math.abs(r[2] - 1) > i ? (pd3D.Matrix.scale(r[6], r[7], r[8], t), t.isIdentity = !1) : (pd3D.Matrix.identity(t), t.isIdentity = !0), n[6] = r[6], n[7] = r[7], n[8] = r[8], e = !0), e && (this.isIdentity = !0, (t = this._cachedTranslation).isIdentity || (pd3D.Matrix.clone(t, this._cachedMatrix), this.isIdentity = !1), (t = this._cachedRotation).isIdentity || (this.isIdentity ? pd3D.Matrix.clone(t, this._cachedMatrix) : pd3D.Matrix.multiply(this._cachedMatrix, t, this._cachedMatrix), this.isIdentity = !1), (t = this._cachedScale).isIdentity || (this.isIdentity ? pd3D.Matrix.clone(t, this._cachedMatrix) : pd3D.Matrix.multiply(this._cachedMatrix, t, this._cachedMatrix), this.isIdentity = !1), this.isIdentity && pd3D.Matrix.identity(this._cachedMatrix), this.isIdentity = a), this.hasChanged = !1, this
    }, pd3D.Transform.prototype.multiplyBy = function (t, e) {
        return e = e || new pd3D.Matrix, this.isIdentity || (t ? e = pd3D.Matrix.multiply(t, this, e) : pd3D.Matrix.clone(this, e)), e
    }, pd3D.Transform.prototype.copyTo = function (t) {
        return t = t || new pd3D.Matrix, pd3D.Matrix.clone(this, t), t
    }, pd3D.Indexer = function (t, e) {
        this.unique = Array.isArray(t) ? t : [], this.map = {}, this.decimals = pd.toInteger(e, 3), this.indexId = 0
    }, pd3D.Indexer.prototype.addObject = function (t) {
        var e, r = JSON.stringify(t);
        return r in this.map ? e = this.map[r] : (e = this.map[r] = this.unique.length, this.unique.push(t)), e
    }, pd3D.Indexer.prototype.addById = function (t) {
        var e, r;
        return t._indexId || (t._indexId = ++this.indexId), r = t._indexId, r in this.map ? e = this.map[r] : (e = this.map[r] = this.unique.length, this.unique.push(t)), e
    }, pd3D.Indexer.prototype.addVectorArray = function (t) {
        var e, r = this.decimals, n = "[" + t[0].toFixed(r) + "," + t[1].toFixed(r) + "," + t[2].toFixed(r) + "]";
        return n in this.map ? e = this.map[n] : (e = this.map[n] = this.unique.length, this.unique.push(t)), e
    }, pd3D.IndexCounter = function (t) {
        this.unique = Array.isArray(t) ? t : [], this.counter = [], this.map = {}
    }, pd3D.IndexCounter.prototype.count = function (t) {
        var e = JSON.stringify(t);
        e in this.map || (this.map[e] = this.unique.length, this.unique.push(t), this.counter.push(0));
        var r = this.map[e];
        return this.counter[r]++, this.map[e]
    }, pd3D.Material = function (t) {
        t = t || {}, this.id = pd3D.getUniqueID(), this.name = t.name || "Mtrl_" + pd.toStringWithLeadingZeros(this.id, 4)
    }, pd3D.Node = function (t, e) {
        this.id = pd3D.getUniqueID(), this.nodeType = e || "Node", this.name = t || this.nodeType + "_" + pd.toStringWithLeadingZeros(this.id, 4), this.transformMatrix = null, this.inverseMatrix = null, this.visible = !0, this.active = !0, this.geometry = {}, this.children = [], this.hasChanged = !1, this.callbackOnDraw = null
    }, pd3D.Node.prototype.hide = function () {
        return this.visible = !1, this
    }, pd3D.Node.prototype.show = function (t) {
        return t = !1 !== t, this.visible = t, this
    }, pd3D.Node.prototype.getTransform = function () {
        return this.transformMatrix
    }, pd3D.Node.prototype.setTransform = function (t) {
        return this.transformMatrix = t, this.transformMatrix ? this.inverseMatrix = pd3D.Matrix.inverse(this.transformMatrix, this.inverseMatrix) : this.inverseMatrix = null, this
    }, pd3D.Node.prototype.addChild = function (t) {
        if (!t) throw new TypeError("ERROR: Undefined object not added as child node.");
        if (!(t instanceof pd3D.Node)) {
            if (!(t.draw || t.drawSurfaces && t.drawOutlines)) throw new TypeError("ERROR: Unsupported object not added as child node.");
            t.id || (t.id = pd3D.getUniqueID()), t.name || (t.name = "Object_" + pd.toStringWithLeadingZeros(t.id, 4))
        }
        return this.children.push(t), this.hasChanged = !0, this
    }, pd3D.Node.prototype.getChildByIndex = function (t) {
        return t >= 0 && t < this.children.length ? this.children[t] : null
    }, pd3D.Node.prototype.findChildrenById = function (t, e) {
        var r = e || [];
        if (pd.isNumeric(t)) {
            this.id == t && r.push(this);
            for (var n, i = 0, a = this.children.length; i < a; i++) null != (n = this.children[i]) && (n.id == t ? r.push(n) : n.findChildrenById && n.findChildrenById(t, r))
        }
        return r
    }, pd3D.Node.prototype.findChildrenByName = function (t, e) {
        var r = e || [];
        if (t && t.length) {
            this.name == t && r.push(this);
            for (var n, i = 0, a = this.children.length; i < a; i++) null != (n = this.children[i]) && (n.name == t ? r.push(n) : n.findChildrenByName && n.findChildrenByName(id, r))
        }
        return r
    }, pd3D.Node.prototype.removeChildByIndex = function (t) {
        return t >= 0 && t < this.children.length && (this.children.splice(t, 1), this.hasChanged = !0), this
    }, pd3D.Node.prototype.removeChild = function (t, e) {
        if (t) {
            var r = this.children.indexOf(t);
            if (r > -1) return this.children.splice(r, 1), this.hasChanged = !0, this;
            if (e) for (var n = 0, i = this.children.length; n < i; n++) this.children[n] && this.children[n].removeChild && this.children[n].removeChild(t)
        }
        return this
    }, pd3D.Node.prototype.clearChildren = function () {
        for (var t, e = 0, r = this.children.length; e < r; e++) (t = this.children[e]) && t.clear && t.clear();
        return this.children.length = 0, this.hasChanged = !0, this
    }, pd3D.Node.prototype.addMesh = function (t, e) {
        if (!(t && t instanceof pd3D.Mesh)) throw new TypeError("ERROR: Only valid pd3D.Mesh objects can be added as pd3D.Node geometry.");
        if (!(e && e instanceof pd3D.Material)) throw new TypeError("ERROR: Only valid pd3D.Material objects can be assigned to pd3D.Node geometry.");
        var r = e.id.toString();
        return this.geometry[r] || (this.geometry[r] = {
            material: e,
            meshes: []
        }), this.geometry[r].meshes.push(t), this.hasChanged = !0, this
    }, pd3D.Node.prototype.addMeshes = function (t, e) {
        if (!t || !Array.isArray(t)) throw new TypeError("ERROR: Only valid arrays of pd3D.Mesh objects can be added as pd3D.Node geometry.");
        if (!(e && e instanceof pd3D.Material)) throw new TypeError("ERROR: Only valid pd3D.Material objects can be assigned to pd3D.Node geometry.");
        var r = e.id.toString();
        this.geometry[r] || (this.geometry[r] = {material: e, meshes: []});
        for (var n = 0, i = t.length; n < i; ++n) {
            var a = t[n];
            a && a instanceof pd3D.Mesh && (this.geometry[r].meshes.push(a), this.hasChanged = !0)
        }
        return this
    }, pd3D.Node.prototype.findMeshById = function (t) {
        for (var e in this.geometry) if (this.geometry.hasOwnProperty(e)) for (var r = this.geometry[e].meshes, n = 0, i = r.length; n < i; n++) if (r[n].id == t) return r[n];
        for (var a, s = null, n = 0, i = this.children.length; n < i; n++) if ((a = this.children[n]) && a.findMeshById && null != (s = a.findMeshById(t))) return s;
        return null
    }, pd3D.Node.prototype.getMeshesByMaterial = function (t) {
        if (!t || !t.id) throw new TypeError("ERROR: Only valid pd3D.Material objects can be used to obtain meshes.");
        var e = t.id.toString();
        return this.geometry[e] ? this.geometry[e].meshes : []
    }, pd3D.Node.prototype.swapMaterials = function (t, e) {
        if (!(t && t.id && e && e.id)) throw new TypeError("ERROR: Both arguments must be valid pd3D.Material objects.");
        if (t.id != e.id) {
            var r = t.id.toString(), n = e.id.toString();
            if (this.geometry[r]) {
                var i = this.geometry[r].meshes;
                this.geometry[n] ? Array.prototype.push.apply(this.geometry[n].meshes, i) : this.geometry[n] = {
                    material: e,
                    meshes: i
                }, delete this.geometry[r]
            }
            for (var a = 0, s = this.children.length; a < s; a++) this.children[a].swapMaterials && this.children[a].swapMaterials(t, e)
        }
        return this
    }, pd3D.Node.prototype.clearGeometry = function () {
        for (var t in this.geometry) if (this.geometry.hasOwnProperty(t)) for (var e = this.geometry[t].meshes, r = 0, n = e.length; r < n; ++r) e[r].clear();
        return this.geometry = {}, this.hasChanged = !0, this
    }, pd3D.Node.prototype.reverseNormals = function () {
        for (var t in this.geometry) if (this.geometry.hasOwnProperty(t)) for (var e = this.geometry[t].meshes, r = 0, n = e.length; r < n; ++r) e[r].reverseNormals();
        for (var i, r = 0, n = this.children.length; r < n; r++) (i = this.children[r]) && i.reverseNormals && i.reverseNormals();
        return this
    }, pd3D.Node.prototype.reverseTriangles = function () {
        for (var t in this.geometry) if (this.geometry.hasOwnProperty(t)) for (var e = this.geometry[t].meshes, r = 0, n = e.length; r < n; ++r) e[r].reverseTriangles();
        for (var i, r = 0, n = this.children.length; r < n; r++) (i = this.children[r]) && i.reverseTriangles && i.reverseTriangles();
        return this
    }, pd3D.Node.prototype.swapYZ = function () {
        for (var t in this.geometry) if (this.geometry.hasOwnProperty(t)) for (var e = this.geometry[t].meshes, r = 0, n = e.length; r < n; ++r) e[r].swapYZ();
        for (var i, r = 0, n = this.children.length; r < n; r++) (i = this.children[r]) && i.swapYZ && i.swapYZ();
        return this
    }, pd3D.Node.prototype.translate = function (t, e, r) {
        for (var n in this.geometry) if (this.geometry.hasOwnProperty(n)) for (var i = this.geometry[n].meshes, a = 0, s = i.length; a < s; ++a) i[a].translate(t, e, r);
        for (var o, a = 0, s = this.children.length; a < s; a++) (o = this.children[a]) && o.translate && o.translate(t, e, r);
        return this
    }, pd3D.Node.prototype.applyMatrix = function (t, e) {
        if (t) {
            var e = e || t.inverse().transpose();
            for (var r in this.geometry) if (this.geometry.hasOwnProperty(r)) for (var n = this.geometry[r].meshes, i = 0, a = n.length; i < a; ++i) n[i].transform(t, e);
            for (var s, i = 0, a = this.children.length; i < a; i++) (s = this.children[i]) && s.applyMatrix && s.applyMatrix(t, e)
        }
        return this
    }, pd3D.Node.prototype.getAABB = function (t, e) {
        t && t.min || ((t = {min: new pd3D.Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)}).max = t.min.negative());
        for (var r in this.geometry) if (this.geometry.hasOwnProperty(r)) for (var n = this.geometry[r].meshes, i = 0, a = n.length; i < a; i++) e && n[i].computeBoundingBox(), n[i].getAABB(t);
        for (var s, i = 0, a = this.children.length; i < a; i++) (s = this.children[i]) && s.getAABB && s.getAABB(t, e);
        return t
    }, pd3D.Node.prototype.compileGeometry = function () {
        var t = [];
        for (var e in this.geometry) if (this.geometry.hasOwnProperty(e)) {
            for (var r, n = this.geometry[e].meshes, i = 0, a = n.length; i < a; ++i) (r = n[i]) && r.hasContent() && r.compile();
            this.geometry[e].meshes.length < 1 && t.push(e)
        }
        if (t.length > 0) for (var i = 0, a = t.length; i < a; i++) delete this.geometry[t[i]];
        return this
    }, pd3D.Node.prototype.compile = function () {
        for (var t, e = 0, r = this.children.length; e < r; e++) (t = this.children[e]) && t.compile && t.compile();
        return this.compileGeometry()
    }, pd3D.Node.prototype.intersectRay = function (t, e, r) {
        r = r || null;
        for (var n in this.geometry) if (this.geometry.hasOwnProperty(n)) for (var i = this.geometry[n].meshes, a = 0, s = i.length; a < s; ++a) r = pd3D.RayTrace.intersectMesh(t, e, i[a], r);
        for (var o, a = 0, s = this.children.length; a < s; a++) (o = this.children[a]) && o.intersectRay && (r = o.intersectRay(t, e, r));
        return r
    }, pd3D.Node.prototype.obstructedRay = function (t, e) {
        for (var r in this.geometry) if (this.geometry.hasOwnProperty(r)) for (var n = this.geometry[r].meshes, i = 0, a = n.length; i < a; ++i) if (pd3D.RayTrace.getFirstHitOnMesh(t, e, n[i])) return !0;
        for (var s, i = 0, a = this.children.length; i < a; i++) if ((s = this.children[i]) && s.obstructedRay && s.obstructedRay(t, e)) return !0;
        return !1
    }, pd3D.Node.prototype.clear = function () {
        return this.clearChildren(), this.clearGeometry(), this.transformMatrix = null, delete this.transformMatrix, this.inverseMatrix = null, delete this.inverseMatrix, this.hasChanged = !0, this
    }, pd3D.RayTrace = function (t, e, r, n) {
        this.t = arguments.length > 0 ? t : Number.MAX_VALUE, this.mesh = n || null, this.normal = r, this.hit = e
    }, pd3D.RayTrace.prototype.mergeWith = function (t) {
        t.t > 0 && t.t < this.t && (this.t = t.t, t.mesh ? this.mesh = t.mesh : this.mesh && (this.mesh = null), this.normal = t.normal, this.hit = t.hit)
    }, pd3D.RayTrace.insideBox = function (t, e, r) {
        return t.x >= e.x && t.x <= r.x && t.y >= e.y && t.y <= r.y && t.z >= e.z && t.z <= r.z
    }, pd3D.RayTrace.intersectBox = function (t, e, r, n) {
        var i = r.subtract(t).divide(e), a = n.subtract(t).divide(e), s = pd3D.Vector.min(i, a),
            o = pd3D.Vector.max(i, a), d = s.max(), h = o.min();
        if (d > 0 && d < h) {
            var u = t.add(e.multiply(d));
            return r = r.add(1e-6), n = n.subtract(1e-6), new pd3D.RayTrace(d, u, new pd3D.Vector((u.x > n.x) - (u.x < r.x), (u.y > n.y) - (u.y < r.y), (u.z > n.z) - (u.z < r.z)))
        }
        return null
    }, pd3D.RayTrace.intersectSphere = function (t, e, r, n) {
        var i = t.subtract(r), a = e.dot(e), s = 2 * e.dot(i), o = s * s - 4 * a * (i.dot(i) - n * n);
        if (o > 0) {
            var d = (-s - Math.sqrt(o)) / (2 * a), h = t.add(e.multiply(d));
            return new pd3D.RayTrace(d, h, h.subtract(r).divide(n))
        }
        return null
    }, pd3D.RayTrace.intersectTriangle = function (t, e, r, n, i) {
        var a = n.subtract(r), s = i.subtract(r), o = a.cross(s).unit(), d = o.dot(r.subtract(t)) / o.dot(e);
        if (d > 0) {
            var h = t.add(e.multiply(d)), u = h.subtract(r), c = s.dot(s), l = s.dot(a), p = s.dot(u), f = a.dot(a),
                m = a.dot(u), g = c * f - l * l, v = (f * p - l * m) / g, y = (c * m - l * p) / g;
            if (v >= 0 && y >= 0 && v + y <= 1) return new pd3D.RayTrace(d, h, o)
        }
        return null
    }, pd3D.RayTrace.intersectMesh = function (t, e, r, n) {
        var i = null;
        if (n = n || null, !r.boundingBox || pd3D.RayTrace.insideBox(t, r.boundingBox.min, r.boundingBox.max) || pd3D.RayTrace.intersectBox(t, e, r.boundingBox.min, r.boundingBox.max)) for (var a, s = r.vertices, o = r.triangles.length, d = r.triangles, h = new pd3D.Vector, u = new pd3D.Vector, c = new pd3D.Vector, l = 0; l < o; ++l) a = d[l], pd3D.Vector.fromArray(s[a[0]], h), pd3D.Vector.fromArray(s[a[1]], u), pd3D.Vector.fromArray(s[a[2]], c), null != (i = pd3D.RayTrace.intersectTriangle(t, e, h, u, c)) && (n ? (i.mesh = r, n.mergeWith(i)) : n = new pd3D.RayTrace(i.t, i.hit, i.normal, r));
        return n
    }, pd3D.RayTrace.getFirstHitOnMesh = function (t, e, r) {
        if (!r.boundingBox || pd3D.RayTrace.insideBox(t, r.boundingBox.min, r.boundingBox.max) || pd3D.RayTrace.intersectBox(t, e, r.boundingBox.min, r.boundingBox.max)) for (var n, i, a = r.vertices, s = r.triangles.length, o = r.triangles, d = new pd3D.Vector, h = new pd3D.Vector, u = new pd3D.Vector, c = 0; c < s; ++c) if (i = o[c], pd3D.Vector.fromArray(a[i[0]], d), pd3D.Vector.fromArray(a[i[1]], h), pd3D.Vector.fromArray(a[i[2]], u), null != (n = pd3D.RayTrace.intersectTriangle(t, e, d, h, u))) return new pd3D.RayTrace(n.t, n.hit, n.normal, r);
        return null
    }
}(), pd3D.Shapes = pd3D.Shapes || {}, function () {
    function t(t) {
        return new pd3D.Vector(2 * (1 & t) - 1, (2 & t) - 1, (4 & t) / 2 - 1)
    }

    var e = .5 * Math.PI, r = 2 * Math.PI;
    pd3D.Shapes.plane = function (t, e) {
        var r = !1, n = (t = t || {}).detailX || t.detail || 1, i = t.detailY || t.detail || 1, a = {};
        e || (e = new pd3D.Mesh(t), r = !0);
        for (var s = 0; s <= i; s++) for (var o = s / i, d = 0; d <= n; d++) {
            var h = d / n;
            if (a.pos = [2 * h - 1, 2 * o - 1, 0], e.coords && (a.coord = [h, o]), e.addVertexData(a), d < n && s < i) {
                var u = d + s * (n + 1);
                e.addTriangle(u, u + 1, u + n + 1), e.addTriangle(u + n + 1, u + 1, u + n + 2)
            }
        }
        return r && e.compile(), e
    };
    var n = [[0, 4, 2, 6, -1, 0, 0], [1, 3, 5, 7, 1, 0, 0], [0, 1, 4, 5, 0, -1, 0], [2, 6, 3, 7, 0, 1, 0], [0, 2, 1, 3, 0, 0, -1], [4, 5, 6, 7, 0, 0, 1]];
    pd3D.Shapes.cube = function (e, r) {
        e = e || {};
        var i = !1, a = [1, 1, 1], s = {};
        Array.isArray(e.size) ? (a[0] = .5 * pd.toNumber(e.size[0], 1), a[1] = .5 * pd.toNumber(e.size[1], 1), a[2] = .5 * pd.toNumber(e.size[2], 1)) : (a[0] = .5 * pd.toNumber(e.size, 1), a[1] = a[2] = a[0]), r || (r = new pd3D.Mesh(e), i = !0);
        for (var o = r.vertexCount(), d = 0; d < n.length; d++) {
            for (var h = 4 * d, u = Math.floor(.5 * d), c = n[d], l = 0; l < 4; l++) {
                var p = c[l];
                s.pos = t(p).scale(a[u]).toArray(), r.coords && (s.coord = [1 & l, (2 & l) / 2]), r.normals && (s.normal = c.slice(4, 7)), r.addVertexData(s)
            }
            if (e.triangles) if (e.invert) {
                if (r.addTriangle(h + 2, h + 1, h), r.addTriangle(h + 3, h + 1, h + 2), r.normals) for (var f = 0; f < 4; f++) {
                    var m = r.normals[h + f];
                    m[0] = -m[0], m[1] = -m[1], m[2] = -m[2]
                }
            } else r.addTriangle(h, h + 1, h + 2), r.addTriangle(h + 2, h + 1, h + 3)
        }
        if (r.lines && (r.addLine(0, 1), r.addLine(1, 3), r.addLine(3, 2), r.addLine(2, 0), r.addLine(4, 5), r.addLine(5, 7), r.addLine(7, 6), r.addLine(6, 4), r.addLine(0, 4), r.addLine(1, 6), r.addLine(3, 7), r.addLine(2, 5)), Array.isArray(e.center) && r.vertices) {
            var g = e.center;
            g[0] = pd.toNumber(g[0], 0), g[1] = pd.toNumber(g[1], 0), g[2] = pd.toNumber(g[2], 0);
            for (var v = o, y = r.vertexCount(); v < y; ++v) {
                var M = r.vertices[v];
                M[0] += g[0], M[1] += g[1], M[2] += g[2]
            }
        }
        return i && r.compile(), r
    }, pd3D.Shapes.rectangle = function (t, n) {
        function i(t) {
            return [(t[0] - O[0]) / g, (t[1] - O[2]) / v]
        }

        function a(t, e) {
            return _.pos = [t, e, D[2]], f && f.applyPointTransformToArray(_.pos), n.coords && (_.coord = i(_.pos)), n.addVertexData(_)
        }

        function s(t, e, r, n) {
            r -= .5 * C;
            for (var i = e + C; i < r; i += C) a(t[0] + n * Math.cos(i), t[1] + n * Math.sin(i))
        }

        function o(t) {
            a(t.vertices[0][0], t.vertices[0][1]), T = a(t.vertices[1][0], t.vertices[1][1]), a(t.vertices[2][0], t.vertices[2][1])
        }

        var d, h, u, c, l, p = !1, f = (t = t || {}).transform || null, m = pd.toNumber(t.scale, 1),
            g = .5 * pd.toNumber(t.width, 250), v = .5 * pd.toNumber(t.height, 100),
            y = pd.toNumber(t.borderWidth, 0) * m, M = pd.toBoolean(t.background, !0), x = pd.toBoolean(t.border, !1),
            b = [0, 0, 0, 0], D = [0, 0, 0], T = -1, w = {edge1: -1, edge2: -1}, O = t.min || [0, 0, 0],
            A = t.max || [O[0] + g, O[1] + v, O[2]], C = r / Math.max(4, 4 * pd.toNumber(t.segments, 6)), _ = {pos: []},
            S = 0, I = 0;
        if (g = .5 * (A[0] - O[0]), v = .5 * (A[1] - O[1]), t.cornerRadius) {
            if (Array.isArray(t.cornerRadius)) {
                var k = t.cornerRadius;
                b[0] = pd.toNumber(k[0] || 0) * m, b[1] = pd.toNumber(k[1] || 0) * m, b[2] = pd.toNumber(k[2] || 0) * m, b[3] = pd.toNumber(k[3] || 0) * m
            } else h = pd.toNumber(t.cornerRadius, 0) * m, b[0] = h, b[1] = h, b[2] = h, b[3] = h;
            var N = Math.min(g, v);
            b[0] = pd.sign(b[0]) * Math.min(N, Math.abs(b[0])), b[1] = pd.sign(b[0]) * Math.min(N, Math.abs(b[1])), b[2] = pd.sign(b[0]) * Math.min(N, Math.abs(b[2])), b[3] = pd.sign(b[0]) * Math.min(N, Math.abs(b[3]))
        }
        if (t.center && Array.isArray(t.center) ? (D[0] = pd.toNumber(t.center[0], 0), D[1] = pd.toNumber(t.center[1], 0), D[2] = pd.toNumber(t.center[2], 0), O[0] = D[0] - g, A[0] = D[0] + g, O[1] = D[1] - g, A[1] = D[1] + g, O[2] = A[2] = +D[2] || 0) : (O[2] = +O[2] || 0, A[2] = +A[2] || 0, D[0] = .5 * (O[0] + A[0]), D[1] = .5 * (O[1] + A[1]), D[2] = .5 * (O[2] + A[2])), n || (n = new pd3D.Mesh(t), p = !0), M = M && n.triangles, x = x && n.lines, n.normals) {
            var V = [0, 0, 1];
            f && f.applyVectorTransformToArray(V), n.normal(V)
        }
        if (!M && (!x || y < .001)) return void(p && n.compile());
        if (M ? Array.isArray(t.backgroundColor) && n.color(t.backgroundColor) : x && Array.isArray(t.borderColor) && n.color(t.borderColor), t.notch) {
            if (w.length = pd.toNumber(t.notchLength, 15), w.width = .5 * pd.toNumber(t.notchWidth, Math.abs(w.length)), w.position = pd.toNumber(t.notchPosition, .5), w.edge = pd.toInteger(t.notchEdge, -1), w.type = pd.toInteger(t.notchType, 0), w.vertices = [], w.length *= m, w.width *= m, Array.isArray(t.notchTarget)) w.x = +t.notchTarget[0] || 0, w.y = +t.notchTarget[1] || 0; else if (w.edge >= 0) switch (w.edge) {
                case pd.Align.BOTTOM:
                    w.x = pd.mapTo(w.position, 0, 1, O[0], A[0]), w.y = O[1] - w.length;
                    break;
                case pd.Align.RIGHT:
                    w.x = A[0] + w.length, w.y = pd.mapTo(w.position, 0, 1, O[1], A[1]);
                    break;
                case pd.Align.TOP:
                    w.x = pd.mapTo(w.position, 0, 1, O[0], A[0]), w.y = A[1] + w.length;
                    break;
                case pd.Align.LEFT:
                    w.x = O[0] - w.length, w.y = pd.mapTo(w.position, 0, 1, O[1], A[1]);
                    break;
                default:
                    w.x = D[0], w.y = D[1]
            }
            (w.x < O[0] || w.x > A[0] || w.y < O[1] || w.y > A[1]) && (w.type ? w.x < D[0] ? w.y < D[1] ? (u = w.x + pd.safeDivide(O[1] - w.y, D[1] - w.y) * (D[0] - w.x), (c = w.y + pd.safeDivide(O[0] - w.x, D[0] - w.x) * (D[1] - w.y)) + w.width >= O[1] ? (w.edge1 = 3, w.vertices[0] = [O[0], Math.max(c + w.width, O[1])], w.vertices[0][1] < O[1] + Math.abs(b[0]) && (b[0] = 0)) : (w.edge1 = 0, w.vertices[0] = [Math.max(u - w.width, O[0]), O[1]], w.vertices[0][0] < O[0] + Math.abs(b[0]) && (b[0] = 0)), w.vertices[1] = [w.x, w.y], u + w.width >= O[0] ? (w.edge2 = 0, w.vertices[2] = [Math.max(u + w.width, O[0]), O[1]], w.vertices[2][0] < O[0] + Math.abs(b[0]) && (b[0] = 0)) : (w.edge2 = 3, w.vertices[2] = [O[0], Math.max(c - w.width, O[1])], w.vertices[2][1] < O[1] + Math.abs(b[0]) && (b[0] = 0))) : (u = w.x - pd.safeDivide(w.y - A[1], D[1] - w.y) * (D[0] - w.x), c = w.y + pd.safeDivide(O[0] - w.x, D[0] - w.x) * (D[1] - w.y), u + w.width >= O[0] ? (w.edge1 = 2, w.vertices[0] = [Math.max(u + w.width, O[0]), A[1]], w.vertices[0][0] < O[0] + Math.abs(b[3]) && (b[3] = 0)) : (w.edge1 = 3, w.vertices[0] = [O[0], Math.min(c + w.width, A[1])], w.vertices[0][1] > A[1] - Math.abs(b[3]) && (b[3] = 0)), w.vertices[1] = [w.x, w.y], c - w.width <= A[1] ? (w.edge2 = 3, w.vertices[2] = [O[0], Math.min(c - w.width, A[1])], w.vertices[2][1] > A[1] - Math.abs(b[3]) && (b[3] = 0)) : (w.edge2 = 2, w.vertices[2] = [Math.max(u - w.width, O[0]), A[1]], w.vertices[2][0] < O[0] + Math.abs(b[3]) && (b[3] = 0))) : w.y < D[1] ? (u = w.x + pd.safeDivide(O[1] - w.y, D[1] - w.y) * (D[0] - w.x), c = w.y + pd.safeDivide(A[0] - w.x, D[0] - w.x) * (D[1] - w.y), u - w.width <= A[0] ? (w.edge1 = 0, w.vertices[0] = [Math.min(u - w.width, A[0]), O[1]], w.vertices[0][0] > A[0] - Math.abs(b[1]) && (b[1] = 0)) : (w.edge1 = 1, w.vertices[0] = [A[0], Math.max(c - w.width, O[1])], w.vertices[0][1] < O[1] + Math.abs(b[1]) && (b[1] = 0)), w.vertices[1] = [w.x, w.y], c + w.width > O[1] ? (w.edge2 = 1, w.vertices[2] = [A[0], Math.max(c + w.width, O[1])], w.vertices[2][1] < O[1] + Math.abs(b[1]) && (b[1] = 0)) : (w.edge2 = 0, w.vertices[2] = [Math.min(u + w.width, A[0]), O[1]], w.vertices[2][0] > A[0] - Math.abs(b[1]) && (b[1] = 0))) : (u = w.x + pd.safeDivide(A[1] - w.y, D[1] - w.y) * (D[0] - w.x), c = w.y + pd.safeDivide(A[0] - w.x, D[0] - w.x) * (D[1] - w.y), u + w.width <= A[0] ? (w.edge1 = 2, w.vertices[0] = [Math.min(u + w.width, A[0]), A[1]], w.vertices[0][0] > A[0] - Math.abs(b[2]) && (b[2] = 0)) : (w.edge1 = 1, w.vertices[0] = [A[0], Math.min(c - w.width, A[1])], w.vertices[0][1] > A[1] - Math.abs(b[2]) && (b[2] = 0)), w.vertices[1] = [w.x, w.y], c + w.width <= A[1] ? (w.edge2 = 1, w.vertices[2] = [A[0], Math.min(c + w.width, A[1])], w.vertices[2][1] > A[1] - Math.abs(b[2]) && (b[2] = 0)) : (w.edge2 = 2, w.vertices[2] = [Math.min(u - w.width, A[0]), A[1]], w.vertices[2][0] > A[0] - Math.abs(b[2]) && (b[2] = 0))) : w.x < D[0] ? w.y < D[1] ? (w.x >= O[0] ? (w.edge1 = w.edge2 = 0, w.vertices[0] = [pd.constrainTo(w.x - w.width, O[0], A[0]), O[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(w.x + w.width, O[0] + 2 * w.width, A[0]), O[1]]) : w.y >= O[1] ? (w.edge1 = w.edge2 = 3, w.vertices[0] = [O[0], pd.constrainTo(w.y + w.width, O[1] + 2 * w.width, A[1])], w.vertices[1] = [w.x, w.y], w.vertices[2] = [O[0], pd.constrainTo(w.y - w.width, O[1], A[1])]) : (w.edge1 = 3, w.edge2 = 0, u = O[0] - w.x, c = O[1] - w.y, l = Math.sqrt(u * u + c * c), u = pd.safeDivide(u, l), c = pd.safeDivide(c, l), w.vertices[0] = [O[0], pd.constrainTo(O[1] + 2 * u * w.width, O[1], A[1])], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(O[0] + c * w.width, O[0], A[0]), O[1]]), d = Math.abs(b[0]), (w.vertices[0][0] < O[0] + d && w.vertices[0][1] < O[1] + d || w.vertices[2][0] < O[0] + d && w.vertices[2][1] < O[1] + d) && (b[0] = 0)) : (w.x >= O[0] ? (w.edge1 = w.edge2 = 2, w.vertices[0] = [pd.constrainTo(w.x + w.width, O[0] + 2 * w.width, A[0]), A[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(w.x - w.width, O[0], A[0]), A[1]]) : w.y <= A[1] ? (w.edge1 = w.edge2 = 3, w.vertices[0] = [O[0], pd.constrainTo(w.y + w.width, O[1], A[1])], w.vertices[1] = [w.x, w.y], w.vertices[2] = [O[0], pd.constrainTo(w.y - w.width, O[1], A[1] - 2 * w.width)]) : (w.edge1 = 2, w.edge2 = 3, u = O[0] - w.x, c = w.y - A[1], l = Math.sqrt(u * u + c * c), u = pd.safeDivide(u, l), c = pd.safeDivide(c, l), w.vertices[0] = [pd.constrainTo(O[0] + 2 * c * w.width, O[0], A[0]), A[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [O[0], pd.constrainTo(A[1] - 2 * u * w.width, O[1], A[1])]), d = Math.abs(b[3]), (w.vertices[0][0] < O[0] + d && w.vertices[0][1] > A[1] - d || w.vertices[2][0] < O[0] + d && w.vertices[2][1] > A[1] - d) && (b[3] = 0)) : w.y < D[1] ? (w.x <= A[0] ? (w.edge1 = w.edge2 = 0, w.vertices[0] = [pd.constrainTo(w.x - w.width, O[0], A[0] - 2 * w.width), O[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(w.x + w.width, O[0], A[0]), O[1]]) : w.y >= O[1] ? (w.edge1 = w.edge2 = 1, w.vertices[0] = [A[0], pd.constrainTo(w.y - w.width, O[1], A[1])], w.vertices[1] = [w.x, w.y], w.vertices[2] = [A[0], pd.constrainTo(w.y + w.width, O[1] + 2 * w.width, A[1])]) : (w.edge1 = 0, w.edge2 = 1, u = w.x - A[0], c = O[1] - w.y, l = Math.sqrt(u * u + c * c), u = pd.safeDivide(u, l), c = pd.safeDivide(c, l), w.vertices[0] = [pd.constrainTo(A[0] - 2 * c * w.width, O[0], A[0]), O[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [A[0], pd.constrainTo(O[1] + 2 * u * w.width, O[1], A[1])]), d = Math.abs(b[1]), (w.vertices[0][0] > A[0] - d && w.vertices[0][1] < O[1] + d || w.vertices[2][0] > A[0] - d && w.vertices[2][1] < O[1] + d) && (b[1] = 0)) : (w.x <= A[0] ? (w.edge1 = w.edge2 = 2, w.vertices[0] = [pd.constrainTo(w.x + w.width, O[0], A[0]), A[1]], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(w.x - w.width, O[0], A[0] - 2 * w.width), A[1]]) : w.y <= A[1] ? (w.edge1 = w.edge2 = 1, w.vertices[0] = [A[0], pd.constrainTo(w.y - w.width, O[1], A[1] - 2 * w.width)], w.vertices[1] = [w.x, w.y], w.vertices[2] = [A[0], pd.constrainTo(w.y + w.width, O[1], A[1])]) : (w.edge1 = 1, w.edge2 = 2, u = w.x - A[0], c = w.y - A[1], l = Math.sqrt(u * u + c * c), u = pd.safeDivide(u, l), c = pd.safeDivide(c, l), w.vertices[0] = [A[0], pd.constrainTo(A[1] - 2 * u * w.width, O[1], A[1])], w.vertices[1] = [w.x, w.y], w.vertices[2] = [pd.constrainTo(A[0] - 2 * c * w.width, O[0], A[0]), A[1]]), d = Math.abs(b[2]), (w.vertices[0][0] > A[0] - d && w.vertices[0][1] > A[1] - d || w.vertices[2][0] > A[0] - d && w.vertices[2][1] > A[1] - d) && (b[2] = 0)))
        }
        if (S = a(D[0], D[1]), 3 == w.edge1 && 0 == w.edge2 ? o(w) : (h = b[0], (d = Math.abs(h)) > .4999 ? (a(O[0], O[1] + d), h > 0 && s([O[0] + d, O[1] + d], -Math.PI, -e, d), a(O[0] + d, O[1])) : a(O[0], O[1])), 0 == w.edge1 && 0 == w.edge2 && o(w), 0 == w.edge1 && 1 == w.edge2 ? o(w) : (h = b[1], (d = Math.abs(h)) > .4999 ? (a(A[0] - d, O[1]), h > 0 && s([A[0] - h, O[1] + d], -e, 0, h), a(A[0], O[1] + d)) : a(A[0], O[1])), 1 == w.edge1 && 1 == w.edge2 && o(w), 1 == w.edge1 && 2 == w.edge2 ? o(w) : (h = b[2], (d = Math.abs(h)) > .4999 ? (a(A[0], A[1] - d), h > 0 && s([A[0] - d, A[1] - d], 0, e, d), a(A[0] - d, A[1])) : a(A[0], A[1])), 2 == w.edge1 && 2 == w.edge2 && o(w), 2 == w.edge1 && 3 == w.edge2 ? o(w) : (h = b[3], (d = Math.abs(h)) > .4999 ? (a(O[0] + d, A[1]), h > 0 && s([O[0] + d, A[1] - d], e, Math.PI, d), a(O[0], A[1] - d)) : a(O[0], A[1])), 3 == w.edge1 && 3 == w.edge2 && o(w), I = n.vertexCount(), x && y > .001) if (n.hasVertexColors && Array.isArray(t.borderColor)) {
            var E, L = pd.toNumber(t.borderZOffset, 0) * m;
            n.color(t.borderColor);
            for (z = S + 1; z < I; ++z) E = n.getVertex(z), _.pos = [E[0], E[1], E[2] + L], n.coords && (_.coord = n.coords[z]), n.addVertexData(_);
            if (y > 1) {
                for (var R = [], P = n.vertexCount(), z = I; z < P; ++z) R.push(n.getVertex(z));
                pd3D.Shapes.thickLine({
                    vertices: R,
                    side: pd.toInteger(t.borderAlign, pd.Align.INSIDE),
                    shaft: y,
                    closed: !0
                }, n)
            } else {
                P = n.vertexCount();
                n.addLine(I, P - 1);
                for (z = I + 1; z < P; ++z) n.addLine(z - 1, z)
            }
        } else {
            n.addLine(S + 1, I - 1);
            for (z = S + 2; z < I; ++z) n.addLine(z - 1, z)
        }
        if (M) {
            n.addTriangle(S, I - 1, S + 1);
            for (z = S + 2; z < I; ++z) z == T ? (n.addTriangle(T - 1, T, T + 1), n.addTriangle(S, z - 1, z + 1), z++) : n.addTriangle(S, z - 1, z)
        }
        return p && n.compile(), t = null, n
    }, pd3D.Shapes.circle = function (t, e) {
        t = t || {};
        var n, i, a, s = !1, o = pd.toNumber(t.radius, 1), d = pd.toNumber(t.radiusInner, -1),
            h = r / pd.toNumber(t.segments, 24), u = t.center || [0, 0, 0], c = {pos: []}, l = null;
        if (e || (e = new pd3D.Mesh(t), s = !0), t.transform instanceof pd3D.Matrix && (l = t.transform), e.normals) {
            var p = [0, 0, 1];
            l && l.applyVectorTransformToArray(p), e.normal(p)
        }
        if (o > 0) if (d > 0) for (var f, m, g, v, y = 0; y < r; y += h) n = Math.sin(y), i = Math.cos(y), c.pos = [u[0] + d * n, u[1] + d * i, u[2]], e.coords && (c.coord = [n, i]), f = e.addVertexData(c), c.pos = [u[0] + o * n, u[1] + o * i, u[2]], g = e.addVertexData(c), y > 0 && (e.triangles && (e.addTriangle(g, v, m), e.addTriangle(f, g, m)), e.lines && (e.addLine(m, f), e.addLine(v, g))), m = f, v = g; else {
            c.pos = [u[0], u[1], u[2]], e.coords && (c.coord = [0, 0]);
            var M = e.addVertexData(c);
            c.pos = [u[0], u[1] + o, u[2]], e.coords && (c.coord = [0, 1]), e.addVertexData(c), a = M + 2;
            for (y = h; y < r; y += h) n = Math.sin(y), i = Math.cos(y), c.pos = [u[0] + o * n, u[1] + o * i, u[2]], e.coords && (c.coord = [n, i]), e.addVertexData(c), e.triangles && (e.addTriangle(M, a - 1, a), e.addTriangle(M, a, a - 1)), e.lines && e.addLine(a - 1, a), a++
        }
        return l && e.transform(l, null, vtx_start), s && e.compile(), e
    }, pd3D.Shapes.sphere = function (n, i) {
        function a(t, e, r) {
            return u ? [t, r, e] : [t, e, r]
        }

        function s(t) {
            return t + (t - t * t) / 2
        }

        var o = (n = n || {}).detail || 6, d = new pd3D.Indexer;
        i ? i.clear() : i = new pd3D.Mesh(n);
        for (var h = 0; h < 8; h++) for (var u = (b = t(h)).x * b.y * b.z > 0, c = [], l = 0; l <= o; l++) {
            for (M = 0; l + M <= o; M++) {
                var p = l / o, f = M / o, m = (o - l - M) / o, g = new pd3D.Vector(s(p), s(f), s(m)).unit().multiply(b),
                    v = {vertex: g.toArray()};
                if (i.coords) {
                    var y = g.toAngles();
                    v.coord = [(y.theta + Math.PI) / r, (y.phi + e) / Math.PI]
                }
                c.push(d.addObject(v))
            }
            if (l > 0) for (var M = 0; l + M <= o; M++) {
                var p = (l - 1) * (o + 1) + (l - 1 - (l - 1) * (l - 1)) / 2 + M, f = l * (o + 1) + (l - l * l) / 2 + M;
                i.triangles.push(a(c[p], c[p + 1], c[f])), l + M < o && i.triangles.push(a(c[f], c[p + 1], c[f + 1]))
            }
        }
        if (i.vertices = d.unique.map(function (t) {
                return t.vertex
            }), i.coords && (i.coords = d.unique.map(function (t) {
                return t.coord
            })), i.normals && (i.normals = i.vertices.map(function (t) {
                return [t[0], t[1], t[2]]
            })), n.radius || n.center) {
            var x = n.center || [0, 0, 0], b = n.scale || (n.radius ? [n.radius, n.radius, n.radius] : [1, 1, 1]);
            i.vertices = i.vertices.map(function (t) {
                return [x[0] + t[0] * b[0], x[1] + t[1] * b[1], x[2] + t[2] * b[2]]
            })
        }
        return i.compile(), i
    }, pd3D.Shapes.sphereLatLng = function (t, n) {
        t = t || {};
        var i, a, s, o, d, h, u, c, l = pd.Const.DEG2RAD,
            p = t.latIncrement ? pd.constrainTo(t.latIncrement, 1, 45) * l : t.increment ? pd.constrainTo(t.increment, 1, 45) * l : 5 * l,
            f = t.lngIncrement ? pd.constrainTo(t.lngIncrement, 1, 45) * l : t.increment ? pd.constrainTo(t.increment, 1, 45) * l : 5 * l,
            m = t.scale || (t.radius ? [t.radius, t.radius, t.radius] : [1, 1, 1]), g = t.center || [0, 0, 0],
            v = Math.ceil(Math.PI / p), y = Math.ceil(r / f), M = 0;
        n ? n.clear() : n = new pd3D.Mesh(t), a = e + p;
        for (D = 0; D <= v; D++) {
            a -= p, o = Math.cos(a), d = Math.sin(a), M = n.vertices.length - (y + 1), i = n.vertices.length, s = -e - f;
            for (T = 0; T <= y; T++) s += f, h = o * Math.sin(s), u = o * Math.cos(s), c = d, n.vertices.push([g[0] + h * m[0], g[1] + u * m[1], g[2] + c * m[2]]), n.normals && n.normals.push([h, u, c]), n.coords && n.coords.push([1 - T / y, 1 - D / v]), D > 0 && T > 0 && (n.triangles.push([i, i - 1, M - 1]), n.triangles.push([M, i, M - 1])), M++, i++
        }
        if (n.lines) {
            for (var x = t.graticule ? pd.constrainTo(t.graticule, 1, 10) : 2, b = t.poleGraticule ? pd.constrainTo(t.poleGraticule, 1, 10) : 3, D = x; D < v; D += x) {
                i = D * (y + 1);
                for (T = 0; T <= y; T++) n.lines.push([i - 1, i++])
            }
            for (var T = 0; T < y; T += x) {
                T % b || (i = y + 1 + T, n.lines.push([i - (y + 1), i]));
                for (D = 2; D < v; D++) i = D * (y + 1) + T, n.lines.push([i - (y + 1), i]);
                T % b || (i = v * (y + 1) + T, n.lines.push([i - (y + 1), i]))
            }
        }
        return n.compile(), n
    }, pd3D.Shapes.thickLine = function (t, e) {
        function r(t) {
            var e = t[0], r = t[1], n = +t[2] || 0, i = e * e + r * r + n * n;
            i > 0 && (i = 1 / Math.sqrt(i), t[0] = e * i, t[1] = r * i, t[2] = n * i)
        }

        var n = t.vertices;
        if (n && n.length > 1) {
            var i = !1;
            t = t || {}, e || (e = new pd3D.Mesh(t), i = !0);
            var a, s, o, d, h, u, c, l, p, f, m, g = n.length, v = pd.toInteger(t.side, 0), y = pd.toNumber(t.scale, 1),
                M = pd.toNumber(t.shaft, 0), x = t.normal || [0, 0, 1],
                b = e.triangles && pd.toBoolean(t.triangles, !0), D = e.lines && pd.toBoolean(t.lines, !1),
                T = e.vertexCount(), w = [], O = [], A = [], C = [], _ = [];
            if (t.style) {
                var S = t.style;
                v = pd.toInteger(S.lineSide, v), M = pd.toNumber(S.lineWidth, M), b = e.triangles && pd.toBoolean(S.triangles, b), D = e.lines && pd.toBoolean(S.lines, D)
            }
            switch (y > pd.Const.EPSILON && (M *= y), v) {
                default:
                    o = h = .5 * M;
                    break;
                case pd.Align.OUTSIDE:
                    o = 0, h = M;
                    break;
                case pd.Align.INSIDE:
                    o = M, h = 0
            }
            if (!t.forceTriangles && M < 1.001 && e.lines) {
                e.addVertex(n[0]);
                for (I = 1; I < g - 1; ++I) c = e.addVertex(n[I]), e.addLine(c - 1, c);
                t.ignoreEnd || (c = e.addVertex(n[g - 1]), e.addLine(c - 1, c))
            } else {
                u = t.closed ? 0 : 1, d = t.closed ? g - 1 : 0, A[0] = n[u][0] - n[d][0], A[1] = n[u][1] - n[d][1], A[2] = (+n[u][2] || 0) - (+n[d][2] || 0), A.len = Math.sqrt(A[0] * A[0] + A[1] * A[1] + A[2] * A[2]), w[0] = A[1] * x[2] - A[2] * x[1], w[1] = A[2] * x[0] - A[0] * x[2], w[2] = A[0] * x[1] - A[1] * x[0], r(w);
                for (var I = 0; I < g; ++I) {
                    if (d = I, (u = I + 1) >= g) {
                        if (t.ignoreEnd) break;
                        u = 0
                    }
                    C[0] = n[u][0] - n[d][0], C[1] = n[u][1] - n[d][1], C[2] = (+n[u][2] || 0) - (+n[d][2] || 0), C.len = Math.sqrt(C[0] * C[0] + C[1] * C[1] + C[2] * C[2]), O[0] = C[1] * x[2] - C[2] * x[1], O[1] = C[2] * x[0] - C[0] * x[2], O[2] = C[0] * x[1] - C[1] * x[0], r(O), p = A.len * C.len, l = A[0] * C[0] + A[1] * C[1] + A[2] * C[2], (m = (f = p > pd.Const.EPSILON ? l / p : 0) >= 1 ? 0 : f <= -1 ? Math.PI : Math.acos(f)) > .0872664626 && !pd.closeTo(m, Math.PI, .0872664626) ? (a = o / (p = Math.cos(.5 * m)), s = h / p, _[0] = w[0] + O[0], _[1] = w[1] + O[1], _[2] = w[2] + O[2], r(_), e.addVertex([n[d][0] - _[0] * a, n[d][1] - _[1] * a, n[d][2] - _[2] * a]), c = e.addVertex([n[d][0] + _[0] * s, n[d][1] + _[1] * s, n[d][2] + _[2] * s]), I > 0 ? (b && (e.addTriangle(c - 3, c, c - 1), e.addTriangle(c - 3, c - 2, c)), D && (e.addLine(c - 3, c - 1), e.addLine(c - 2, c))) : D && e.addLine(c - 1, c)) : (I > 0 && (e.addVertex([n[d][0] - w[0] * o, n[d][1] - w[1] * o, n[d][2] - w[2] * o]), c = e.addVertex([n[d][0] + w[0] * h, n[d][1] + w[1] * h, n[d][2] + w[2] * h]), b && (e.addTriangle(c - 3, c, c - 1), e.addTriangle(c - 3, c - 2, c)), D && (e.addLine(c - 3, c - 1), e.addLine(c - 2, c))), e.addVertex([n[d][0] - O[0] * o, n[d][1] - O[1] * o, n[d][2] - O[2] * o]), c = e.addVertex([n[d][0] + O[0] * h, n[d][1] + O[1] * h, n[d][2] + O[2] * h]), 0 == I && D && e.addLine(c - 1, c)), w[0] = O[0], w[1] = O[1], w[2] = O[2], A.len = C.len, A[0] = C[0], A[1] = C[1], A[2] = C[2]
                }
                !t.ignoreEnd && t.closed ? (b && (e.addTriangle(T, c - 1, c), e.addTriangle(T, c, T + 1)), D && (e.addLine(T, c - 1), e.addLine(T + 1, c))) : !t.ignoreEnd && D && e.addLine(c - 1, c)
            }
            t.transform instanceof pd3D.Matrix && e.transform(matrix, null, T), i && e.compile()
        }
        return e
    }, pd3D.Shapes.arrow = function (t, e) {
        var r = !1, n = !1;
        t = t || {}, e || (e = new pd3D.Mesh(t), r = !0);
        var i = pd.toInteger(t.type, 0), a = pd.toNumber(t.scale, 1), s = pd.toNumber(t.shaft, 0),
            o = pd.toNumber(t.indent, 0), d = pd.toNumber(t.thickness, .25),
            h = Math.max(1, pd.toNumber(t.length, i > 0 ? 25 : 40)),
            u = Math.max(1, pd.toNumber(t.width, h * (i > 0 ? 1 : .6))),
            c = e.triangles && pd.toBoolean(t.triangles, !0), l = e.lines && pd.toBoolean(t.lines, !1);
        if (t.style) {
            var p = t.style;
            i = pd.toInteger(p.arrowType, i), s = pd.toNumber(p.lineWidth, s), o = pd.toNumber(p.arrowIndent, o), d = pd.toNumber(p.arrowThickness, d), u = Math.max(1, pd.toNumber(p.arrowWidth, u)), h = Math.max(1, pd.toNumber(p.arrowLength, h)), c = e.triangles && pd.toBoolean(p.triangles, c), l = e.lines && pd.toBoolean(p.lines, l)
        }
        var f = -1, m = -1, g = u / h;
        t.vertices && t.vertices.length > 0 && (t.side = pd.Align.CENTER, n = t.ignoreEnd = !0, pd3D.Shapes.thickLine(t, e)), a > pd.Const.EPSILON && (u *= a, h *= a, o *= a, s *= a);
        var v = 4;
        d >= 1 ? v = 1 / (d * a / h) : d > 0 && (v = 1 / d);
        var y = h / v, M = u / v, x = t.to;
        null == x && (x = t.vertices && t.vertices.length > 0 ? t.vertices[t.vertices.length - 1] : [0, 0, 0]);
        var b = t.from || null;
        null == b && t.vertices && t.vertices.length > 1 && (b = t.vertices[t.vertices.length - 2]);
        var D = s < 1.001 ? 0 : .5 * s, T = .5 * u, w = e.vertexCount();
        switch (i) {
            default:
            case 0:
                o = Math.min(o, .9 * h), pd.closeTo(o, 0, .1) && !n ? (e.addVertex([0, 0, 0]), e.addVertex([-h, T, 0]), e.addVertex([-h, -T, 0]), c && e.addTriangle(w, w + 1, w + 2), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 2, w))) : (e.addVertex([0, 0, 0]), e.addVertex([-h, T, 0]), f = e.addVertex([-h + o, D, 0]), m = e.addVertex([-h + o, -D, 0]), e.addVertex([-h, -T, 0]), c && (e.addTriangle(w, w + 1, w + 2), e.addTriangle(w, w + 3, w + 4)), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 3, w + 4), e.addLine(w + 4, w)));
                break;
            case 1:
                e.addVertex([0, 0, 0]), e.addVertex([-(v + .25) * y, (v + .25) * M, 0]), e.addVertex([-(v + .75) * y, (v - .25) * M, 0]), f = e.addVertex([-y - D, D * g, 0]), m = e.addVertex([-y - D, -D * g, 0]), e.addVertex([-(v + .75) * y, -(v - .25) * M, 0]), e.addVertex([-(v + .25) * y, -(v + .25) * M, 0]), c && (e.addTriangle(w, w + 1, w + 3), e.addTriangle(w + 1, w + 2, w + 3), e.addTriangle(w + 4, w + 5, w + 6), e.addTriangle(w, w + 4, w + 6)), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 2, w + 3), e.addLine(w + 4, w + 5), e.addLine(w + 5, w + 6), e.addLine(w + 6, w));
                break;
            case 2:
                e.addVertex([0, 0, 0]), e.addVertex([-v * y, v * M, 0]), e.addVertex([-(v + 1) * y, v * M, 0]), f = e.addVertex([-y - D, D * g, 0]), m = e.addVertex([-y - D, -D * g, 0]), e.addVertex([-(v + 1) * y, -v * M, 0]), e.addVertex([-v * y, -v * M, 0]), c && (e.addTriangle(w, w + 1, w + 3), e.addTriangle(w + 1, w + 2, w + 3), e.addTriangle(w + 4, w + 5, w + 6), e.addTriangle(w, w + 4, w + 6)), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 2, w + 3), e.addLine(w + 4, w + 5), e.addLine(w + 5, w + 6), e.addLine(w + 6, w));
                break;
            case 3:
                e.addVertex([0, 0, 0]), e.addVertex([-(v + .5) * y, (v + .5) * M, 0]), e.addVertex([-(v + .5) * y, (v - .5) * M, 0]), f = e.addVertex([-y - D, D * g, 0]), m = e.addVertex([-y - D, -D * g, 0]), e.addVertex([-(v + .5) * y, -(v - .5) * M, 0]), e.addVertex([-(v + .5) * y, -(v + .5) * M, 0]), c && (e.addTriangle(w, w + 1, w + 3), e.addTriangle(w + 1, w + 2, w + 3), e.addTriangle(w + 4, w + 5, w + 6), e.addTriangle(w, w + 4, w + 6)), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 2, w + 3), e.addLine(w + 4, w + 5), e.addLine(w + 5, w + 6), e.addLine(w + 6, w));
                break;
            case 4:
                e.addVertex([0, 0, 0]), e.addVertex([-v * y, v * M, 0]), e.addVertex([-(v + .5) * y, v * M, 0]), e.addVertex([-(v + .5) * y, (v - .5) * M, 0]), f = e.addVertex([-y - D, D * g, 0]), m = e.addVertex([-y - D, -D * g, 0]), e.addVertex([-(v + .5) * y, -(v - .5) * M, 0]), e.addVertex([-(v + .5) * y, -v * M, 0]), e.addVertex([-v * y, -v * M, 0]), c && (e.addTriangle(w, w + 1, w + 4), e.addTriangle(w + 1, w + 2, w + 3), e.addTriangle(w + 1, w + 3, w + 4), e.addTriangle(w + 5, w + 6, w + 8), e.addTriangle(w + 6, w + 7, w + 8), e.addTriangle(w, w + 5, w + 8)), l && (e.addLine(w, w + 1), e.addLine(w + 1, w + 2), e.addLine(w + 2, w + 3), e.addLine(w + 3, w + 4), e.addLine(w + 5, w + 6), e.addLine(w + 6, w + 7), e.addLine(w + 7, w + 8), e.addLine(w + 8, w))
        }
        if (f >= 0 && m >= 0 && (D < .1 && e.lines ? e.addLine(w - 1, m) : (c && D > 0 && (e.addTriangle(w, f, m), n && (e.addTriangle(w - 1, f, w - 2), e.addTriangle(w - 1, m, f))), l && (n ? (e.addLine(w - 2, f), e.addLine(w - 1, m)) : D > 0 && e.addLine(f, m)))), Array.isArray(x)) {
            var O = pd3D.Matrix.translate(+x[0] || 0, +x[1] || 0, +x[2] || 0);
            if (Array.isArray(b)) {
                var A = Math.atan2(x[1] - b[1], x[0] - b[0]) * pd.Const.RAD2DEG;
                pd.closeTo(A, 0) || (O = pd3D.Matrix.multiply(O, pd3D.Matrix.rotate(A, 0, 0, 1), O))
            }
            e.transform(O, null, w)
        }
        return t.transform instanceof pd3D.Matrix && e.transform(matrix, null, w), r && e.compile(), e
    }, pd3D.Shapes.polygon = function (t, e, n) {
        var i = !1;
        t = t || {}, e || (e = new pd3D.Mesh(t), i = !0);
        var a, s, o, d, h, u, c, l = null, p = pd.toInteger(t.type, 0), f = pd.toNumber(t.size, 20),
            m = pd.toNumber(t.rotation, 0), g = pd.toNumber(t.thickness, 2.5),
            v = pd.constrainTo(pd.toNumber(t.angle, 360), 0, 360),
            y = pd.constrainTo(pd.toInteger(t.segments, 24), 2, 720), M = e.triangles && pd.toBoolean(t.triangles, !0),
            x = e.lines && pd.toBoolean(t.lines, !1), b = {pos: []}, D = t.center || null;
        null == D && t.vertices && t.vertices.length > 0 && (D = t.vertices[t.vertices.length - 1]), n = pd.toNumber(n, 0), pd.closeTo(n, 0) && (n = pd.toNumber(t.scale, 0)), pd.closeTo(n, 0) && (n = 1), Array.isArray(t.offset) && (null == D && (D = [0, 0, 0]), D[0] += (+t.offset[0] || 0) * n, D[1] += (+t.offset[1] || 0) * n, D[2] += (+t.offset[2] || 0) * n);
        var T = t.from || null;
        if (null == T && t.vertices && t.vertices.length > 1 && (T = t.vertices[t.vertices.length - 2]), pd.closeTo(v, 0) && (v = 360), n > pd.Const.EPSILON && (g *= n, f *= n), Array.isArray(t.color) && e.color(t.color), t.transform instanceof pd3D.Matrix && (l = t.transform), e.normals) {
            var w = [0, 0, 1];
            l && l.applyVectorTransformToArray(w), e.normal(w)
        }
        var O = e.vertexCount();
        switch (p) {
            case 2:
            case-2:
                y = 3, g *= 2, m += 60;
                break;
            case 3:
            case-3:
                y = 4, g *= 1.41421356, m += 45;
                break;
            case 4:
            case-4:
                y = 4, g *= 1.41421356;
                break;
            case 5:
            case-5:
                y *= 2, m += 180;
                break;
            case-6:
                y = 4
        }
        switch (p) {
            default:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                var A = f, C = Math.max(2, pd.toInteger(t.tickIncr, 2));
                if (A > 0) {
                    b.pos = [0, 0, 0], e.coords && (b.coord = [0, 0]);
                    var _ = e.addVertexData(b);
                    y < 2 && (y = pd.mapAndConstrainTo(v, 0, 360, 2, 24)), m *= pd.Const.DEG2RAD, v *= pd.Const.DEG2RAD, c = 0;
                    for (var S = 0, I = 1 + (L = .5 * (E = 1 / Math.round(y))); S < I; S += E) V = Math.min(S, 1) * v, h = Math.cos(V + m), u = Math.sin(V + m), 5 == p && (A = c++ % C ? f - g : f), b.pos = [A * h, A * u, 0], e.coords && (b.coord = [h, u]), a = e.addVertexData(b), S > L && (M && e.addTriangle(_, s, a), x && e.addLine(s, a)), s = a;
                    x && v < r && (e.addLine(_, _ + 1), e.addLine(_, a))
                }
                break;
            case-1:
            case-2:
            case-3:
            case-4:
            case-5:
                var A = f, k = Math.max(0, f - g), C = Math.max(2, pd.toInteger(t.tickIncr, 2));
                if (A > 0) {
                    y < 2 && (y = pd.mapAndConstrainTo(v, 0, 360, 2, 24)), m *= pd.Const.DEG2RAD, v *= pd.Const.DEG2RAD, c = 0;
                    for (var S = 0, I = 1 + (L = .5 * (E = 1 / Math.round(y))); S < I; S += E) V = Math.min(S, 1) * v, h = Math.cos(V + m), u = Math.sin(V + m), -5 == p && (A = c++ % C ? f - g : f), b.pos = [k * h, k * u, 0], e.coords && (b.coord = [h, u]), a = e.addVertexData(b), b.pos = [A * h, A * u, 0], o = e.addVertexData(b), S > L && (M && (e.addTriangle(o, s, d), e.addTriangle(a, s, o)), x && (e.addLine(s, a), e.addLine(d, o))), s = a, d = o;
                    x && v < r && (e.addLine(O, O + 1), e.addLine(s, d))
                }
                break;
            case-6:
            case 6:
                var A = f, N = pd.toNumber(t.tickSize, g) * n, k = Math.max(0, f - N);
                if (A > 0) {
                    y < 2 && (y = pd.mapAndConstrainTo(v, 0, 360, 2, 24)), g *= .5, c = 0;
                    for (var V, E = 1 / Math.round(y), L = .5 * E, R = new pd3D.Matrix, P = [new pd3D.Vector(-g, k, 0), new pd3D.Vector(g, k, 0), new pd3D.Vector(g, A, 0), new pd3D.Vector(-g, A, 0)], S = 0; S < 1; S += E) V = Math.min(S, 1) * v, R = pd3D.Matrix.rotate(V + m, 0, 0, 1, R), b.pos = R.transformPoint(P[0]).toArray(), a = e.addVertexData(b), b.pos = R.transformPoint(P[1]).toArray(), e.addVertexData(b), b.pos = R.transformPoint(P[2]).toArray(), e.addVertexData(b), b.pos = R.transformPoint(P[3]).toArray(), e.addVertexData(b), M && (e.addTriangle(a, a + 1, a + 2), e.addTriangle(a, a + 2, a + 3)), x && (e.addLine(a, a + 1), e.addLine(a + 1, a + 2), e.addLine(a + 2, a + 3), e.addLine(a + 3, a + 1))
                }
        }
        if (Array.isArray(T)) {
            var z = 0;
            z = null != D ? Math.atan2(D[1] - T[1], D[0] - T[0]) * pd.Const.RAD2DEG : Math.atan2(-T[1], -T[0]) * pd.Const.RAD2DEG, pd.closeTo(z, 0) || e.transform(pd3D.Matrix.rotate(z, 0, 0, 1), null, O)
        }
        return null != D && e.transform(pd3D.Matrix.translate(D[0], D[1], D[2]), null, O), l && e.transform(l, null, O), i && e.compile(), e
    }, pd3D.Shapes.circularAxis = function (t, e) {
        var n = !1;
        t = t || {}, e || (e = new pd3D.Mesh(t), n = !0);
        var i, a, s, o, d, h, u, c = null, l = pd.toNumber(t.radius, 1), p = pd.toNumber(t.scale, 1),
            f = pd.toNumber(t.angle, 0), m = pd.toNumber(t.thickness, .1), g = pd.toNumber(t.tickLength, .25),
            v = pd.toNumber(t.tickWidth, m), y = pd.constrainTo(pd.toNumber(t.arc, 360), 0, 360),
            M = pd.constrainTo(pd.toNumber(t.segments, 0), 0, 720), x = e.triangles && pd.toBoolean(t.triangles, !0),
            b = e.lines && pd.toBoolean(t.lines, !1), D = {pos: []}, T = t.center || null;
        null == T && (T = t.vertices && t.vertices.length > 0 ? t.vertices[t.vertices.length - 1] : [0, 0, 0]);
        var w = t.from || null;
        if (null == w && t.vertices && t.vertices.length > 1 && (w = t.vertices[t.vertices.length - 2]), p > pd.Const.EPSILON && (m *= p, size *= p), Array.isArray(t.color) && e.color(t.color), t.transform instanceof pd3D.Matrix && (c = t.transform), e.normals) {
            var O = [0, 0, 1];
            c && c.applyVectorTransformToArray(O), e.normal(O)
        }
        var A = e.vertexCount(), C = Math.max(.01, l - m), _ = Math.max(.005, C - g);
        Math.atan2(.5 * v, C), Math.atan2(.5 * v, _);
        if (l > 0) {
            M < 2 && (M = pd.mapAndConstrainTo(y, 0, 360, 2, 24)), f *= pd.Const.DEG2RAD, y *= pd.Const.DEG2RAD, u = 0;
            for (var S, I = 1 / Math.round(M), k = .5 * I, N = 0, V = 1 + k; N < V; N += I) S = Math.min(N, 1) * y, d = Math.cos(S + f), h = Math.sin(S + f), D.pos = [T[0] + C * d, T[1] + C * h, T[2]], e.coords && (D.coord = [d, h]), i = e.addVertexData(D), D.pos = [T[0] + l * d, T[1] + l * h, T[2]], s = e.addVertexData(D), N > k && (x && (e.addTriangle(s, a, o), e.addTriangle(i, a, s)), b && (e.addLine(a, i), e.addLine(o, s))), a = i, o = s, -5 == type && (l = ++u % 2 ? size - m : size);
            b && y < r && (e.addLine(A, A + 1), e.addLine(a, o))
        }
        if (Array.isArray(w)) {
            var E = Math.atan2(T[1] - w[1], T[0] - w[0]) * pd.Const.RAD2DEG;
            pd.closeTo(E, 0) || e.transform(pd3D.Matrix.rotate(E, 0, 0, 1), null, A)
        }
        return c && e.transform(c, null, A), n && e.compile(), e
    }, pd3D.Shapes.circularArrow = function (t, e) {
        var r = !1;
        t = t || {}, e || (e = new pd3D.Mesh(t), r = !0);
        var n = pd.Const.DEG2RAD, i = pd.toNumber(t.width, 1), a = pd.toNumber(t.radius, 1), s = t.center || [0, 0, 0],
            o = pd.toNumber(t.fromAngle, 0) * n, d = pd.toNumber(t.toAngle, Math.PI) * n,
            h = e.triangles && pd.toBoolean(t.triangles, !0), u = e.lines && pd.toBoolean(t.lines, !1),
            c = e.vertexCount(), l = 2.5 * n, p = d - o, f = Math.ceil(Math.abs(p) / l), m = a + i, g = a - i,
            v = a + .5 * i, y = a - .5 * i;
        f < 3 && (f = 3);
        var M = o, x = p / f, b = Math.sin(o), D = Math.cos(o);
        e.addVertex([s[0] + a * b, s[1] + a * D, s[2]]), M += x, b = Math.sin(M), D = Math.cos(M), e.addVertex([s[0] + m * b, s[1] + m * D, s[2]]), e.addVertex([s[0] + g * b, s[1] + g * D, s[2]]), h && e.addTriangle(c, c + 2, c + 1), e.addVertex([s[0] + y * b, s[1] + y * D, s[2]]), e.addVertex([s[0] + v * b, s[1] + v * D, s[2]]), u && (e.addLine(c, c + 1), e.addLine(c, c + 2), e.addLine(c + 2, c + 3), e.addLine(c + 1, c + 4));
        for (var T = e.vertexCount(), w = 2; w < f; w++) M += x, b = Math.sin(M), D = Math.cos(M), e.addVertex([s[0] + y * b, s[1] + y * D, s[2]]), e.addVertex([s[0] + v * b, s[1] + v * D, s[2]]), h && (e.addTriangle(T - 1, T - 2, T), e.addTriangle(T + 1, T - 1, T)), u && (e.addLine(T - 2, T), e.addLine(T - 1, T + 1)), T += 2;
        return e.addVertex([s[0] + g * b, s[1] + g * D, s[2]]), e.addVertex([s[0] + m * b, s[1] + m * D, s[2]]), b = Math.sin(d), D = Math.cos(d), e.addVertex([s[0] + a * b, s[1] + a * D, s[2]]), h && e.addTriangle(T, T + 2, T + 1), u && (e.addLine(T - 2, T), e.addLine(T - 1, T + 1), e.addLine(T, T + 2), e.addLine(T + 1, T + 2)), t.transform instanceof pd3D.Matrix && e.transform(t.transform, null, c), r && e.compile(), e
    }
}(), String.prototype.trim || function () {
    String.prototype.trim = function () {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
    }
}(), function () {
    function t(t, e) {
        var r = S + (t + m * (e - .5)) * p, n = (e + g * e * (t - .5)) * p, i = _.m;
        return C.init(i[0] * r + i[1] * n + i[3], i[4] * r + i[5] * n + i[7], i[8] * r + i[9] * n + i[11]).divide(i[12] * r + i[13] * n + i[15]), C.toArray()
    }

    function e(t, e) {
        return C.init(S + (t + m * (e - .5)) * p, (e + g * e * (t - .5)) * p, O), _.transformPoint(C, C), C.toArray()
    }

    function r(e, r, n) {
        var i, a, u, c, l = e.length;
        s.hasVertexColors && s.color(o);
        var p = s.addVertex(t(e[0][0], e[0][1]));
        for (u = 1; u < l; ++u) s.addVertex(t(e[u][0], e[u][1]));
        if (h > .001) for (l = r.length, u = 0; u < l; ++u) s.addTriangle(p + r[u][0], p + r[u][1], p + r[u][2]), r[u].length > 3 && s.addTriangle(p + r[u][0], p + r[u][2], p + r[u][3]);
        if (D = p, w && n) {
            if (d && s.hasVertexColors) for (l = e.length, s.color(d), p = s.addVertex(t(e[0][0], e[0][1])), u = 1; u < l; ++u) s.addVertex(t(e[u][0], e[u][1]));
            for (i = p, l = n.length, u = 0; u < l; ++u) {
                for (a = p + n[u], c = i + 1; c <= a; ++c) s.addLine(c - 1, c);
                s.addLine(a, i), i = a + 1
            }
        }
    }

    function n(r, n, i) {
        var a, o, d, h, u, c, l = r.length;
        for (u = s.addVertex(t(r[0][0], r[0][1])), d = 1; d < l; ++d) s.addVertex(t(r[d][0], r[d][1]));
        for (c = s.addVertex(e(r[0][0], r[0][1])), d = 1; d < l; ++d) s.addVertex(e(r[d][0], r[d][1]));
        for (l = n.length, d = 0; d < l; ++d) s.addTriangle(u + n[d][2], u + n[d][1], u + n[d][0]), n[d].length > 3 && s.addTriangle(u + n[d][3], u + n[d][2], u + n[d][0]), s.addTriangle(c + n[d][0], c + n[d][1], c + n[d][2]), n[d].length > 3 && s.addTriangle(c + n[d][0], c + n[d][2], c + n[d][3]);
        for (d = 0; d < l; ++d) s.addTriangle(u + n[d][2], u + n[d][1], u + n[d][0]), n[d].length > 3 && s.addTriangle(u + n[d][3], u + n[d][2], u + n[d][0]), s.addTriangle(c + n[d][0], c + n[d][1], c + n[d][2]), n[d].length > 3 && s.addTriangle(c + n[d][0], c + n[d][2], c + n[d][3]);
        if (i) {
            for (a = u, l = i.length, vtx_dif = c - u, d = 0; d < l; ++d) {
                for (o = u + i[d], h = a + 1; h <= o; ++h) s.addTriangle(h - 1, h, h + vtx_dif), s.addTriangle(h - 1, h + vtx_dif, h - 1 + vtx_dif);
                s.addTriangle(o, a, a + vtx_dif), s.addTriangle(o, a + vtx_dif, o + vtx_dif), a = o + 1
            }
            if (w) {
                for (a = u, d = 0; d < l; ++d) {
                    for (o = u + i[d], h = a + 1; h <= o; ++h) s.addLine(h - 1, h);
                    s.addLine(o, a), a = o + 1
                }
                for (a = c, d = 0; d < l; ++d) {
                    for (o = c + i[d], h = a + 1; h <= o; ++h) s.addLine(h - 1, h);
                    s.addLine(o, a), a = o + 1
                }
                for (d = 0; d < l; ++d) for (h = i[d]; h >= 0; --h) s.addLine(h + u, h + c)
            }
        }
        T = c, D = u
    }

    function i(r, n, i) {
        var a, o, d, h, u, c, l, p, f, m, g = r.length, v = [0, 0, -1], y = s.defaultNormal;
        for (_.applyVectorTransformToArray(v), s.defaultNormal = v.slice(), d = s.addVertex(t(r[0][0], r[0][1])), u = 1; u < g; ++u) s.addVertex(t(r[u][0], r[u][1]));
        for (pd3D.VectorArray.negate(v), s.defaultNormal = v.slice(), h = s.addVertex(e(r[0][0], r[0][1])), u = 1; u < g; ++u) s.addVertex(e(r[u][0], r[u][1]));
        for (g = n.length, u = 0; u < g; ++u) s.addTriangle(d + n[u][2], d + n[u][1], d + n[u][0]), n[u].length > 3 && s.addTriangle(d + n[u][3], d + n[u][2], d + n[u][0]), s.addTriangle(h + n[u][0], h + n[u][1], h + n[u][2]), n[u].length > 3 && s.addTriangle(h + n[u][0], h + n[u][2], h + n[u][3]);
        for (u = 0; u < g; ++u) s.addTriangle(d + n[u][2], d + n[u][1], d + n[u][0]), n[u].length > 3 && s.addTriangle(d + n[u][3], d + n[u][2], d + n[u][0]), s.addTriangle(h + n[u][0], h + n[u][1], h + n[u][2]), n[u].length > 3 && s.addTriangle(h + n[u][0], h + n[u][2], h + n[u][3]);
        if (i) {
            for (a = 0, g = i.length, u = 0; u < g; ++u) {
                for (o = i[u], c = a + 1; c <= o; ++c) l = t(r[c - 1][0], r[c - 1][1]), p = t(r[c][0], r[c][1]), f = e(r[c][0], r[c][1]), m = e(r[c - 1][0], r[c - 1][1]), pd3D.VectorArray.calculateSurfaceNormal(v, l, p, f), s.defaultNormal = v.slice(), s.addTriangle(s.addVertex(l), s.addVertex(p), s.addVertex(f)), s.addTriangle(s.addVertex(l), s.addVertex(f), s.addVertex(m));
                l = t(r[o][0], r[o][1]), p = t(r[a][0], r[a][1]), f = e(r[a][0], r[a][1]), m = e(r[o][0], r[o][1]), pd3D.VectorArray.calculateSurfaceNormal(v, l, p, f), s.defaultNormal = v.slice(), s.addTriangle(s.addVertex(l), s.addVertex(p), s.addVertex(f)), s.addTriangle(s.addVertex(l), s.addVertex(f), s.addVertex(m)), a = o + 1
            }
            if (w) {
                for (a = d, u = 0; u < g; ++u) {
                    for (o = d + i[u], c = a + 1; c <= o; ++c) s.addLine(c - 1, c);
                    s.addLine(o, a), a = o + 1
                }
                for (a = h, u = 0; u < g; ++u) {
                    for (o = h + i[u], c = a + 1; c <= o; ++c) s.addLine(c - 1, c);
                    s.addLine(o, a), a = o + 1
                }
                for (u = 0; u < g; ++u) for (c = i[u]; c >= 0; --c) s.addLine(c + d, c + h)
            }
        }
        s.defaultNormal = y, T = h, D = d
    }

    function a(t) {
        var e, r, n, i, a, s = t.length, o = !1, d = !1, M = !1, D = m, T = g, w = 0;
        S = 0, s > 0 && (a = t.charCodeAt(0)) >= 97 && a < 123 && (M = !0);
        for (var O = 0; O < s; O++) {
            switch (p = 1, i = 1, e = r = 0, o = d, d = M, M = O < s - 1 && ((a = t.charCodeAt(O + 1)) >= 97 && a < 123), t.charAt(O)) {
                default:
                    n = .25 * l, r = b[1] + pd.mapAndConstrainTo(h, 0, .3, .2, .1), A([[x[0], b[0]], [x[9], b[0]], [x[9], b[14]], [x[0], b[14]], [x[1], b[1]], [x[8], b[1]], [x[8], b[13]], [x[0], b[13]]], [[0, 1, 7, 4], [1, 2, 6, 7], [2, 3, 5, 6], [3, 0, 4, 5]], [3, 7]);
                    break;
                case" ":
                    i = v;
                    break;
                case"\f":
                    w = veryClose(w, 0) ? .15 : 0, m = D + w, i = 0;
                    break;
                case"!":
                    r = b[1] + pd.mapAndConstrainTo(h, 0, .3, .2, .1), A([[x[0], b[0]], [x[1], b[0]], [x[1], b[1]], [x[0], b[1]], [x[0], r], [x[1], r], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 2, 3], [4, 5, 6, 7]], [3, 7]), i = h / l;
                    break;
                case'"':
                    n = x[1] + .1, A([[x[0], b[13]], [x[0] + u, b[13] - h], [x[1], b[13]], [x[1], b[14]], [x[0], b[14]], [n, b[13]], [n + u, b[13] - h], [n + h, b[13]], [n + h, b[14]], [n, b[14]]], [[0, 1, 2], [0, 2, 3, 4], [5, 6, 7], [6, 7, 8, 9]], [4, 9]), i = h / l * 2 + .1;
                    break;
                case"'":
                    A([[x[0], b[13]], [x[0] + u, b[13] - h], [x[1], b[13]], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 2], [0, 2, 3, 4]], [4]), i = h / l;
                    break;
                case"#":
                    e = pd.mapAndConstrainTo(l, 0, 5, 0, .2 * l), r = pd.mapAndConstrainTo(h, 0, .3, .2, .05);
                    var C = .3 * l, _ = Math.atan(1 / C), I = h / Math.sin(_), k = Math.cos(_), N = b[7] - r,
                        V = b[7] - r - h, E = b[7] + r + h, L = b[7] + r, R = N * k, P = V * k, z = E * k, F = L * k,
                        B = b[14] * k, U = pd.mapAndConstrainTo(l, 0, 2, 0, e + r), q = x[0] + e, H = x[0] + U,
                        Y = x[9] - U - B - I, G = x[9] - e;
                    A([[H, b[0]], [H + I, b[0]], [H + P + I, V], [Y + P, V], [Y, b[0]], [Y + I, b[0]], [Y + P + I, V], [G, V], [G, N], [Y + R + I, N], [Y + F + I, L], [G, L], [G, E], [Y + z + I, E], [Y + B + I, b[14]], [Y + B, b[14]], [Y + z, E], [H + z + I, E], [H + B + I, b[14]], [H + B, b[14]], [H + z, E], [q, E], [q, L], [H + F, L], [H + R, N], [q, N], [q, V], [H + P, V], [H + R + I, N], [H + F + I, L], [Y + F, L], [Y + R, N]], [[0, 1, 2, 27], [3, 4, 5, 6], [9, 10, 30, 31], [13, 14, 15, 16], [17, 18, 19, 20], [23, 24, 28, 29], [26, 7, 8, 25], [22, 11, 12, 21]], [27, 31]);
                    break;
                case"$":
                    A([[x[2], b[0]], [x[4], b[0]], [x[4], b[0] - .2], [x[5], b[0] - .2], [x[5], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[7], b[8]], [x[3], b[8]], [x[1], b[10]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[9], b[11]], [x[9], b[12]], [x[7], b[14]], [x[5], b[14]], [x[5], b[14] + .2], [x[4], b[14] + .2], [x[4], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[9]], [x[2], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[0], b[3]], [x[0], b[2]]], [[0, 5, 29, 30], [5, 6, 28, 29], [6, 7, 27, 28], [7, 8, 26, 27], [8, 9, 25, 26], [9, 10, 24, 25], [10, 11, 23, 24], [11, 12, 22, 23], [12, 13, 17, 22], [13, 14, 16, 17], [14, 15, 16], [30, 31, 33, 0], [31, 32, 33], [1, 2, 3, 4], [18, 19, 20, 21]], [33]);
                    break;
                case"%":
                    var X = Math.min(.15, h), W = pd.mapAndConstrainTo(h, 0, .2, .05, .15);
                    n = x[9] - 1.5 * W, r = (e = u / Math.sin(Math.atan(1 / l))) / l, A([[x[0], b[0]], [x[0] + e, b[0]], [x[9], b[14] - r], [x[9], b[14]], [x[9] - e, b[14]], [x[0], b[0] + r], [n - (e = 1.5 * W), (r = b[0] + 1.5 * W) - e], [n + e, r - e], [n + e, r + e], [n - e, r + e], [n - (e -= X), r - e], [n - e, r + e], [n + e, r + e], [n + e, r - e], [(n = x[0] + 1.5 * W) - (e = 1.5 * W), (r = b[14] - 1.5 * W) - e], [n + e, r - e], [n + e, r + e], [n - e, r + e], [n - (e -= X), r - e], [n - e, r + e], [n + e, r + e], [n + e, r - e]], [[0, 1, 5], [1, 2, 4, 5], [2, 3, 4], [6, 7, 13, 10], [7, 8, 12, 13], [8, 9, 11, 12], [9, 6, 10, 11], [14, 15, 21, 18], [15, 16, 20, 21], [16, 17, 19, 20], [17, 14, 18, 19]], [5, 9, 13, 17, 21]);
                    break;
                case"&":
                    n = x[4], e = Math.min(x[4] - .05, x[0] + Math.max(0, b[9] - .5)), A([[n, b[0] - .2], [n + h, b[0] - .2], [n + h, b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[3]], [x[8], b[3]], [x[6], b[1]], [n + h, b[1]], [n + h, b[6]], [x[6], b[6]], [x[6], b[8]], [n + h, b[8]], [n + h, b[13]], [x[6] - e, b[13]], [x[8] - e, b[11]], [x[9] - e, b[11]], [x[9] - e, b[12]], [x[7] - e, b[14]], [n + h, b[14]], [n + h, b[14] + .2], [n, b[14] + .2], [n, b[14]], [x[2] + e, b[14]], [x[0] + e, b[12]], [x[0] + e, b[7]], [x[0], b[5]], [x[0], b[2]], [x[2], b[0]], [n, b[0]], [x[3], b[1]], [x[1], b[3]], [x[1], b[4]], [x[3], b[6]], [n, b[6]], [n, b[1]], [x[3], b[8]], [x[1] + e, b[11]], [x[3] + e, b[13]], [n, b[13]], [n, b[8]]], [[0, 1, 20, 21], [2, 3, 7, 8], [3, 4, 6, 7], [4, 5, 6], [9, 10, 11, 12], [13, 14, 18, 19], [14, 15, 17, 18], [15, 16, 17], [22, 23, 38, 39], [23, 24, 37, 38], [24, 25, 36, 37], [25, 33, 36], [33, 34, 40, 36], [25, 26, 32, 33], [26, 27, 31, 32], [27, 28, 30, 31], [28, 29, 35, 30]], [29, 35, 40]);
                    break;
                case"(":
                    r = .2, e = .2 * l, A([[x[1] + e, b[0] - r], [x[1], b[2]], [x[1], b[12]], [x[1] + e, b[14] + r], [x[0], b[12]], [x[0], b[2]]], [[0, 1, 5], [1, 2, 4, 5], [2, 3, 4]], [5]), i = h / l + .2;
                    break;
                case")":
                    r = .2, e = x[1] - x[0], n = x[1] + .2 * l, A([[x[0], b[0] - r], [n, b[2]], [n, b[12]], [x[0], b[14] + r], [n - e, b[12]], [n - e, b[2]]], [[0, 1, 5], [1, 2, 4, 5], [2, 3, 4]], [5]), i = h / l + .2;
                    break;
                case"*":
                    var j = pd.mapAndConstrainTo(h, .1, .3, .1, b[0]), $ = pd.mapAndConstrainTo(h, .1, .3, .9, b[14]),
                        K = pd.mapAndConstrainTo(l, 0, 5, 0, .2 * l), Z = x[9] - K, Q = x[0] + K,
                        _ = Math.atan((Z - Q) / (($ - j) * l));
                    e = u / Math.sin(_), r = u / Math.cos(_), A([[x[4], j], [x[5], j], [x[5], b[6] - r], [Z - e, j], [Z, j], [Z, j + r], [x[5] + e, b[6]], [Z, b[6]], [Z, b[8]], [x[5] + e, b[8]], [Z, $ - r], [Z, $], [Z - e, $], [x[5], b[8] + r], [x[5], $], [x[4], $], [x[4], b[8] + r], [Q + e, $], [Q, $], [Q, $ - r], [x[4] - e, b[8]], [Q, b[8]], [Q, b[6]], [x[4] - e, b[6]], [Q, j + r], [Q, j], [Q + e, j], [x[4], b[6] - r]], [[0, 1, 2, 27], [2, 3, 5, 6], [3, 4, 5], [6, 7, 8, 9], [9, 10, 12, 13], [10, 11, 12], [13, 14, 15, 16], [16, 17, 19, 20], [17, 18, 19], [20, 21, 22, 23], [23, 24, 26, 27], [24, 25, 26], [27, 16, 20, 23], [2, 13, 16, 27], [2, 6, 9, 13]], [27]);
                    break;
                case"+":
                    var j = pd.mapAndConstrainTo(h, .1, .3, .1, b[0]), $ = pd.mapAndConstrainTo(h, .1, .3, .9, b[14]);
                    e = pd.mapAndConstrainTo(l, 0, 5, 0, .2 * l), A([[x[4], j], [x[5], j], [x[5], b[6]], [n = x[9] - e, b[6]], [n, b[8]], [x[5], b[8]], [x[5], $], [x[4], $], [x[4], b[8]], [n = x[0] + e, b[8]], [n, b[6]], [x[4], b[6]]], [[1, 6, 7, 0], [2, 3, 4, 5], [8, 9, 10, 11]], [11]);
                    break;
                case"-":
                    e = pd.mapAndConstrainTo(l, 0, 5, .1 * l, .3 * l), A([[x[0] + e, b[6]], [n = x[9] - e, b[6]], [n, b[8]], [x[0] + e, b[8]]], [[0, 1, 2, 3]], [3]);
                    break;
                case",":
                    n = u, r = b[1] + pd.mapAndConstrainTo(h, 0, .3, .2, .1), (o || M) && (p = c), A([[x[0], b[0]], [x[0] + u, b[0]], [x[0] + u, b[0] - h], [x[1], b[0]], [x[1], b[1]], [x[0], b[1]]], [[0, 3, 4, 5], [1, 2, 3]], [5]), i = h / l;
                    break;
                case".":
                    n = .25 * l, r = b[1] + pd.mapAndConstrainTo(h, 0, .3, .2, .1), (o || M) && (p = c), A([[x[0], b[0]], [b[1], b[0]], [x[1], b[1]], [x[0], b[1]]], [[0, 1, 2, 3]], [3]), i = h / l;
                    break;
                case"/":
                    r = (e = u / Math.sin(Math.atan(1 / l))) / l, A([[x[0], b[0] - .2], [x[0] + e, b[0] - .2], [x[9], b[14] + .2 - r], [x[9], b[14] + .2], [x[9] - e, b[14] + .2], [x[0], b[0] - .2 + r]], [[0, 1, 5], [1, 2, 4, 5], [2, 3, 4]], [5]);
                    break;
                case"0":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]], [x[3], b[1]], [x[1], b[3]], [x[8], b[11] - h], [x[8], b[3]], [x[6], b[1]], [x[1], b[3] + h], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]]], [[0, 1, 12, 8], [1, 2, 11, 12], [2, 3, 17, 11], [3, 4, 16, 17], [4, 5, 15, 16], [5, 6, 14, 15], [6, 7, 9, 14], [7, 0, 8, 9], [9, 10, 17, 13]], [7, 12, 17]);
                    break;
                case"1":
                    A([[e = .25 * l - u, r = b[0]], [e += h, r], [e, r = b[14]], [e -= h, r], [e -= h, r = b[13]], [e += h, r]], [[0, 1, 2, 3], [3, 4, 5]], [5]), i = .5;
                    break;
                case"2":
                    A([[x[0], b[0]], [x[9], b[0]], [x[9], b[1]], [x[1], b[1]], [x[1], b[4]], [x[3], b[6]], [x[7], b[6]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[11]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]], [x[2], b[8]], [x[0], b[5]]], [[0, 1, 2, 3], [3, 4, 20, 0], [4, 5, 19, 20], [5, 6, 18, 19], [6, 7, 17, 18], [7, 8, 16, 17], [8, 9, 15, 16], [9, 10, 14, 15], [10, 11, 13, 14], [11, 12, 13]], [20]);
                    break;
                case"3":
                    A([[x[0], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[9] - Math.max(0, b[9] - .5), b[7]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[0], b[14]], [x[0] + x[10], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]], [.5 * l, b[8]], [.5 * l, b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[0] + x[10], b[1]]], [[0, 1, 19, 20], [1, 2, 18, 19], [2, 3, 17, 18], [3, 4, 16, 17], [4, 13, 16], [13, 14, 15, 16], [4, 5, 12, 13], [5, 6, 11, 12], [6, 7, 10, 11], [7, 8, 9, 10]], [20]);
                    break;
                case"4":
                    n = .7 * l, e = h / Math.sin(Math.atan(1 / l)), r = h / l, A([[n - u, b[0]], [n + u, b[0]], [n + u, .35 - u], [x[9], .35 - u], [x[9], .35 + u], [n + u, .35 + u], [n + u, b[14]], [n + u - e, b[14]], [x[0], .35 + u], [x[0], .35 - u], [n - u, .35 - u], [x[0] + e, .35 + u], [n - u, b[14] - r], [n - u, .35 + u]], [[0, 1, 6, 12], [7, 8, 11, 6], [9, 10, 13, 8], [2, 3, 4, 5]], [10, 13]);
                    break;
                case"5":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[7], b[8]], [x[1], b[8]], [x[1], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[0], b[14]], [x[0], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[0], b[3]], [x[0], b[2]]], [[0, 1, 14, 15], [1, 2, 13, 14], [2, 3, 12, 13], [3, 4, 11, 12], [4, 5, 10, 11], [5, 6, 9, 10], [6, 7, 8, 9], [0, 15, 16, 18], [16, 17, 18]], [18]);
                    break;
                case"6":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[7], b[8]], [x[1], b[8]], [x[1], b[11]], [x[3], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]], [x[3], b[1]], [x[1], b[3]], [x[1], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]]], [[0, 1, 19, 13], [1, 2, 18, 19], [2, 3, 17, 18], [3, 4, 16, 17], [4, 5, 15, 16], [0, 13, 14, 12], [12, 14, 6, 11], [6, 7, 10, 11], [7, 8, 9, 10]], [12, 19]);
                    break;
                case"7":
                    A([[x[8] - f, b[0]], [x[9] - f, b[0]], [x[9], b[14]], [x[0], b[14]], [x[0] + x[10], b[13]], [x[8], b[13]]], [[0, 1, 2, 5], [2, 3, 4, 5]], [5]);
                    break;
                case"8":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[9] - Math.max(0, b[9] - .5), b[7]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[9]], [x[0] + Math.max(0, b[9] - .5), b[7]], [x[0], b[5]], [x[0], b[2]], [x[3], b[1]], [x[1], b[3]], [x[1], b[4]], [x[3], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[3], b[8]], [x[1], b[10]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]]], [[0, 1, 21, 14], [1, 2, 20, 21], [2, 3, 19, 20], [3, 4, 18, 19], [4, 29, 18], [18, 29, 22, 17], [4, 5, 28, 29], [5, 6, 27, 28], [6, 7, 26, 27], [7, 8, 25, 26], [8, 9, 24, 25], [9, 10, 23, 24], [10, 11, 22, 23], [11, 17, 22], [11, 12, 16, 17], [12, 13, 15, 16], [13, 0, 14, 15]], [13, 21, 29]);
                    break;
                case"9":
                    A([[x[0], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[9]], [x[2], b[6]], [x[8], b[6]], [x[8], b[3]], [x[6], b[1]], [x[0] + x[10], b[1]], [x[3], b[8]], [x[1], b[10]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[8]]], [[0, 1, 11, 12], [1, 2, 10, 11], [2, 3, 18, 10], [3, 4, 17, 18], [4, 5, 16, 17], [5, 6, 15, 16], [6, 7, 14, 15], [7, 8, 13, 14], [8, 9, 19, 13]], [12, 19]);
                    break;
                case":":
                    r = pd.mapAndConstrainTo(h, 0, .3, .2, .05), (o || M) && (p = c), A([[x[0], b[7] - r - h], [x[1], b[7] - r - h], [x[1], b[7] - r], [x[0], b[7] - r], [x[0], b[7] + r], [x[1], b[7] + r], [x[1], b[7] + r + h], [x[0], b[7] + r + h]], [[0, 1, 2, 3], [4, 5, 6, 7]], [3, 7]), i = h / l;
                    break;
                case";":
                    r = pd.mapAndConstrainTo(h, 0, .3, .2, .05), (o || M) && (p = c), A([[x[0], b[7] - r - h], [x[0] + u, b[7] - r - h], [x[0] + u, b[7] - r - h - h], [x[1], b[7] - r - h], [x[1], b[7] - r], [x[0], b[7] - r], [x[0], b[7] + r], [x[1], b[7] + r], [x[1], b[7] + r + h], [x[0], b[7] + r + h]], [[0, 3, 4, 5], [1, 2, 3], [6, 7, 8, 9]], [5, 9]), i = h / l;
                    break;
                case"<":
                    e = h / Math.sin(Math.atan(1 / l)), A([[Y = .75 * l - (r = .5 * e), .1], [Y + e, .1], [(H = .25 * l - r) + e, .5], [Y + e, .9], [Y, .9], [H, .5]], [[1, 2, 5, 0], [2, 3, 4, 5]], [5]);
                    break;
                case"=":
                    e = pd.mapAndConstrainTo(l, 0, 5, 0, .2 * l), r = pd.mapAndConstrainTo(h, 0, .3, .2, .05), A([[x[0] + e, b[7] - r - h], [n = x[9] - e, b[7] - r - h], [n, b[7] - r], [n = x[0] + e, b[7] - r], [n, b[7] + r], [n = x[9] - e, b[7] + r], [n, b[7] + r + h], [x[0] + e, b[7] + r + h]], [[0, 1, 2, 3], [4, 5, 6, 7]], [3, 7]);
                    break;
                case">":
                    e = h / Math.sin(Math.atan(1 / l)), A([[H = .25 * l - (r = .5 * e), .1], [H + e, .1], [(Y = .75 * l - r) + e, .5], [H + e, .9], [H, .9], [Y, .5]], [[1, 2, 5, 0], [2, 3, 4, 5]], [5]);
                    break;
                case"?":
                    r = Math.min(b[6], b[1] + pd.mapAndConstrainTo(h, 0, .3, .2, .1)), A([[x[4], b[0]], [x[5], b[0]], [x[5], b[1]], [x[4], b[1]], [x[4], r], [x[5], r], [x[5], b[6]], [x[7], b[6]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[11]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]], [x[4], b[8]]], [[0, 1, 2, 3], [4, 5, 6, 20], [6, 7, 19, 20], [7, 8, 18, 19], [8, 9, 17, 18], [9, 10, 16, 17], [10, 11, 15, 16], [11, 12, 14, 15], [12, 13, 14]], [3, 20]);
                    break;
                case"@":
                    n = .5 * l, r = pd.mapAndConstrainTo(h, 0, .3, .2, .05);
                    var J = Math.min(n, x[1] + r + h), tt = Math.max(n, x[8] - r - h),
                        et = Math.min(b[7], b[1] + r + h), rt = Math.max(b[7], b[13] - r - h);
                    A([[x[2], b[0]], [x[9], b[0]], [x[9] - x[10], b[1]], [x[3], b[1]], [x[1], b[3]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[1] + r + h], [tt + h, et], [tt + h, rt + h], [J - h, rt + h], [J - h, et - h], [x[9], et - h], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]], [J, et], [J, rt], [tt, rt], [tt, et]], [[0, 1, 2, 3], [3, 4, 19, 0], [4, 5, 18, 19], [5, 6, 17, 18], [6, 7, 16, 17], [7, 8, 15, 16], [8, 9, 14, 15], [9, 20, 13, 14], [10, 11, 22, 23], [11, 12, 21, 22], [12, 13, 20, 21]], [19, 23]);
                    break;
                case"a":
                    p = c;
                case"A":
                    A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [x[8], b[6]], [x[8], b[0]], [x[9], b[0]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[1], b[8]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[8]]], [[4, 5, 6, 14], [6, 7, 13, 14], [7, 8, 12, 13], [8, 9, 11, 12], [9, 0, 1, 11], [2, 3, 15, 10]], [9, 15]);
                    break;
                case"b":
                    p = c;
                case"B":
                    A([[x[0], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[9] - Math.max(0, b[9] - .5), b[7]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[0], b[14]], [x[1], b[1]], [x[1], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[1], b[8]], [x[1], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]]], [[0, 1, 14, 9], [1, 2, 13, 14], [2, 3, 12, 13], [3, 4, 11, 12], [4, 20, 11], [4, 5, 19, 20], [5, 6, 18, 19], [6, 7, 17, 18], [7, 8, 16, 17], [8, 0, 9, 16], [10, 11, 20, 15]], [8, 14, 20]);
                    break;
                case"c":
                    p = c;
                case"C":
                    A([[x[2], b[0]], [x[9], b[0]], [x[9] - x[10], b[1]], [x[3], b[1]], [x[1], b[3]], [x[1], b[11]], [x[3], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]]], [[2, 3, 0, 1], [3, 4, 11, 0], [4, 5, 10, 11], [5, 6, 9, 10], [6, 7, 8, 9]], [11]);
                    break;
                case"d":
                    p = c;
                case"D":
                    A([[x[0], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[12]], [x[7], b[14]], [x[0], b[14]], [x[1], b[1]], [x[1], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[3]], [x[6], b[1]]], [[0, 1, 11, 6], [1, 2, 10, 11], [2, 3, 9, 10], [3, 4, 8, 9], [4, 5, 7, 8], [5, 0, 6, 7]], [5, 11]);
                    break;
                case"e":
                    p = c;
                case"E":
                    A([[x[0], b[0]], [x[9], b[0]], [x[9] - x[10], b[1]], [x[1], b[1]], [x[1], b[6]], [x[5], b[6]], [x[5], b[8]], [x[1], b[8]], [x[1], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[0], b[14]]], [[2, 3, 0, 1], [3, 8, 11, 0], [8, 9, 10, 11], [4, 5, 6, 7]], [11]);
                    break;
                case"f":
                    p = c;
                case"F":
                    A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [x[5], b[6]], [x[5], b[8]], [x[1], b[8]], [x[1], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[0], b[14]]], [[0, 1, 6, 9], [6, 7, 8, 9], [2, 3, 4, 5]], [9]);
                    break;
                case"g":
                    p = c;
                case"G":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[8]], [Math.min(x[8], x[5]), b[8]], [Math.min(x[8], x[5]), b[6]], [x[8], b[6]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[1], b[11]], [x[3], b[13]], [x[9] - x[10], b[13]], [x[9], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]]], [[0, 1, 8, 9], [1, 2, 7, 8], [2, 3, 6, 7], [3, 4, 5, 6], [9, 10, 17, 0], [10, 11, 16, 17], [11, 12, 15, 16], [12, 13, 14, 15]], [17]);
                    break;
                case"h":
                    p = c;
                case"H":
                    A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [x[8], b[6]], [x[8], b[0]], [x[9], b[0]], [x[9], b[14]], [x[8], b[14]], [x[8], b[8]], [x[1], b[8]], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 10, 11], [2, 3, 8, 9], [4, 5, 6, 7]], [11]);
                    break;
                case"i":
                    p = c;
                case"I":
                    n = .5 * Math.max(.5 * l, 1.25 * h), r = Math.min(.5 * (n - u), h), A([[e = n - u - r, b[0]], [e += h + r + r, b[0]], [e, b[1]], [e -= r, b[1]], [e, b[13]], [e += r, b[13]], [e, b[14]], [e -= h + r + r, b[14]], [e, b[13]], [e += r, b[13]], [e, b[1]], [e -= r, b[1]]], [[0, 1, 2, 11], [3, 4, 9, 10], [6, 7, 8, 5]], [11]), i = Math.max(.5, 1.25 * h / l);
                    break;
                case"j":
                    p = c;
                case"J":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[14]], [x[4], b[14]], [x[4], b[13]], [x[8], b[13]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[0], b[3]], [x[0], b[2]]], [[0, 1, 8, 9], [1, 2, 7, 8], [2, 3, 6, 7], [3, 4, 5, 6], [9, 10, 12, 0], [10, 11, 12]], [12]);
                    break;
                case"k":
                    p = c;
                case"K":
                    nt = .5 / (l - (n = .5 * l));
                    e = h / Math.sin(Math.atan(nt)), r = (.5 - u) / nt, x[9] - e - r < x[1] && (n = x[1] + (e - h / (2 * nt)), r = x[9] - e - x[1]), A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [x[9] - e - r, b[6]], [Math.max(x[1], x[9] - e), b[0]], [x[9], b[0]], [n, b[7]], [x[9], b[14]], [Math.max(x[1], x[9] - e), b[14]], [x[9] - e - r, b[8]], [x[1], b[8]], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 11, 12], [2, 3, 9, 10], [3, 6, 9], [3, 4, 5, 6], [6, 7, 8, 9]], [12]);
                    break;
                case"l":
                    p = c;
                case"L":
                    A([[x[0], b[0]], [x[9], b[0]], [x[9] - x[10], b[1]], [x[1], b[1]], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 2, 3], [3, 4, 5, 0]], [5]);
                    break;
                case"m":
                    p = c;
                case"M":
                    n = .5 * l, e = Math.atan((n - h) / (.5 - u)), r = pd.constrainTo(h / Math.sin(e), 0, .75), A([[x[0], b[0]], [x[1], b[0]], [x[1], b[14] - r], [n, b[8] > r ? b[8] - r : b[0]], [x[8], b[14] - r], [x[8], b[0]], [x[9], b[0]], [x[9], b[14]], [x[8], b[14]], [n, b[8] > r ? b[8] : b[0] + r], [x[1], b[14]], [x[0], b[14]]], [[1, 10, 11, 0], [2, 3, 9, 10], [3, 4, 8, 9], [8, 5, 6, 7]], [11]);
                    break;
                case"n":
                    p = c;
                case"N":
                    e = Math.atan(1 / l), r = h / Math.cos(e), A([[x[0], b[0]], [x[1], b[0]], [x[1], b[14] - r], [x[8], b[0]], [x[9], b[0]], [x[9], b[14]], [x[8], b[14]], [x[8], b[0] + r], [x[1], b[14]], [x[0], b[14]]], [[1, 8, 9, 0], [2, 3, 7, 8], [4, 5, 6, 3]], [9]);
                    break;
                case"o":
                    p = c;
                case"O":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]], [x[3], b[1]], [x[1], b[3]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[3]], [x[6], b[1]]], [[0, 1, 15, 8], [1, 2, 14, 15], [2, 3, 13, 14], [3, 4, 12, 13], [4, 5, 11, 12], [5, 6, 10, 11], [6, 7, 9, 10], [7, 0, 8, 9]], [7, 15]);
                    break;
                case"p":
                    p = c;
                case"P":
                    A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [x[7], b[6]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[0], b[14]], [x[1], b[8]], [x[1], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]]], [[0, 1, 9, 7], [2, 3, 13, 8], [3, 4, 12, 13], [4, 5, 11, 12], [5, 6, 10, 11], [6, 7, 9, 10]], [7, 13]);
                    break;
                case"q":
                    p = c;
                case"Q":
                    e = .1 * l, A([[x[2], b[0]], [x[9], b[0]], [Math.max(x[9] - e, x[9] - x[10]), b[1]], [x[9] - e, b[1]], [x[9] - e, b[12]], [x[7] - e, b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[2]], [x[3], b[1]], [x[1], b[3]], [x[1], b[11]], [x[3], b[13]], [x[6] - e, b[13]], [x[8] - e, b[11]], [x[8] - e, b[1]]], [[0, 1, 2, 9], [3, 4, 14, 15], [4, 5, 13, 14], [5, 6, 12, 13], [6, 7, 11, 12], [7, 8, 10, 11], [8, 0, 9, 10]], [8, 15]);
                    break;
                case"r":
                    p = c;
                case"R":
                    var nt = (.5 - u) / (l - (n = .6 * l + u));
                    e = h / Math.sin(Math.atan(nt)), r = (.5 - u) / nt, x[9] - e - r < x[1] && (n = x[1] + (e - h / (2 * nt)), r = x[9] - e - x[1]), A([[x[0], b[0]], [x[1], b[0]], [x[1], b[6]], [Math.max(x[1], n - e), b[6]], [Math.max(x[1], x[9] - e), b[0]], [x[9], b[0]], [n > x[7] ? x[7] : n, b[6]], [x[7], b[6]], [x[9], b[9]], [x[9], b[12]], [x[7], b[14]], [x[0], b[14]], [x[1], b[8]], [x[1], b[13]], [x[6], b[13]], [x[8], b[11]], [x[8], b[10]], [x[6], b[8]]], [[0, 1, 13, 11], [2, 7, 17, 12], [3, 4, 5, 6], [7, 8, 16, 17], [8, 9, 15, 16], [9, 10, 14, 15], [10, 11, 13, 14]], [11, 17]);
                    break;
                case"s":
                    p = c;
                case"S":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[5]], [x[7], b[8]], [x[3], b[8]], [x[1], b[10]], [x[1], b[11]], [x[3], b[13]], [x[6], b[13]], [x[8], b[11]], [x[9], b[11]], [x[9], b[12]], [x[7], b[14]], [x[2], b[14]], [x[0], b[12]], [x[0], b[9]], [x[2], b[6]], [x[6], b[6]], [x[8], b[4]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[0], b[3]], [x[0], b[2]]], [[0, 1, 21, 22], [1, 2, 20, 21], [2, 3, 19, 20], [3, 4, 18, 19], [4, 5, 17, 18], [5, 6, 16, 17], [6, 7, 15, 16], [7, 8, 14, 15], [8, 9, 13, 14], [9, 10, 12, 13], [10, 11, 12], [22, 23, 25, 0], [23, 24, 25]], [25]);
                    break;
                case"t":
                    p = c;
                case"T":
                    A([[x[4], b[0]], [x[5], b[0]], [x[5], b[13]], [x[9], b[13]], [x[9], b[14]], [x[0], b[14]], [x[0], b[13]], [x[4], b[13]]], [[0, 1, 2, 7], [4, 5, 6, 3]], [7]);
                    break;
                case"u":
                    p = c;
                case"U":
                    A([[x[2], b[0]], [x[7], b[0]], [x[9], b[2]], [x[9], b[14]], [x[8], b[14] - x[10]], [x[8], b[3]], [x[6], b[1]], [x[3], b[1]], [x[1], b[3]], [x[1], b[14] - x[10]], [x[0], b[14]], [x[0], b[2]]], [[0, 1, 6, 7], [1, 2, 5, 6], [2, 3, 4, 5], [7, 8, 11, 0], [8, 9, 10, 11]], [11]);
                    break;
                case"v":
                    p = c;
                case"V":
                    n = .5 * l;
                    _ = Math.atan(n);
                    e = Math.min(n, h / Math.cos(_)), r = Math.min(b[13], h / Math.sin(_)), A([[n, b[0]], [x[9], b[14]], [x[9] - e, b[14]], [n, b[0] + r], [x[0] + e, b[14]], [x[0], b[14]]], [[0, 1, 2, 3], [0, 3, 4, 5]], [5]);
                    break;
                case"w":
                    p = c;
                case"W":
                    n = .5 * l, e = Math.atan((n - h) / (.5 - u));
                    var it = (r = pd.constrainTo(h / Math.sin(e), 0, .75)) * f;
                    A([[x[0] + f, b[0]], [Math.min(n, x[1] + f), b[0]], [n, b[8] > r ? b[6] : b[14] - r], [Math.max(n, x[8] - f), b[0]], [x[9] - f, b[0]], [x[9], b[14]], [x[8], b[14]], [Math.max(n, x[8] - f) + it, b[0] + r], [n, b[8] > r ? b[6] + r : b[14]], [Math.min(n, x[1] + f) - it, b[0] + r], [x[1], b[14]], [x[0], b[14]]], [[0, 1, 9], [0, 9, 11], [9, 10, 11], [1, 2, 8, 9], [2, 3, 7, 8], [3, 4, 7], [4, 7, 5], [5, 6, 7]], [11]);
                    break;
                case"x":
                    p = c;
                case"X":
                    n = .5 * l, r = (e = u / Math.sin(Math.atan(1 / l))) / l, A([[x[0], b[0]], [x[0] + e, b[0]], [n, b[7] - r], [x[9] - e, b[0]], [x[9], b[0]], [x[9], b[0] + r], [n + e, b[7]], [x[9], b[14] - r], [x[9], b[14]], [x[9] - e, b[14]], [n, b[7] + r], [x[0] + e, b[14]], [x[0], b[14]], [x[0], b[14] - r], [n - e, b[7]], [x[0], b[0] + r]], [[0, 1, 15], [1, 2, 14, 15], [2, 3, 5, 6], [3, 4, 5], [6, 7, 9, 10], [7, 8, 9], [10, 11, 13, 14], [11, 12, 13], [2, 6, 10, 14]], [15]);
                    break;
                case"y":
                    p = c;
                case"Y":
                    n = .5 * l;
                    var at = 1 / l * (x[4] - x[0]);
                    r = (e = u / Math.sin(Math.atan(1 / l))) / l, A([[x[4], b[0]], [x[5], b[0]], [x[5], b[14] - at - r], [x[9], b[14] - r], [x[9], b[14]], [x[9] - e, b[14]], [n, b[7] + r], [x[0] + e, b[14]], [x[0], b[14]], [x[0], b[14] - r], [x[4], b[14] - at - r]], [[2, 6, 10], [0, 1, 2, 10], [2, 3, 5, 6], [3, 4, 5], [6, 7, 9, 10], [7, 8, 9]], [10]);
                    break;
                case"z":
                    p = c;
                case"Z":
                    e = Math.atan(1 / l), r = h / Math.sin(e), A([[x[0], b[0]], [x[9], b[0]], [x[9], b[1]], [x[0] + r, b[1]], [x[9], b[13]], [x[9], b[14]], [x[0], b[14]], [x[0], b[13]], [x[9] - r, b[13]], [x[0], b[1]]], [[0, 1, 2, 9], [3, 4, 8, 9], [5, 6, 7, 4]], [9]);
                    break;
                case"\\":
                    r = (e = u / Math.sin(Math.atan(1 / l))) / l, A([[x[9] - e, b[0] - .2], [x[9], b[0] - .2], [x[9], b[0] - .2 + r], [x[0] + e, b[14] + .2], [x[0], b[14] + .2], [x[0], b[14] + .2 - r]], [[0, 1, 2], [2, 3, 5, 0], [3, 4, 5]], [5]);
                    break;
                case"[":
                    r = .2, e = .2 * l, A([[x[0], b[0] - r], [x[1] + e, b[0] - r], [x[1] + e, b[1] - r], [x[1], b[1] - r], [x[1], b[13] + r], [x[1] + e, b[13] + r], [x[1] + e, b[14] + r], [x[0], b[14] + r]], [[0, 1, 2, 3], [3, 4, 7, 0], [4, 5, 6, 7]], [7]), i = h / l + .2;
                    break;
                case"]":
                    r = .2, e = x[1] - x[0], n = x[1] + .2 * l, A([[x[0], b[0] - r], [n, b[0] - r], [n, b[14] + r], [x[0], b[14] + r], [x[0], b[13] + r], [n - e, b[13] + r], [n - e, b[1] - r], [x[0], b[1] - r]], [[0, 1, 6, 7], [1, 2, 5, 6], [2, 3, 4, 5]], [7]), i = h / l + .2;
                    break;
                case"^":
                    n = .5 * l;
                    _ = Math.atan(l);
                    e = h / Math.cos(_), r = h / Math.sin(_), A([[x[0], b[7]], [x[0] + e, b[7]], [n, Math.max(b[7], b[14] - r)], [x[9] - e, b[7]], [x[9], b[7]], [n, b[14]]], [[1, 2, 5, 0], [2, 3, 4, 5]], [5]);
                    break;
                case"_":
                    n = .25 * l, r = b[0] - u, A([[x[0], b[0]], [x[9], b[0]], [x[9], b[1]], [x[0], b[1]]], [[0, 1, 2, 3]], [3]);
                    break;
                case"`":
                    n = .25 * l;
                    var X = Math.min(.15, h), W = pd.mapAndConstrainTo(h, 0, .2, .05, .15);
                    r = b[14] - 1.5 * W, A([[n - (e = 1.5 * W), r - e], [n + e, r - e], [n + e, r + e], [n - e, r + e], [n - (e -= X), r - e], [n - e, r + e], [n + e, r + e], [n + e, r - e]], [[0, 1, 7, 4], [1, 2, 6, 7], [2, 3, 5, 6], [3, 0, 4, 5]], [3, 7]), i = .5;
                    break;
                case"{":
                    r = .2, e = pd.mapAndConstrainTo(l, 0, 5, .25 * l, .1 * l), e = h + Math.max(.1 / l, e), n = .25 * l - .5 * e + .5 * Math.max(.1, h), A([[n + e, b[0] - r], [n + h, b[2]], [n + h, b[5]], [n - Math.max(.1, h) + h, b[7]], [n + h, b[9]], [n + h, b[12]], [n + e, b[14] + r], [n, b[12]], [n, b[10]], [n - Math.max(.1, h), b[7]], [n, b[4]], [n, b[2]]], [[0, 1, 11], [1, 2, 10, 11], [2, 3, 9, 10], [3, 4, 8, 9], [4, 5, 7, 8], [5, 6, 7]], [11]), i = .5;
                    break;
                case"|":
                    r = .2, A([[(n = .25 * l) - u, b[0] - r], [n + u, b[0] - r], [n + u, b[14] + r], [n - u, b[14] + r]], [[0, 1, 2, 3]], [3]), i = .5;
                    break;
                case"}":
                    r = .2, e = pd.mapAndConstrainTo(l, 0, 5, .25 * l, .1 * l), e = h + Math.max(.1 / l, e), n = .25 * l + .5 * e - .5 * Math.max(.1, h), A([[n - e, b[0] - r], [n, b[2]], [n, b[4]], [n + Math.max(.1, h), b[7]], [n, b[10]], [n, b[12]], [n - e, b[14] + r], [n - h, b[12]], [n - h, b[9]], [n + Math.max(.1, h) - h, b[7]], [n - h, b[5]], [n - h, b[2]]], [[0, 1, 11], [1, 2, 10, 11], [2, 3, 9, 10], [3, 4, 8, 9], [4, 5, 7, 8], [5, 6, 7]], [11]), i = .5;
                    break;
                case"~":
                    e = pd.mapAndConstrainTo(l, 0, 5, 0, .2 * l);
                    var st = .333333333 * (x[9] - x[0] - e - e), H = x[0] + e + st, Y = x[9] - e - st;
                    A([[x[0] + e, .25], [H, .6 - u], [Y, .4 - u], [x[9] - e, .75], [Y, .4 + u], [H, .6 + u]], [[0, 1, 5], [1, 2, 4, 5], [2, 3, 4]], [5])
            }
            S += i * l * p, S += M ? y * c : y * p
        }
        m = D, g = T
    }

    var s = null, o = null, d = null, h = .1, u = .5 * h, c = .8, l = 1.25, p = 1, f = .1, m = 0, g = 0, v = .8,
        y = .25, M = .5, x = null, b = null, D = 0, T = 0, w = !1, O = 0, A = null;
    pd3D.FontInstance = function (t) {
        t = t || {}, this.isTriangulated = !0, this._width = pd.toNumber(t.width, .1), this._aspectRatio = pd.toNumber(t.aspectRatio, 1.25), this._chamfer = pd.toNumber(t.chamfer, .1), this._italic = pd.toNumber(t.italic, 0), this._skew = pd.toNumber(t.skew, 0), this._weight = pd.toNumber(t.weight, 0), this._weight > pd.Const.EPSILON ? this._width = this._weight / 900 * .35 : this._weight = Math.round(this._width / .35 * 900), this._extrusion = pd.toNumber(t.extrusion, 0), this._updateMetrics = !0, this._metrics = [[], []], this._letterSpacing = pd.toNumber(t.letterSpacing, .25), this._wordSpacing = pd.toNumber(t.wordSpacing, .8), this._lineSpacing = pd.toNumber(t.lineSpacing, .5), this._smallCapsRatio = pd.toNumber(t.smallCapsRatio, .8), this._includeOutline = !1;
        var e = null, r = null, n = null;
        this.maxTextWidth = 0, this.blockHeight = 0, this.blockWidth = 0, this.setSize = function (t) {
            return Array.isArray(t) ? n = pd3D.Matrix.scale(+t[0] || 1, +t[1] || 1, +t[2] || 1, n) : (t = +t || 0, n = pd.closeTo(t, 0) ? null : pd3D.Matrix.scale(t, t, t, n)), this
        }, this.setRotationPolar = function (t, e) {
            return pd.closeTo(t, 0) ? r = pd.closeTo(e, 0) ? null : pd3D.Matrix.rotate(e, 0, 1, 0, r) : (r = pd3D.Matrix.rotate(t, 0, 0, 1, r), pd.closeTo(e, 0) || r.multiplyBy(pd3D.Matrix.rotate(e, 0, 1, 0))), this
        }, this.setRotation = function (t, e, n, i) {
            return r = pd.closeTo(t, 0) ? null : pd3D.Matrix.rotate(t, e, n, i, r), this
        }, this.addRotation = function (t, e, n, i) {
            return pd.closeTo(t, 0) || (r ? r.multiplyBy(pd3D.Matrix.rotate(t, e, n, i)) : r = pd3D.Matrix.rotate(t, e, n, i, r)), this
        }, this.clearRotations = function () {
            return r = null, this
        }, this.drawText = function (t, i, a, s, o) {
            return e = pd3D.Matrix.translate(i[0], i[1], i[2], e), r && e.multiplyBy(r), n && e.multiplyBy(n), this.addText(t, s || pd.Align.CENTER, o || pd.Align.CENTER, e, a), this
        }
    }, pd3D.FontInstance.prototype.italicSlant = function (t) {
        return arguments.length ? (this._italic = pd.constrainTo(parseFloat(t), -1, 1), this) : this._italic
    }, pd3D.FontInstance.prototype.verticalSkew = function (t) {
        return arguments.length ? (this._skew = pd.constrainTo(parseFloat(t), -1, 1), this) : this._skew
    }, pd3D.FontInstance.prototype.averageKerning = function (t) {
        return arguments.length ? (this._letterSpacing = pd.constrainTo(parseFloat(t) - 1, 0, 10), this) : this._letterSpacing + 1
    }, pd3D.FontInstance.prototype.letterSpacing = function (t) {
        return arguments.length ? (this._letterSpacing = pd.constrainTo(parseFloat(t), 0, 10), this) : this._letterSpacing
    }, pd3D.FontInstance.prototype.wordSpacing = function (t) {
        return arguments.length ? (this._wordSpacing = pd.constrainTo(parseFloat(t), 0, 10), this) : this._wordSpacing
    }, pd3D.FontInstance.prototype.lineSpacing = function (t) {
        return arguments.length ? (this._lineSpacing = pd.constrainTo(parseFloat(t), 0, 10), this) : this._lineSpacing
    }, pd3D.FontInstance.prototype.smallCapsRatio = function (t) {
        return arguments.length ? (this._smallCapsRatio = pd.constrainTo(parseFloat(t), .1, 1), this) : this._smallCapsRatio
    }, pd3D.FontInstance.prototype.aspectRatio = function (t, e, r) {
        return arguments.length ? (this._aspectRatio = pd.constrainTo(t, .1, 10), e > pd.Const.EPSILON && (this._letterSpacing = pd.constrainTo(e - 1, 0, 10)), r > pd.Const.EPSILON && (this._wordSpacing = pd.constrainTo(r, 0, 10)), this._updateMetrics = !0, this) : this._aspectRatio
    }, pd3D.FontInstance.prototype.weight = function (t) {
        if (!arguments.length) return this._weight;
        var e = pd.constrainTo(parseFloat(t), 0, 900);
        return pd.closeTo(this._weight, e, .5) || (this._width = 333333e-9 * e, this._weight = Math.round(e), this._updateMetrics = !0), this
    }, pd3D.FontInstance.prototype.chamfer = function (t) {
        if (!arguments.length) return this._chamfer / .275 * 1e3;
        var e = 275e-6 * pd.constrainTo(parseFloat(t), 1, 1e3);
        return pd.closeTo(this._chamfer, e, .001) || (this._updateMetrics = !0, this._chamfer = e), this
    }, pd3D.FontInstance.prototype.includeOutline = function (t) {
        return arguments.length ? (this._includeOutline = !!t, this) : this._includeOutline
    }, pd3D.FontInstance.prototype.extrusion = function (t) {
        return arguments.length ? (this._extrusion = pd.toNumber(t, 0), this) : this._extrusion
    }, pd3D.FontInstance.prototype.resetMetrics = function () {
        return this._aspectRatio = pd.constrainTo(this._aspectRatio, .1, 10), this._letterSpacing = .25, this._wordSpacing = .8, this._lineSpacing = .5, this._italic = 0, this._skew = 0, this._calculateFontVertices(), this
    }, pd3D.FontInstance.prototype._calculateFontVertices = function () {
        var t = this._width, e = this._chamfer, r = this._aspectRatio, n = t / 2.414213, i = .5 * r,
            a = .5 * (t = Math.min(i, t)), s = t + .01, o = this._metrics[0], d = this._metrics[1];
        o[0] = 0, o[1] = t, o[2] = e, o[3] = Math.max(t, e + n), o[4] = i - a, o[5] = i + a, o[6] = Math.max(s, Math.min(r - t, r - e - n)), o[7] = Math.max(s, r - e), o[8] = Math.max(s, r - t), o[9] = r, o[10] = pd.mapAndConstrainTo(e, 0, t, 0, t), d[0] = 0, d[1] = t, d[2] = e, d[3] = Math.max(t, e + n), d[4] = .5 + a - e - n, d[5] = Math.min(.5, .5 + a - e), d[6] = .5 - a, d[7] = .5, d[8] = .5 + a, d[9] = Math.max(.5, .5 - a + e), d[10] = Math.max(d[8], .5 - a + e + n), d[11] = Math.min(1 - t, 1 - e - n), d[12] = 1 - e, d[13] = 1 - t, d[14] = 1, d[4] = Math.min(d[4], d[6]), d[3] > d[4] && (d[3] = d[4] = .5 * (d[3] + d[4])), d[10] > d[11] && (d[10] = d[11] = .5 * (d[10] + d[11])), this._updateMetrics = !1
    }, pd3D.FontInstance.prototype.getLineWidth = function (t) {
        var e, r, n = 0, i = 0, a = this._aspectRatio, s = this._width, o = this._smallCapsRatio,
            d = this._letterSpacing * a, h = this._wordSpacing, u = !1, c = !1, l = !1, p = t.length, f = !0;
        p > 0 && (r = t.charCodeAt(0)) >= 97 && r < 123 && (l = !0);
        for (var m = 0; m < p; m++) {
            switch (i = e = 1, u = c, c = l, m < p - 1 ? l = (r = t.charCodeAt(m + 1)) >= 97 && r < 123 : (l = !1, f = !1), t.charAt(m)) {
                default:
                    c && (e = o);
                    break;
                case"i":
                    e = o;
                case"I":
                    i = Math.max(.5, 1.25 * s / a);
                    break;
                case"\b":
                case"\f":
                    i = e = 0;
                    break;
                case" ":
                    i = h;
                    break;
                case"1":
                case"{":
                case"}":
                    i = .5;
                    break;
                case"(":
                case")":
                case"[":
                case"]":
                    i = s / a + .2;
                    break;
                case'"':
                    i = s / a * 2 + .1;
                    break;
                case"|":
                case"`":
                    i = .5;
                    break;
                case",":
                case".":
                case":":
                case";":
                    (u || l) && (e = o);
                case"!":
                case"'":
                    i = s / a
            }
            n += i * a * e, f && (n += l ? d * o : d * e)
        }
        return n
    }, pd3D.FontInstance.prototype.getTextWidth = function (t) {
        for (var e, r = t.match(/[^\r\n]+/g), n = 0, i = 0, a = r.length; i < a; ++i) n < (e = this.getLineWidth(r[i].trim())) && (n = e);
        return n
    }, pd3D.FontInstance.prototype.addText = function (t, e, p, D, T) {
        if (this._updateMetrics && this._calculateFontVertices(), !t || t.length < 1) return T;
        D = D || new pd3D.Matrix, _.init(D), h = this._width, u = .5 * h, c = this._smallCapsRatio, l = this._aspectRatio, f = this._chamfer, m = this._italic, g = this._skew, M = this._lineSpacing, v = this._wordSpacing, y = this._letterSpacing * l, w = this._includeOutline && T.hasLines, O = this._extrusion, x = this._metrics[0], b = this._metrics[1], s = T || new pd3D.Mesh, o = s.defaultColor, d = s.defaultLineColor, w && s.hasVertexColors && s.defaultLineColor != s.defaultColor || (d = null), s.triangles || s.addIndexBuffer("triangles"), A = O > pd.Const.EPSILON ? s.hasVertexNormals ? i : n : r;
        var C, S, I, k = t.match(/[^\r\n]+/g), N = k ? k.length : 0, V = 0, E = Math.max(1, N + (N - 1) * M);
        switch (p) {
            default:
            case pd.Align.BASELINE:
                break;
            case pd.Align.TOP:
            case pd.Align.TOP_LEFT:
            case pd.Align.TOP_RIGHT:
                N < 2 && (E += .5 * M), _.multiplyBy(pd3D.Matrix.translate(0, -1, 0));
                break;
            case pd.Align.CENTER:
                _.multiplyBy(pd3D.Matrix.translate(0, .5 * E - 1, 0));
                break;
            case pd.Align.BOTTOM:
            case pd.Align.BOTTOM_LEFT:
            case pd.Align.BOTTOM_RIGHT:
                N < 2 && (E += .5 * M), _.multiplyBy(pd3D.Matrix.translate(0, -1 + E, 0))
        }
        for (var L = 0; L < N; ++L) {
            switch (C = k[L].trim(), S = this.getLineWidth(C), I = 0, V < S && (V = S), e) {
                default:
                    I = .5 * -S;
                    break;
                case pd.Align.LEFT:
                case pd.Align.TOP_LEFT:
                case pd.Align.BOTTOM_LEFT:
                case pd.Align.BASELINE:
                    break;
                case pd.Align.RIGHT:
                case pd.Align.TOP_RIGHT:
                case pd.Align.BOTTOM_RIGHT:
                    I = -S
            }
            pd.closeTo(I, 0) ? a(C) : (_.multiplyBy(pd3D.Matrix.translate(I, 0, 0)), a(C), _.multiplyBy(pd3D.Matrix.translate(-I, 0, 0))), k.length > 1 && _.multiplyBy(pd3D.Matrix.translate(0, -(1 + M), 0))
        }
        return this.maxTextWidth < V && (this.maxTextWidth = V), this.blockHeight = E, this.blockWidth = V, s.hasVertexColors && s.color(o), s
    };
    var C = new pd3D.Vector, _ = new pd3D.Matrix, S = 0;
    pd3D.Font = new pd3D.FontInstance
}();
var pdDOM = pdDOM || {};
!function () {
    function t(t) {
        var e, r = t.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        return /trident/i.test(r[1]) ? (e = /\brv[ :]+(\d+)/g.exec(t) || [], {
            name: "IE",
            version: e[1] || ""
        }) : "Chrome" === r[1] && null != (e = t.match(/\b(OPR|Edge)\/(\d+)/)) ? {
            name: e[1].replace("OPR", "Opera"),
            version: e[2]
        } : (r = r[2] ? [r[1], r[2]] : [navigator.appName, navigator.appVersion, "-?"], null != (e = t.match(/version\/(\d+)/i)) && r.splice(1, 1, e[1]), {
            name: r[0],
            version: r[1]
        })
    }

    function e(t, e, r) {
        for (var n = 0; n < g.length; n++) g[n] || (e = e.toLowerCase()), t.addEventListener(g[n] + e, r, !1)
    }

    function r(t, e, r) {
        for (var n = 0; n < g.length; n++) g[n] || (e = e.toLowerCase()), t.removeEventListener(g[n] + e, r)
    }

    function n(t) {
        return t > .206893034 ? t * t * t : (t - 4 / 29) / 7.787037
    }

    function i(t) {
        return t > .008856 ? Math.pow(t, 1 / 3) : 7.787037 * t + 4 / 29
    }

    function a(t) {
        return Math.round(255 * (t <= .00304 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055))
    }

    function s(t) {
        return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
    }

    function o(t) {
        var e = s(255 * t[0]), r = s(255 * t[1]), n = s(255 * t[2]),
            a = i((.4124564 * e + .3575761 * r + .1804375 * n) / .95047),
            o = i(.2126729 * e + .7151522 * r + .072175 * n);
        return [116 * o - 16, 500 * (a - o), 200 * (o - i((.0193339 * e + .119192 * r + .9503041 * n) / 1.08883))]
    }

    function d(t) {
        var e = (t[0] + 16) / 116, r = e + t[1] / 500, i = e - t[2] / 200;
        return r = .95047 * n(r), e = n(e), i = 1.08883 * n(i), [a(3.2404542 * r - 1.5371385 * e - .4985314 * i) / 255, a(-.969266 * r + 1.8760108 * e + .041556 * i) / 255, a(.0556434 * r - .2040259 * e + 1.0572252 * i) / 255]
    }

    function h(t, e, r, n) {
        var i = 1 - r, a = o(t), s = o(e), h = d([i * a[0] + r * s[0], i * a[1] + r * s[1], i * a[2] + r * s[2]]);
        return n = n || [], n[0] = pd.constrainTo(h[0], 0, 1), n[1] = pd.constrainTo(h[1], 0, 1), n[2] = pd.constrainTo(h[2], 0, 1), n[3] = i * t[3] + r * e[3], n
    }

    function u(t, e, r, n) {
        var i = 1 - r, a = [+t[0] || 0, +t[1] || 0, +t[2] || 0], s = [+e[0] || 0, +e[1] || 0, +e[2] || 0];
        return n = n || [], n[0] = i * a[0] + r * s[0], n[1] = i * a[1] + r * s[1], n[2] = i * a[2] + r * s[2], n
    }

    function c(t, e) {
        var r = [];
        t = t || [], Array.isArray(t) && (t[0] = +t[0] || 0, t[1] = +t[1] || 0, t[2] = +t[2] || 0, t[3] = pd.toNumber(t[3], 1)), e = e || [], Array.isArray(t) && (e[0] = +e[0] || 0, e[1] = +e[1] || 0, e[2] = +e[2] || 0, e[3] = pd.toNumber(e[3], 1)), this.interpolate = function (n) {
            return 1 === n ? e : h(t, e, n, r)
        }
    }

    function l(t, e) {
        var r = [];
        t = t || [], Array.isArray(t) && (t[0] = +t[0] || 0, t[1] = +t[1] || 0, t[2] = +t[2] || 0), e = e || [], Array.isArray(t) && (e[0] = +e[0] || 0, e[1] = +e[1] || 0, e[2] = +e[2] || 0), this.interpolate = function (n) {
            return 1 === n ? e : u(t, e, n, r)
        }
    }

    function p(t, e) {
        e = pd.toNumber(e, 1), t = pd.toNumber(t, 0), this.interpolate = function (r) {
            return (1 - r) * t + r * e
        }
    }

    pdDOM.mobileOS = "", pdDOM.isMobile = !1, pdDOM.devicePixelRatio = window.devicePixelRatio || 1, pdDOM.pageScale = 1, function () {
        var e = navigator.userAgent || navigator.vendor || window.opera;
        if (pdDOM.mobileOS = e.match(/(iPhone|iPod|iPad|Android|BlackBerry)/) || [], pdDOM.isMobile = pdDOM.mobileOS.length > 0, pdDOM.isMobile) {
            if (/windows phone/i.test(e)) return void(pdDOM.isWindowsPhone = !0);
            if (/android/i.test(e)) return void(pdDOM.isAndroid = !0);
            if (/iPad|iPhone|iPod/.test(e) && !window.MSStream) pdDOM.isiOS = !0, /iPhone/.test(e) && (pdDOM.isiPhone = !0)
        } else {
            var r = e.toLowerCase();
            if (r.indexOf("macintosh") >= 0 && (pdDOM.isMacintosh = !0), navigator.vendor && navigator.vendor.indexOf("Apple") >= 0 && navigator.userAgent && !navigator.userAgent.match("CriOS")) {
                var n = t(r), i = parseFloat(n.version);
                return pdDOM.isSafariOldVersion = i < 11, void(pdDOM.isSafari = !0)
            }
            if (r.indexOf("firefox") >= 0) return void(pdDOM.isFirefox = !0);
            if (r.indexOf("windows") >= 0) pdDOM.isWindows10 = r.indexOf("10.") >= 0, pdDOM.isWindows = !0
        }
    }();
    var f = !0, m = null;
    pdDOM.checkForSafariCanvasFix = function (t, e, r) {
        return pdDOM.isSafariOldVersion && window.devicePixelRatio > 1.5 && (t > 1441 || e > 901 ? (f && r && (null == m ? m = r({
            content: "<strong>WARNING</strong>: WebGL canvas resolution reduced as Safari really struggles<br />on a scaled Retina display when sized greater than 1440x900 pixels.",
            style: "primary",
            timeout: 12e3
        }) : m.hasClass("snackbar-opened") || m.snackbar("show")), pdDOM.devicePixelRatio = 1, f = !1) : (r && m && m.hasClass("snackbar-opened") && m.snackbar("hide"), pdDOM.devicePixelRatio = window.devicePixelRatio, f = !0)), pdDOM
    }, pdDOM.getClientWidth = function () {
        var t = window.innerWidth, e = document.documentElement.clientWidth;
        return e < t ? t : e
    }, pdDOM.getClientHeight = function () {
        var t = window.innerHeight, e = document.documentElement.clientHeight;
        return e < t ? t : e
    }, pdDOM.setFullSizeCanvasByDevice = function (t, e, r, n) {
        return pdDOM.checkForSafariCanvasFix(e, r, n), t && t.canvas && (t.canvas.width = e * pdDOM.devicePixelRatio, t.canvas.height = r * pdDOM.devicePixelRatio, t.viewport(0, 0, t.canvas.width, t.canvas.height), t.canvas.style.height = r, t.canvas.style.width = e), pdDOM
    }, pdDOM.applyFirefoxPageScaleFix = function (t, e, r, n) {
        return t && pdDOM.isFirefox && (t.css({
            "-moz-transform": "scale(" + n + ")",
            "-moz-transform-origin": "0 0"
        }), n < 1 ? t.css({
            width: e * pdDOM.pageScale + "px",
            height: r * pdDOM.pageScale + "px"
        }) : t.css({width: "100%", height: "100%"})), pdDOM
    }, pdDOM.getParamString = function (t, e, r) {
        var n = [];
        for (var i in t) n.push(encodeURIComponent(r ? i.toUpperCase() : i) + "=" + encodeURIComponent(t[i]));
        return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&")
    }, pdDOM.getUrlParams = function (t) {
        var e = {};
        return (t = t || window.location.search).replace(/[?&]+([^=&]+)=([^&]*)/gi, function (t, r, n) {
            e[r] = n
        }), e
    }, pdDOM.hasClass = function (t, e) {
        var r = new RegExp("(\\s|^)" + e + "(\\s|$)");
        if (t instanceof SVGElement) {
            var n = t.getAttribute("class");
            return !!n && !!n.match(r)
        }
        return !!t.className.match(r)
    }, pdDOM.addClass = function (t, e, r) {
        r = pd.toBoolean(r, !1), pd.isArray(e) && e.forEach(function (e) {
            pdDOM.addClass(t, e, r)
        });
        var n = t.getAttribute("class"), i = new RegExp("(\\s|^)" + e + "(\\s|$)");
        return n && n.match(i) || (t instanceof SVGElement ? (n = r ? n.length > 0 ? e + " " + n : e : n.length > 0 ? n + " " + e : e, t.setAttribute("class", n)) : t.className = r ? t.className.length > 0 ? e + " " + t.className : e : t.className.length > 0 ? t.className + " " + e : e), pdDOM
    }, pdDOM.removeClass = function (t, e) {
        pd.isArray(e) && e.forEach(function (e) {
            pdDOM.removeClass(t, e)
        });
        var r = t.getAttribute("class"), n = new RegExp("(\\s|^)" + e + "(\\s|$)");
        return r && r.match(n) && (t instanceof SVGElement ? (r = r.replace(n, " ").trim(), t.setAttribute("class", r)) : t.className = t.className.replace(n, " ").trim()), pdDOM
    }, pdDOM.toggleClass = function (t, e, r) {
        pd.isArray(e) && e.forEach(function (e) {
            pdDOM.toggleClass(t, e, r)
        });
        var n = pdDOM.hasClass(t, e);
        return r = pd.toBoolean(r, !n), r && !n ? pdDOM.addClass(t, e) : !r && n && pdDOM.removeClass(t, e), pdDOM
    }, pdDOM.getComputedElementStyle = function (t, e) {
        var r = "";
        if (window.getComputedStyle) r = getComputedStyle(t).getPropertyValue(e); else if (t.currentStyle) try {
            r = t.currentStyle[e]
        } catch (t) {
        }
        return r
    }, pdDOM.getElementFontSizeInPixels = function (t) {
        return parseFloat(pdDOM.getComputedElementStyle(t || document.documentElement, "font-size"))
    }, pdDOM.convertEmToPixels = function (t, e) {
        return parseFloat(t) * pdDOM.getElementFontSizeInPixels(e)
    }, pdDOM.convertToInlineStyles = function (t, e) {
        if (e = e || {}, t) {
            e.recursive && Array.prototype.forEach.call(t.children, function (t) {
                pdDOM.convertToInlineStyles(t, e)
            });
            for (var r = getComputedStyle(t), n = 0; n < r.length; n++) {
                var i = r.item(n);
                if (!e.properties || e.properties.indexOf(i) >= 0) {
                    var a = r.getPropertyValue(i);
                    t.style[i] = a
                }
            }
        }
    }, pdDOM.copyToClipboard = function (t) {
        var e = !1;
        if (t) {
            var r = document.createElement("textarea"), n = window.pageYOffset || document.documentElement.scrollTop;
            r.style.fontSize = "12pt", r.style.border = "0", r.style.padding = "0", r.style.margin = "0", r.style.position = "absolute", r.style.left = "-9999px", r.style.top = n + "px", r.setAttribute("readonly", ""), r.value = t.toString(), document.body.appendChild(r), r.focus(), r.select();
            try {
                e = document.execCommand("copy")
            } catch (t) {
                e = !1
            }
            setTimeout(function () {
                document.body.removeChild(r), r = null
            }, 500)
        }
        return e
    }, pdDOM.enableDragDrop = function (t, e) {
        function r(t) {
            (t = t || window.event).dataTransfer.dropEffect = "copy", t.stopPropagation(), t.preventDefault()
        }

        function n(t) {
            return (t = t || window.event).stopPropagation(), t.preventDefault(), e(t.dataTransfer.files), !1
        }

        return !(!window.FileReader || !t || "function" != typeof e) && (t.addEventListener("dragenter", r), t.addEventListener("dragleave", r), t.addEventListener("dragover", r), t.addEventListener("drop", n), !0)
    }, pdDOM.getKbdIncrement = function (t, e) {
        switch (t.which) {
            case 37:
                return e ? 1 : 0;
            case 38:
                return 1;
            case 39:
                return e ? -1 : 0;
            case 40:
                return -1;
            case 33:
                return 10;
            case 34:
                return -10
        }
        return 0
    }, pdDOM.getScrollIncrement = function (t) {
        var e = t.originalEvent || t;
        if (e) {
            if (e.deltaY) return e.deltaY < 0 ? 1 : -1;
            if (e.deltaX) return e.deltaX < 0 ? 1 : -1;
            if (void 0 !== e.wheelDeltaY) return e.wheelDeltaY < 0 ? 1 : -1;
            if (void 0 !== e.wheelDeltaX) return e.wheelDeltaX < 0 ? 1 : -1;
            if (e.wheelDelta) return e.wheelDelta < 0 ? 1 : -1;
            if (e.detail) return e.detail < 0 ? 1 : -1
        }
        return 0
    }, pdDOM.hiResTimeStamp = function () {
        if (window.performance) {
            var t = window.performance;
            if (t.now) return function () {
                return t.now()
            };
            if (t.webkitNow) return function () {
                return t.webkitNow()
            };
            if (t.mozNow) return function () {
                return t.mozNow()
            };
            if (t.oNow) return function () {
                return t.oNow()
            }
        }
        return function () {
            return Date.now()
        }
    }(), pdDOM.ThrottledUpdate = function (t, e, r) {
        function n() {
            i.cancel(), t(r)
        }

        var i = this, a = null;
        if ("function" != typeof t) throw new TypeError("ERROR: Callback must be a function.");
        return e = pd.isNumeric(e) ? parseFloat(e) : 50, this.trigger = function () {
            return a || (a = setTimeout(n, e)), i
        }, this.restart = function (t) {
            return a && clearTimeout(a), e = pd.toNumber(t, e), a = setTimeout(n, e), i
        }, this.timeout = function (e) {
            return i.cancel(), e = e || r, t(e), i
        }, this.cancel = function () {
            return a && clearTimeout(a), a = null, i
        }, this
    }, pdDOM.throttledCalculation = function (t) {
        function e() {
            var e = 0, i = pdDOM.hiResTimeStamp() + t.timeout;
            if (r) for (; null != (r = r.next()) && (n(r), !(++e >= t.iterations || pdDOM.hiResTimeStamp() > i));) ;
            return !r || r.cancelled ? (t.callbackOnComplete && t.callbackOnComplete(t), !0) : (t.callbackOnTimeout && t.callbackOnTimeout(r, t), !1)
        }

        if ("object" != typeof(t = t || {}).iterator || "function" != typeof t.iterator.next) throw new Error("ERROR: Calculation requires a valid iterator object.");
        if ("function" != typeof t.callbackCalculate) throw new Error("ERROR: Calculation callback must be a function.");
        var r = t.iterator, n = t.callbackCalculate;
        return t.iterations = t.iterations || 1e6, t.timeout = t.timeout || 100, pdDOM.getGlobalAnimationQueue().addOrReplace(e).start(), !0
    };
    var g = ["webkit", "moz", "MS", "o", ""];
    pdDOM.cssAnimation = function (t, n, i, a) {
        pdDOM.addClass(t, n), e(t, "AnimationEnd", function e(s) {
            r(t, "AnimationEnd", e), pdDOM.removeClass(t, n), "function" == typeof i && i(s, a)
        })
    };
    var v = null;
    pdDOM.getGlobalAnimationQueue = function () {
        return v || (v = new pdDOM.AnimationQueue), v
    }, pdDOM.AnimationQueue = function () {
        function t(t) {
            i.indexOf(t) < 0 && i.push(t)
        }

        function e(t, e) {
            t((u - h) / 1e3, d, t._payload) && a.push(e)
        }

        function r() {
            if (o) {
                if (s.length > 0 && (s.forEach(t), s.length = 0), u = (new Date).getTime(), i.forEach(e), d++, a.length > 0) {
                    a.sort(function (t, e) {
                        return e - t
                    });
                    for (var c = a.length - 1; c >= 0; c--) i.splice(a[c], 1);
                    a.length = 0
                }
                n(r), h = u
            }
        }

        var n = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (t) {
            setTimeout(t, 1e3 / 60)
        }, i = [], a = [], s = [], o = !1, d = 0, h = 0, u = 0;
        return this.frameCount = function () {
            return d
        }, this.add = function (e, r) {
            return e && "function" == typeof e && (r && (e._payload = r), o ? s.push(e) : t(e)), this
        }, this.addOrReplace = function (e, r) {
            if (e && "function" == typeof e) {
                var n = i.indexOf(e);
                r && (e._payload = r), n >= 0 ? i[n] = e : o ? s.push(e) : t(e)
            }
            return this
        }, this.contains = function (t) {
            return i.indexOf(t) >= 0
        }, this.remove = function (t) {
            if (t && "function" == typeof t) {
                var e = i.indexOf(t);
                e >= 0 && (o ? a.push(e) : i.splice(e, 1))
            }
            return this
        }, this.start = function () {
            return o || (o = !0, h = (new Date).getTime(), r()), this
        }, this.stop = function () {
            return o = !1, this
        }, v || (v = this), this
    }, pdDOM.Animation = function (t, e) {
        var r = this;
        return this._queue = [], e && this._queue.push(e), e = e || {}, this.active = !1, this.duration = pd.constrainTo(pd.toNumber(e.duration, 1), .001, 1e3), this.easing = e.easing || pd.Easing.inOutSine, this.fromValue = pd.toNumber(e.fromValue, 0), this.toValue = pd.toNumber(e.toValue, 1), this.getter = e.getter || null, this.callback = t || null, this.onStart = e.onStart || null, this.onComplete = e.onComplete || null, this.progress = 0, this.speed = 1 / this.duration, this.update = function (t) {
            return r._handleUpdate(t)
        }, t = e = null, this
    }, pdDOM.Animation.prototype._handleUpdate = function (t) {
        if (this.progress > .999) return this.active = !1, this.progress = 1, this.callback && this.callback(this.toValue, this), (!this.onComplete || !1 !== this.onComplete(this)) && (!(this._queue.length > 0) || (this.start(this._queue.shift()), !1));
        if (this.callback) {
            var e = this.progress;
            this.easing && (e = this.easing(e)), this.callback((1 - e) * this.fromValue + e * this.toValue, this)
        }
        return (this.progress += this.speed * t) >= 1 && (this.progress = 1), !1
    }, pdDOM.Animation.prototype._handleStart = function (t) {
        t || (t = this._queue.length > 0 ? this._queue.shift() : {}), void 0 !== t.duration && (this.duration = pd.toNumber(t.duration, 1)), void 0 !== t.easing && (this.easing = t.easing), void 0 !== t.getter && (this.getter = t.getter), void 0 !== t.onStart && (this.onStart = t.onStart), void 0 !== t.onComplete && (this.onComplete = t.onComplete), t.callback && "function" == typeof t.callback && (this.callback = t.callback);
        var e = pd.toNumber(t.toValue, this.toValue), r = pd.toNumber(t.fromValue, this.fromValue);
        return this.getter && (r = pd.toNumber(this.getter(), r)), this.duration = pd.constrainTo(pd.toNumber(this.duration, 1), .001, 1e3), this.speed = 1 / this.duration, pd.closeTo(r, e) && pd.closeTo(e, this.toValue) || (this.active ? (this.progress = Math.min(.5, this.progress), this.fromValue = r - this.progress * (e - r), this.toValue = e) : (this.progress = 0, this.fromValue = r, this.toValue = e, pdDOM.getGlobalAnimationQueue().addOrReplace(this.update), this.active = !0, this.onStart && this.onStart(this))), this
    }, pdDOM.Animation.prototype.then = function (t) {
        return t && this._queue.push(t), this
    }, pdDOM.Animation.prototype.start = function (t) {
        return this._handleStart(t), this
    }, pdDOM.Animation.prototype.cancel = function () {
        return this.active = !1, pdDOM.getGlobalAnimationQueue().remove(this.update), this.onComplete && this.onComplete(this), this
    }, pdDOM.Transition = function (t) {
        return t = t || {}, this.target = t.target, this.property = t.property || "", this.type = pd.toInteger(t.type, -1), this.easing = t.easing && "function" == typeof t.easing ? t.easing : null, this.mapping = Array.isArray(t.mapping) ? t.mapping : null, this.interpolator = t.interpolator || null, this.isMethod = this.target && "function" == typeof this.target[this.property], this._cachedTransform = [0, 0, 0, 0, 0, 0, 0, 0, 0], this._cachedTransform.active = !1, this.interpolator || this.determineType(this.type, t.from, t.to), t = null, this
    };
    var y = pdDOM.Transition;
    pdDOM.Transition.VALUE = 0, pdDOM.Transition.VECTOR = 1, pdDOM.Transition.COLOR = 2, pdDOM.Transition.prototype.determineType = function (t, e, r) {
        if (t < 0 && Array.isArray(r)) {
            if (!Array.isArray(e)) throw new Error("From and to values must be of the same type and length.");
            r.length > 3 && e.length > 3 ? t = y.COLOR : r.length > 2 && e.length > 2 && (t = y.VECTOR)
        }
        switch (t) {
            default:
            case y.VALUE:
                this.interpolator = new p(e, r), this.type = y.VALUE;
                break;
            case y.VECTOR:
                this.interpolator = new l(e, r), this.type = t;
                break;
            case y.COLOR:
                this.interpolator = new c(e, r), this.type = t
        }
        return this
    }, pdDOM.Transition.prototype.update = function (t) {
        var e = this.interpolator;
        return !!e && (this.easing && (t = this.easing(t)), this.mapping && (t = pd.mapTo(t, 0, 1, this.mapping[0], this.mapping[1])), this.isMethod ? this.target[this.property](e.interpolate(t)) : this.target[this.property] = e.interpolate(t), !0)
    }, pdDOM.AnimationSequence = function (t) {
        (t = t || {}).easing = t.easing || pd.Easing.linear, pdDOM.Animation.call(this, null, t), this.host = t.host || null, this.processOnDraw = pd.toBoolean(t.processOnDraw, !1), this.transitionSequence = t.transitions || [], this.activeStep = null, this._onFullyComplete = this.onComplete, this.onComplete = null
    }, pdDOM.AnimationSequence.prototype = Object.create(pdDOM.Animation.prototype), pdDOM.AnimationSequence.prototype.constructor = pdDOM.AnimationSequence, pdDOM.AnimationSequence.prototype._nextStep = function () {
        var t = null;
        return this.transitionSequence.length > 0 && (t = this.transitionSequence.shift()).duration < 0 && (t.callback && t.callback(this, this.host), t = this._nextStep()), t
    }, pdDOM.AnimationSequence.prototype._processPropertyChanges = function (t, e) {
        var r = !1;
        if (t && t instanceof Object && e && e instanceof Object) for (var n in e) t.hasOwnProperty(n) && e.hasOwnProperty(n) && (t[n] = e[n], r = !0);
        return r
    }, pdDOM.AnimationSequence.prototype._handleProgress = function (t, e) {
        e.activeStep && !e.activeStep.paused && (e.processOnDraw || e.process(), gl.update())
    }, pdDOM.AnimationSequence.prototype._handleComplete = function (t) {
        if (t.checkNextStep = !0, !t.processOnDraw || t.activeStep && t.activeStep.paused) {
            if (t.activeStep = t._nextStep(), t.active = t.checkNextStep = !1, !t.activeStep) return t._onFullyComplete && t._onFullyComplete(t), !0;
            t._handleStart({duration: t.activeStep.duration, fromValue: 0, toValue: 1})
        } else t.active = t.transitionSequence.length > 0;
        return !t.active
    }, pdDOM.AnimationSequence.prototype.addTransition = function (t, e) {
        var r = [];
        if (t = Math.max(.017, pd.toNumber(t, 1)), arguments.length > 1) for (var n = 1; n < arguments.length; ++n) if (e = arguments[n], Array.isArray(e)) for (var i = 0; i < e.length; ++i) e[i].update && (e[i].target || (e[i].target = this.host), r.push(e[i])); else e.update && (e.target || (e.target = this.host), r.push(e));
        return this.transitionSequence.push({transitions: r, duration: t}), this
    }, pdDOM.AnimationSequence.prototype.addCallback = function (t) {
        return t && this.transitionSequence.push({callback: t, duration: -1}), this
    }, pdDOM.AnimationSequence.prototype.addPause = function (t) {
        return (t = pd.toNumber(t, 1)) > 0 && this.transitionSequence.push({
            transitions: [],
            duration: t,
            paused: !0
        }), this
    }, pdDOM.AnimationSequence.prototype.addChanges = function (t, e) {
        var r = this;
        return 1 == arguments.length && (e = t, t = this.host), t && t instanceof Object && e && e instanceof Object && this.addCallback(function () {
            r._processPropertyChanges(t, e) && gl.update()
        }), this
    }, pdDOM.AnimationSequence.prototype.process = function () {
        if (this.activeStep && !this.activeStep.paused && this.activeStep.duration > 0) {
            var t = this.progress;
            this.easing && (t = this.easing(t));
            for (var e = this.activeStep.transitions, r = 0, n = e.length; r < n; ++r) e[r].update(t)
        }
        return this.checkNextStep && (this.activeStep = this._nextStep(), this.active = this.checkNextStep = !1, this.activeStep ? this._handleStart({
            duration: this.activeStep.duration,
            fromValue: 0,
            toValue: 1
        }) : this.cancel()), this
    }, pdDOM.AnimationSequence.prototype.start = function () {
        return this.transitionSequence.length > 0 && (!this.activeStep || this.progress >= .999) && (this.activeStep = this._nextStep()), this.activeStep && this.activeStep.duration > 0 && (this.checkNextStep = !1, this._handleStart({
            callback: this._handleProgress,
            onComplete: this._handleComplete,
            duration: this.activeStep.duration,
            easing: pd.Easing.linear,
            fromValue: 0,
            toValue: 1
        })), this
    }, pdDOM.AnimateNode = function (t) {
        if (!(t instanceof pd3D.Node)) throw new TypeError("Can only animate a pd3D.Node object.");
        this.node = t, this.transform = t.transformMatrix = new pd3D.Transform, this.animation = new pdDOM.AnimationSequence({host: this});
        var e = [0, 0, 0], r = [0, 0, 0], n = [1, 1, 1];
        Object.defineProperty(this, "translation", {
            get: function () {
                return e
            }, set: function (t) {
                if (Array.isArray(t)) {
                    var r = gl.animationQueue.frameCount();
                    e.frameIndex != r && (e.frameIndex = r, e[0] = 0, e[1] = 0, e[2] = 0), e[0] += +t[0] || 0, e[1] += +t[1] || 0, e[2] += +t[2] || 0
                }
            }
        }), Object.defineProperty(this, "rotation", {
            get: function () {
                return r
            }, set: function (t) {
                if (Array.isArray(t)) {
                    var e = gl.animationQueue.frameCount();
                    r.frameIndex != e && (r.frameIndex = e, r[0] = 0, r[1] = 0, r[2] = 0), r[0] += +t[0] || 0, r[1] += +t[1] || 0, r[2] += +t[2] || 0
                }
            }
        }), Object.defineProperty(this, "scale", {
            get: function () {
                return n
            }, set: function (t) {
                if (Array.isArray(t)) {
                    var e = gl.animationQueue.frameCount();
                    n.frameIndex != e && (n.frameIndex = e, n[0] = 1, n[1] = 1, n[2] = 1), n[0] *= +t[0] || 0, n[1] *= +t[1] || 0, n[2] *= +t[2] || 0
                }
            }
        }), this.clearDynamicTransform = function () {
            return e[0] = e[1] = e[2] = 0, r[0] = r[1] = r[2] = 0, n[0] = n[1] = n[2] = 1, this
        }, t.callbackOnDraw = function (t, e, r) {
            this.animation && this.animation.active && this.animation.process(), this.transform.addTranslation(this.translation), this.transform.addRotation(this.rotation), this.transform.addScale(this.scale)
        }, this.remove = function () {
            this.node.transformMatrix = null, this.node.callbackOnDraw = null
        }
    }, pdDOM.localStorage = window.localStorage, pdDOM.localStorage || (pdDOM.localStorage = {
        getItem: function (t) {
            return t && this.hasOwnProperty(t) ? unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(t).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1")) : null
        }, key: function (t) {
            return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, "").split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[t])
        }, setItem: function (t, e) {
            t && (document.cookie = escape(t) + "=" + escape(e) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/", this.length = document.cookie.match(/\=/g).length)
        }, length: 0, removeItem: function (t) {
            t && this.hasOwnProperty(t) && (document.cookie = escape(t) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/", this.length--)
        }, hasOwnProperty: function (t) {
            return new RegExp("(?:^|;\\s*)" + escape(t).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(document.cookie)
        }
    }, pdDOM.localStorage.length = (document.cookie.match(/\=/g) || pdDOM.localStorage).length);
    var M = !0;
    pdDOM.setLocalStorageItem = function (t, e) {
        var r = pdDOM.localStorage;
        if (r && t && t.length) try {
            r.setItem(t, e)
        } catch (t) {
            M && (alert("ERROR - Unable to store value:\n" + t), M = !1)
        }
    }, pdDOM.getLocalStorageItem = function (t) {
        return t && t.length ? pdDOM.localStorage.getItem(t) : null
    }, pdDOM.removeLocalStorageItems = function (t) {
        if (Array.isArray(t)) {
            for (var e = pdDOM.localStorage, r = 0, n = t.length; r < n; ++r) e.removeItem(t[r]);
            return !0
        }
        return !1
    }, pdDOM.fromXML = function (t) {
        var e, r, n, i, a = {};
        if (1 == t.nodeType) {
            if (t.attributes.length > 0) {
                a["@attributes"] = {};
                for (var s = 0; s < t.attributes.length; s++) {
                    var o = t.attributes.item(s);
                    a["@attributes"][o.nodeName] = o.nodeValue
                }
            }
        } else 3 == t.nodeType && (a = t.nodeValue.trim());
        if (t.hasChildNodes()) if (1 === t.childNodes.length && 3 === t.childNodes[0].nodeType) a = t.childNodes[0].nodeValue; else for (var d = 0; d < t.childNodes.length; d++) void 0 === a[i = (n = t.childNodes.item(d)).nodeName] ? "" !== (e = pd.xmlToJson(n)) && (a[i] = e) : (void 0 === a[i].push && (r = a[i], a[i] = [], a[i].push(r)), "" !== (e = pd.xmlToJson(n)) && a[i].push(e));
        if (!Array.isArray(a) && "object" == typeof a) {
            var h = Object.keys(a);
            if (1 == h.length && "#text" == h[0]) return a["#text"];
            if (0 === h.length) return null
        }
        return a
    }, pdDOM.toXML = function (t, e) {
        function r(t, e) {
            var i, a;
            if (e.constructor === String || e.constructor === Number || e.constructor === Boolean) {
                if (t.appendChild(n.createTextNode(e.toString())), e === e.valueOf()) return
            } else e.constructor === Date && t.appendChild(n.createTextNode(e.toGMTString()));
            for (var s in e) if (!isFinite(s)) if (i = e[s], "keyValue" === s) null !== i && !0 !== i && t.appendChild(n.createTextNode(i.constructor === Date ? i.toGMTString() : String(i))); else if ("@attributes" === s) for (var o in i) t.setAttribute(o, i[o]); else if ("@" === s.charAt(0)) t.setAttribute(s.slice(1), i); else if (i.constructor === Array) for (var d = 0; d < i.length; d++) r(a = n.createElement(s), i[d]), t.appendChild(a); else a = n.createElement(s), i instanceof Object ? r(a, i) : null !== i && !0 !== i && a.appendChild(n.createTextNode(i.toString())), t.appendChild(a)
        }

        var n = document.implementation.createDocument("", "", null);
        n || (n = (new DOMParser).parseFromString("<dummy />", "text/xml")).removeChild(n.documentElement), e = e || "jsonXML";
        var i = n.createElement(e);
        return r(i, t), n.appendChild(i), n
    }
}(), function () {
    pdDOM.jsonToURI = function t(e) {
        function r(t) {
            return /[^\w-.]/.test(t) ? t.replace(/[^\w-.]/g, function (t) {
                return "$" === t ? "!" : (t = t.charCodeAt(0), t < 256 ? "*" + ("00" + t.toString(16)).slice(-2) : "**" + ("0000" + t.toString(16)).slice(-4))
            }) : t
        }

        var n;
        switch (typeof e) {
            case"number":
                return isFinite(e) ? "~" + pd.toStringWithPrecisionRange(e, 0, 6) : "~null";
            case"boolean":
                return "~" + e;
            case"string":
                return "~'" + r(e);
            case"object":
                if (!e) return "~null";
                if (n = [], pd.isArray(e)) {
                    for (var i = 0; i < e.length; i++) n[i] = t(e[i]) || "~null";
                    return "~(" + (n.join("") || "~") + ")"
                }
                for (var a in e) if (e.hasOwnProperty(a)) {
                    var s = t(e[a]);
                    s && n.push(r(a) + s)
                }
                return "~(" + n.join("~") + ")";
            default:
                return
        }
    };
    var t = {true: !0, false: !1, null: null};
    pdDOM.uriToJSON = function (e) {
        function r(t) {
            if (e.charAt(i) !== t) throw new Error("bad JSURL syntax: expected " + t + ", got " + (e && e.charAt(i)));
            i++
        }

        function n() {
            for (var t, r = i, n = ""; i < a && "~" !== (t = e.charAt(i)) && ")" !== t;) switch (t) {
                case"*":
                    r < i && (n += e.substring(r, i)), "*" === e.charAt(i + 1) ? (n += String.fromCharCode(parseInt(e.substring(i + 2, i + 6), 16)), r = i += 6) : (n += String.fromCharCode(parseInt(e.substring(i + 1, i + 3), 16)), r = i += 3);
                    break;
                case"!":
                    r < i && (n += e.substring(r, i)), n += "$", r = ++i;
                    break;
                default:
                    i++
            }
            return n + e.substring(r, i)
        }

        if (!e) return e;
        var i = 0, a = (e = e.replace(/%27/g, "'")).length;
        return function s() {
            var o, d, h;
            switch (r("~"), d = e.charAt(i)) {
                case"(":
                    if (i++, "~" === e.charAt(i)) if (o = [], ")" === e.charAt(i + 1)) i++; else do {
                        o.push(s())
                    } while ("~" === e.charAt(i)); else if (o = {}, ")" !== e.charAt(i)) do {
                        o[n()] = s()
                    } while ("~" === e.charAt(i) && ++i);
                    r(")");
                    break;
                case"'":
                    i++, o = n();
                    break;
                default:
                    for (h = i++; i < a && /[^)~]/.test(e.charAt(i));) i++;
                    var u = e.substring(h, i);
                    if (/[\d\-]/.test(d)) o = parseFloat(u); else if (void 0 === (o = t[u])) throw new Error("bad value keyword: " + u)
            }
            return o
        }()
    }
}(), pdDOM.Interaction = pdDOM.Interaction || {}, function () {
    function t(t) {
        var e = null;
        return t.target ? e = t.target : t.srcElement && (e = t.srcElement), e && 3 == e.nodeType && (e = e.parentNode), e
    }

    function e(e) {
        var r = pd.toNumber(e.pageX, 0), n = pd.toNumber(e.pageY, 0), i = t(e);
        if (i && i.getBoundingClientRect) {
            var a = 1 / pdDOM.pageScale, s = i.getBoundingClientRect();
            r -= s.left * a, n -= s.top * a
        }
        return {
            target: i,
            button: e.button || 0,
            identifier: pd.toNumber(e.identifier, e.pointerId),
            pageX: e.pageX,
            pageY: e.pageY,
            x: r,
            y: n
        }
    }

    function r() {
        u = 0, c = 0, v = null, M = -1, x = -1;
        for (var t in y) y.hasOwnProperty(t) && delete y[t]
    }

    function n(t, e, r) {
        isNaN(e) && (e = -1), isNaN(r) && (r = -1);
        var n = t.targetTouches || t.originalEvent.targetTouches;
        return n && n.length > 0 && (n.length > 1 && e == (r = n[1].identifier) && (e = -1), e < 0 && (e = n[0].identifier)), [e, r]
    }

    function i(e, r) {
        if (!e || !r) return !0;
        for (var n = t(r); n; n = n.parentNode) if (n === e) return !0;
        return !1
    }

    function a(t) {
        // console.log('t:' + t);
        // console.log('u2097:' + u);
        "touch" == t.pointerType.toLowerCase() && (t.isPrimary && t.timeStamp - c > l && r(), u = Math.min(10, u + 1), c = t.timeStamp)
    }

    function s(t) {
        // console.log('u2192:' + u);
        // console.log('c:' + c);
        "touch" == t.pointerType.toLowerCase() && (u = Math.max(0, u - 1), c = t.timeStamp, u <= 0 && r())
    }

    function o(t) {
        return t = t || 3 + 2 * pdDOM.devicePixelRatio, D.x > t || D.y > t
    }

    var d = !1, h = !1, u = 0, c = 0, l = 3e3, p = {x: 0, y: 0}, f = 0, m = 0, g = 0, v = null, y = {}, M = -1, x = -1,
        b = null, D = {x: 0, y: 0}, T = 400, w = 1250;
    window.PointerEvent && (d = !0, document.addEventListener("pointerdown", a), document.addEventListener("pointercancel", s), document.addEventListener("pointerup", s)), ("ontouchstart" in window || "ontouchstart" in document.documentElement || window.DocumentTouch && document instanceof DocumentTouch) && (h = !0), pdDOM.Interaction.activeTouchList = y, pdDOM.Interaction.hasMoved = o, Object.defineProperty(pdDOM.Interaction, "hasPointerEvents", {
        get: function () {
            return d
        }
    }), Object.defineProperty(pdDOM.Interaction, "hasTouchEvents", {
        get: function () {
            return h
        }
    }), Object.defineProperty(pdDOM.Interaction, "activeTouchCount", {
        get: function () {
            return u
        }
    }), Object.defineProperty(pdDOM.Interaction, "activeTouchTimeStamp", {
        get: function () {
            return c
        }, set: function (t) {
            c = +t
        }
    }), Object.defineProperty(pdDOM.Interaction, "activeTouchTimeOutInMS", {
        get: function () {
            return l
        }, set: function (t) {
            l = Math.max(500, +t)
        }
    }), Object.defineProperty(pdDOM.Interaction, "activeTouchElement", {
        get: function () {
            return v
        }
    }), pdDOM.Interaction.createEvent = function (t, e) {
        // console.log('==================================' + pdDOM.Interaction.createEvent);
        var r = !1, n = !1, a = !1, s = b, o = 0, l = 0, v = {};
        // console.log('v:' + v);
        // console.log("u:" + u);
        if (v.event = t, v.isTouchEvent = !1, v.touchCount = u, v.timeStamp = t.timeStamp, v.button = t.button, v.ctrlKey = t.ctrlKey, v.shiftKey = t.shiftKey, v.metaKey = t.metaKey, v.altKey = t.altKey, v.scale = 1, v.rotation = 0, v.dragX = 0, v.dragY = 0, v.x = pd.toNumber(t.pageX, 0), v.y = pd.toNumber(t.pageY, 0), v.primaryX = v.x, v.primaryY = v.y, t.type && t.type.length > 0) {
            // console.log('v.dragX:' + v.dragX);
            // console.log('v.dragY:' + v.dragY);
            // console.log('v.primaryX:' + v.primaryX);
            // console.log('v.primaryY:' + v.primaryY);
            // console.log(v);
            if (d && "p" == t.type.charAt(0) && (r = t.pointerType && "touch" == t.pointerType)) {
            //     // console.log('s:' + s);
            //     // console.log('y:' + y);
            //     // console.log('t.pointerType' + t.pointerType)
            //
                I = 0;
                v.isTouchEvent = !0, y[t.pointerId] && (s = y[t.pointerId]);
                for (var T in y) y.hasOwnProperty(T) && (C = y[T]) && i(e, C) && (o += C.pageX, l += C.pageY, I++);
            //     console.log();
                if (I > 0 && (a = !0, o /= I, l /= I, M >= 0 && (V = y[M]) && (v.primaryX = V.pageX, v.primaryY = V.pageY, I > 1 && x > 0 && (E = y[x])))) {
                    //
                    var w = E.pageX - V.pageX, O = E.pageY - V.pageY;
                    m = Math.sqrt(w * w + O * O), v.rotation = -Math.atan2(O, w) * pd.Const.RAD2DEG, n = !0
                    // console.log('T:' + T);
                }
            }
            if (h && "t" == t.type.charAt(0)) {
                v.isTouchEvent = !0, r = !0, t.touches && (u = t.touches.length, v.touchCount = u, v.button = u - 1);
                var A = t.targetTouches || t.originalEvent.targetTouches;
                if (A && A.length > 0) {
                    for (var C, _ = -1, S = -1, I = 0, k = 0, N = A.length; k < N; k++) C = A[k], M === C.identifier && (_ = k), x === C.identifier && (S = k), o += C.pageX, l += C.pageY, I++;
                    if (I > 0 && (a = !0, o /= I, l /= I, _ >= 0 && S >= 0)) {
                        var V = A[_], E = A[S];
                        if (V && E) {
                        //     //
                        //     // console.log("V:" + V);
                        //     // console.log('E' + E);
                            var w = E.pageX - V.pageX, O = E.pageY - V.pageY;
                            m = Math.sqrt(w * w + O * O), v.rotation = -Math.atan2(O, w) * pd.Const.RAD2DEG, n = !0
                        }
                    }
                    C = A[Math.max(0, _)], v.x = v.primaryX = C.pageX, v.y = v.primaryY = C.pageY
                    // console.log('C:' + C);
                } else (A = t.changedTouches || t.originalEvent.changedTouches) && A.length > 0 && (a = !0, o = (C = A[0]).pageX, l = C.pageY, v.x = o, v.y = l)
            }
        }
        if (e && e.getBoundingClientRect) {
            var L = 1 / pdDOM.pageScale, R = e.getBoundingClientRect();
            R.left && (o -= R.left * L, v.x -= R.left * L), R.top && (l -= R.top * L, v.y -= R.top * L)
        }
        switch (t.type.toLowerCase()) {
            case"pointerdown":
                if (!r) {
                    D.x = 0, D.y = 0;
                    break
                }
                v.button = u;
            case"mousedown":
            case"touchstart":
                D.x = 0, D.y = 0, n && (f = m, g = v.rotation, v.rotation = 0);
                // console.log('touchStart');
                break;
            case"pointermove":
                r ? v.button = u - 1 : v.button < 0 && t.button < 0 && (t.buttons > 0 ? 1 & t.buttons ? v.button = 0 : 4 & t.buttons ? v.button = 1 : 2 & t.buttons ? v.button = 2 : 8 & t.buttons ? v.button = 3 : 16 & t.buttons ? v.button = 4 : 32 & t.buttons && (v.button = 5) : s && (v.button = s.button));
            case"touchmove":
                // console.log('touchmoveEvent');
            case"mousemove":
                // console.log(r);
                // console.log(s);
                if (r) {
                    if (c = t.timeStamp, v.button >= 0 && a ? (v.dragX = o - p.x, v.dragY = l - p.y) : s && (v.dragX = v.x - s.x, v.dragY = v.y - s.y), v.button > 0 && n) {
                        var P = v.rotation;
                        v.scale = f > 0 ? m / f : 1, f = m, v.rotation -= g, g = P
                    }
                    t.preventDefault()
                } else s && (v.dragX = v.x - s.x, v.dragY = v.y - s.y);
                // D.x += Math.abs(v.dragX), D.y += Math.abs(v.dragY);
                break;
            case"touchend":
            case"touchcancel":
            case"pointerup":
            case"pointercancel":
                r && (v.button = u - 1);
                break;
            case"mouseup":
                v.button >= 0 && (u = 0);
                break;
            case"wheel":
            case"mousewheel":
            case"dommousescroll":
                v.delta = pd.sign(pdDOM.getScrollIncrement(t));
                break;
            case"keydown":
                v.delta = pd.sign(pdDOM.getKbdIncrement(t))
        }
        return r && a && (p.x = o, p.y = l), s && (s.x = v.x, s.y = v.y), v
    }, pdDOM.Interaction.makeInteractive = function (t, i) {
        function a(e) {
            if (!b && i.onmove) {
                // console.log('3047 function a:' + a)
                // e.preventDefault();
                // var r = pdDOM.Interaction.createEvent(e, t);
                // i.onmove(r)
            }
        }

        function s(r) {
            // console.log('3055 function s:' + s)
            var n = !1;
            if (r.preventDefault(), r.timeStamp || (r.timeStamp = Date.now()), N = Date.now(), null == v && (v = t, c = r.timeStamp, i.onmove && t.removeEventListener("pointermove", a), t.addEventListener("pointermove", f), t.addEventListener("pointercancel", O), t.addEventListener("pointerup", O), n = !0), r.pointerType && "touch" == r.pointerType ? (y[r.pointerId] = e(r), M < 0 && (M = r.pointerId), M != r.pointerId && (x < 0 || x == M) && (x = r.pointerId)) : b = e(r), n) {
                if (i.onpress) {
                    var s = pdDOM.Interaction.createEvent(r, t);
                    i.onpress(s)
                }
                t.setPointerCapture && t.setPointerCapture(r.pointerId)
            }
        }

        function l(r) {
            // console.log('3067 function l:' + l)
            if (r.preventDefault(), r.timeStamp || (r.timeStamp = Date.now()), E = Date.now(), i.onmove && t.removeEventListener("mousemove", a), document.addEventListener("mousemove", m), document.addEventListener("mouseup", A), b = e(r), i.onpress) {
                var n = pdDOM.Interaction.createEvent(r, t);
                i.onpress(n)
            }
        }

        function p(r) {
            // console.log('3075 function p:' + p)
            var a = !1;
            i.allowDefaultOnTouch || "boolean" == typeof r.cancelable && !r.cancelable || r.preventDefault(), r.timeStamp || (r.timeStamp = Date.now()), R = Date.now(), null == v && (v = t, document.addEventListener("touchmove", g), document.addEventListener("touchcancel", C), document.addEventListener("touchend", C), a = !0);
            var s = r.touches || r.targetTouches || r.changedTouches;
            //console.log(s);
            u = s ? s.length : Math.min(10, u + 1), c = r.timeStamp;
            var o = r.changedTouches;
            if (o && o.length > 0) for (var d = 0, h = o.length; d < h; d++) y[o[d].identifier] = e(o[d]);
            if (M < 0 || x < 0) {
                var l = n(r, M, x);
                M = l[0], x = l[1]
            }
            if (a && i.onpress) {
                var p = pdDOM.Interaction.createEvent(r, t);
                i.onpress(p)
            }
        }

        function f(e) {
            // console.log('3094 function f:' + e)
            console.log(e);
            e.preventDefault();
            var r = y[e.pointerId];
            // console.info('t',t);
            if (r && (r.pageX = e.pageX, r.pageY = e.pageY), i.ondrag) {
                var n = pdDOM.Interaction.createEvent(e, t);
                // if(n.touchCount>2){
                //     return;
                // }
            //     console.info('n', n);
                Math.abs(n.dragX) < 50 && Math.abs(n.dragY) < 50 && i.ondrag(n)
            }
            //console.info('o', o);
            o() && (N = 0, E = 0)
        }

        function m(e) {
            // console.log('3112 function m:' + m)
            if (e.preventDefault(), i.ondrag) {
                var r = pdDOM.Interaction.createEvent(e, t);
                if(r.touchCount>2){
                    return;
                }
                i.ondrag(r)
            }
            o() && (E = 0)
        }

        function g(e) {
            // console.log('3124 function g:' + g)
            if (i.allowDefaultOnTouch || "boolean" == typeof e.cancelable && !e.cancelable || e.preventDefault(), M < 0 || x < 0) {
                var r = n(e, M, x);
                M = r[0], x = r[1]
            }
            if (i.ondrag) {
                var a = pdDOM.Interaction.createEvent(e, t);
                // if(a.touchCount>2){
                //     return;
                // }
                Math.abs(a.dragX) < 50 && Math.abs(a.dragY) < 50 && i.ondrag(a)
            }
            o() && (R = 0)
        }

        function D() {
            // console.log('3140 function D:' + D);
            t.removeEventListener("pointermove", f), t.removeEventListener("pointercancel", O), t.removeEventListener("pointerup", O), i.onmove && t.addEventListener("pointermove", a)
        }

        function O(e) {
            // console.log('3145 function O:' + e)
            var n, a = !1, s = Date.now();
            if (e.preventDefault(), e.timeStamp || (e.timeStamp = s), t.releasePointerCapture && t.releasePointerCapture(e.pointerId), n = pdDOM.Interaction.createEvent(e, t), N > 0 && s - N > w && (n.longPress = !0), e.pointerType && "touch" == e.pointerType) {
                delete y[e.pointerId], M == e.pointerId ? M = x = -1 : x == e.pointerId && (x = -1);
                var o = 0;
                for (var d in y) y.hasOwnProperty(d) && (M < 0 && x != d && (M = d), x < 0 && M != d && (x = d), o++);
                o <= 0 && (D(), a = !0)
            } else b = null, D(), r(), a = !0;
            a && (i.onrelease && i.onrelease(n), i.onlongpress && n.longPress ? _(i.onlongpress, n) : i.ondoubletap && N > 0 && N - V < T && (n.isTouchEvent || n.button > 0) && _(i.ondoubletap, n), V = N, E > 0 && (E = 0), N = 0)
        }

        function A(e) {
            // console.log('3157 function A:' + A);
            var r, n = Date.now();
            e.preventDefault(), e.timeStamp || (e.timeStamp = n), r = pdDOM.Interaction.createEvent(e, t), E > 0 && n - E > w && (r.longPress = !0), document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", A), i.onmove && t.addEventListener("mousemove", a), i.onrelease && i.onrelease(r), i.onlongpress && r.longPress ? _(i.onlongpress, r) : i.ondoubletap && E > 0 && E - L < T && r.button > 0 && _(i.ondoubletap, r), L = E, E = 0, b = null
        }

        function C(e) {
            // console.log('3163 function C:' + C)
            var n, a = !1, s = Date.now();
            i.allowDefaultOnTouch || "boolean" == typeof e.cancelable && !e.cancelable || e.preventDefault(), e.timeStamp || (e.timeStamp = s), n = pdDOM.Interaction.createEvent(e, t), R > 0 && s - R > w && (n.longPress = !0);
            var o = e.touches || e.targetTouches || e.changedTouches;
            u = o ? o.length : Math.max(0, u - 1), c = e.timeStamp;
            var d = e.changedTouches;
            if (d && d.length > 0) for (var h = 0, l = d.length; h < l; h++) {
                f = d[h].identifier;
                delete y[f], M == f ? M = x = -1 : x == f && (x = -1)
            }
            var p = 0;
            for (var f in y) y.hasOwnProperty(f) && (M < 0 && x != f && (M = f), x < 0 && M != f && (x = f), p++);
            p <= 0 && (document.removeEventListener("touchmove", g), document.removeEventListener("touchcancel", C), document.removeEventListener("touchend", C), a = !0, r()), a && (R > 0 && s - R > w && (n.longPress = !0), i.onrelease && i.onrelease(n), i.onlongpress && n.longPress ? _(i.onlongpress, n) : i.ondoubletap && R > 0 && R - P < T && _(i.ondoubletap, n), P = R, R = 0)
        }

        function _(t, e) {
            // console.log('3183');
            setTimeout(function () {
                t(e)
            }, 50)
        }

        function S(e) {
            // console.log('3185 function S:' + S)
            if (i.ondoubletap) {
                e.preventDefault();
                var r = pdDOM.Interaction.createEvent(e, t);
                if(r.touchCount>2){
                    return;
                }
                i.ondoubletap(r)
            }
        }

        function I(e) {
            // console.log('3197 function I' + I)
            if (i.onscroll) {
                var r = pdDOM.Interaction.createEvent(e, t);
                if(r.touchCount>2){
                    return;
                }
                r.delta && i.onscroll(r)
            }
        }

        function k(e) {
            // console.log('3208 funciton k:'+ k)
            if (i.onkeydown) {
                var r = pdDOM.Interaction.createEvent(e, t);
                i.onkeydown(r)
            } else i.onscroll && (r = pdDOM.Interaction.createEvent(e, t)).delta && i.onscroll(r)
        }

        t.style.touchAction = "none", t.classList.add("no-select", "no-touch"), i = i || {};
        var N = 0, V = 0, E = 0, L = 0, R = 0, P = 0;
        return d && !i.simple ? (t.addEventListener("pointerdown", s), i.onmove && t.addEventListener("pointermove", a)) : (t.addEventListener("mousedown", l), i.onmove && t.addEventListener("mousemove", a), h && t.addEventListener("touchstart", p)), i.ondoubletap && t.addEventListener("dblclick", S), i.onscroll && (t.addEventListener("DOMMouseScroll", I), t.addEventListener("mousewheel", I), t.addEventListener("wheel", I)), (i.onkeydown || i.onscroll) && t.addEventListener("keydown", k), this.dispose = function () {
            d && !i.simple ? (t.removeEventListener("pointerdown", s), i.onmove && t.removeEventListener("pointermove", a)) : (t.removeEventListener("mousedown", l), i.onmove && t.addEventListener("mousemove", a)), h && t.removeEventListener("touchstart", p), i.ondoubletap && t.addEventListener("dblclick", S), i.onscroll && (t.removeEventListener("DOMMouseScroll", I), t.removeEventListener("mousewheel", I), t.removeEventListener("wheel", I)), (i.onkeydown || i.onscroll) && t.removeEventListener("keydown", k)
        }, this
    }
}(), function () {
    function t(t, e, r, n, i, a, s, o, d) {
        if (e && t && a > i) {
            t.shiftKey ? s = pd.toNumber(d, 50 * s) : t.ctrlKey || t.metaKey || (s = pd.toNumber(o, 5 * s));
            var h = pd.constrainTo(parseFloat(n()) + e * s, i, a);
            n(pd.snapTo(h, e * s))
        }
    }

    ko.loadExternalTemplates = function (t) {
        function e() {
            this.attr("loaded", !0), $(r).length || t()
        }

        var r = 'script[src][type="text/html"]:not([loaded])';
        $filesToLoad = $(r), ko.utils.arrayForEach($filesToLoad, function (t) {
            var r = $(t);
            r.load(r.attr("src"), e.bind(r))
        })
    }, ko.extenders.fixedPrecision = function (t, e) {
        var r = ko.pureComputed({
            read: t, write: function (r) {
                var n = t(), i = isNaN(r) ? 0 : parseFloat(r), a = pd.roundTo(i, e);
                a !== n ? t(a) : r !== n && t.notifySubscribers(a)
            }
        }).extend({notify: "always"});
        return r(t()), r
    }, ko.bindingHandlers.href = {
        update: function (t, e) {
            ko.bindingHandlers.attr.update(t, function () {
                return {href: e()}
            })
        }
    }, ko.bindingHandlers.src = {
        update: function (t, e) {
            ko.bindingHandlers.attr.update(t, function () {
                return {src: e()}
            })
        }
    }, ko.bindingHandlers.hidden = {
        update: function (t, e) {
            var r = ko.utils.unwrapObservable(e());
            ko.bindingHandlers.visible.update(t, function () {
                return !r
            })
        }
    }, ko.bindingHandlers.numeric = {
        init: function (t, e, r, n, i) {
            var a = ko.computed({
                read: function () {
                    return ko.unwrap(e())
                }, write: function (t) {
                    isNaN(t) || e()(parseFloat(t))
                }, disposeWhenNodeIsRemoved: t
            });
            ko.applyBindingsToNode(t, {value: a}, i)
        }
    }, ko.bindingHandlers.currencyValue = {
        init: function (t, e, r) {
            var n = e() || {}, i = ko.isObservable(n.value) ? n.value : ko.observable(0),
                a = ko.unwrap(n.symbol) || "", s = ko.pureComputed({
                    read: function () {
                        return a + parseFloat(i()).toFixed(2)
                    }, write: function (t) {
                        var e = i(), r = parseFloat(t.replace(a, ""));
                        r !== e ? i(r) : t !== e.toString() && i.valueHasMutated()
                    }
                });
            ko.applyBindingsToNode(t, {value: s})
        }
    }, ko.bindingHandlers.angleValue = {
        init: function (t, e, r) {
            var n = e(), i = ko.pureComputed({
                read: function () {
                    return pd.toStringWithPrecisionRange(n(), 2, 9) + ""
                }, write: function (t) {
                    var e = n(), r = parseFloat(t);
                    r !== e ? n(r) : t !== e.toString() && n.valueHasMutated()
                }
            });
            ko.applyBindingsToNode(t, {value: i})
        }
    }, ko.bindingHandlers.angleText = {
        init: function (t, e, r) {
            var n = e(), i = ko.pureComputed(function () {
                var t = n();
                return isNaN(t) ? "-" : pd.toStringWithPrecisionRange(n(), 2, 9) + ""
            });
            ko.applyBindingsToNode(t, {text: i})
        }
    }, ko.bindingHandlers.toFixed = {
        init: function (t, e, r) {
            var n = e(), i = pd.toInteger(r.get("precision"), 2);
            if (!ko.isObservable(n)) {
                var a = e() || {};
                n = ko.isObservable(a.value) ? a.value : ko.observable(0), i = pd.toInteger(ko.unwrap(a.precision), i)
            }
            var s = ko.pureComputed(function () {
                return (+n()).toFixed(i)
            });
            ko.applyBindingsToNode(t, {text: s})
        }
    }, ko.bindingHandlers.fixedPrecision = {
        init: function (t, e, r) {
            var n = e(), i = pd.toInteger(r.get("precision"), 0);
            if (!ko.isObservable(n)) {
                var a = e() || {};
                n = ko.isObservable(a.value) ? a.value : ko.observable(0), i = ko.unwrap(a.precision) || 0
            }
            var s = ko.pureComputed(function () {
                return parseFloat(n()).toFixed(i)
            });
            ko.applyBindingsToNode(t, {text: s})
        }
    }, ko.bindingHandlers.clickWithoutFocus = {
        init: function (t, e, r, n, i) {
            var a = $(t);
            ko.utils.registerEventHandler(a, window.PointerEvent ? "pointerdown" : "mousedown touchstart", function (t) {
                (void 0 !== t.button && t.button <= 0 || 0 == t.which) && t.type && "touchstart" == t.type && a.click(), t.preventDefault()
            }), ko.bindingHandlers.click.init(t, e, r, n, i)
        }
    }, ko.bindingHandlers.repeatButton = {
        init: function (t, e, r, n, i) {
            var a = $(t), s = null, o = null;
            ko.utils.registerEventHandler(t, window.PointerEvent ? "pointerdown" : "mousedown touchstart", function (t) {
                (void 0 !== t.button && t.button <= 0 || 0 == t.which) && (t.type && "touchstart" == t.type && a.click(), o = setTimeout(function () {
                    s = setInterval(function () {
                        a.click()
                    }, 100)
                }, 400)), t.preventDefault()
            }), ko.utils.registerEventHandler(t, "mouseup mouseout touchend touchcancel touchleave pointerup pointerleave", function () {
                o && clearTimeout(o), s && clearInterval(s)
            }), ko.bindingHandlers.click.init(t, e, r, n, i)
        }
    }, ko.bindingHandlers.radioButton = {
        init: function (t, e, r, n, i) {
            var a, s, o = e();
            if (!ko.isWriteableObservable(o)) throw"You must pass a Knockout observable or writeable computed";
            a = (s = $(t)).hasClass("btn") ? s : $(".btn", s);
            var d = r();
            a.each(function () {
                var t = this, e = $(t),
                    r = void 0 !== d.radioValue ? d.radioValue : void 0 !== e.attr("data-value") ? e.attr("data-value") : void 0 !== e.attr("value") ? e.attr("value") : e.text();
                return e.on("click", function () {
                    o(ko.utils.unwrapObservable(r)), e.blur()
                }), e.blur(), ko.computed({
                    disposeWhenNodeIsRemoved: t, read: function () {
                        var t = o() === ko.utils.unwrapObservable(r);
                        e.toggleClass("btn-info", t).toggleClass("active", t)
                    }
                })
            })
        }
    }, ko.bindingHandlers.checkButton = {
        init: function (t, e, r, n, i) {
            function a() {
                var t = !!s();
                o.toggleClass("active", t), o.hasClass("btn") && o.toggleClass("btn-info", t)
            }

            var s = e();
            if (!ko.isWriteableObservable(s)) throw"You must pass a Knockout observable or writeable computed";
            var o = $(t);
            a(), s.subscribe(a), o.on("click", function () {
                s(!o.hasClass("active")), o.blur()
            })
        }
    }, ko.bindingHandlers.radioMenuItem = {
        init: function (t, e, r, n, i) {
            var a, s, o = e();
            if (!ko.isWriteableObservable(o)) throw"You must pass a Knockout observable or writeable computed";
            a = "menuitem" == (s = $(t)).attr("role") ? s : $("a[role=menuitem]", s);
            var d = r();
            a.each(function () {
                var t = this, e = $(this),
                    r = void 0 !== d.radioValue ? d.radioValue : void 0 !== e.attr("data-value") ? e.attr("data-value") : void 0 !== e.attr("value") ? e.attr("value") : e.text();
                return e.on("click", function () {
                    o(ko.utils.unwrapObservable(r)), e.blur()
                }), e.blur(), ko.computed({
                    disposeWhenNodeIsRemoved: t, read: function () {
                        var t = o() === ko.utils.unwrapObservable(r);
                        e.find(".icon").toggleClass("icon-radio-unchecked", !t), e.find(".icon").toggleClass("icon-radio-checked", t), e.toggleClass("active", t)
                    }
                })
            })
        }
    }, ko.bindingHandlers.checkMenuItem = {
        init: function (t, e, r, n, i) {
            function a() {
                var t = !!s();
                o.find(".icon").toggleClass("icon-checked", t), o.find(".icon").toggleClass("icon-unchecked", !t), o.toggleClass("active", t)
            }

            var s = e();
            if (!ko.isWriteableObservable(s)) throw"You must pass a Knockout observable or writeable computed";
            var o = $(t);
            a(), s.subscribe(a), o.on("click", function () {
                s(!o.hasClass("active")), o.blur()
            })
        }
    }, ko.bindingHandlers.jqSlider = {
        init: function (t, e, r) {
            var n = $(t), i = e(), a = r().jqOptions || {};
            n.slider(a), ko.isObservable(i) && ko.utils.registerEventHandler(t, "slide slidechange", function () {
                var t = parseFloat(n.slider("value"));
                i(t)
            });
            var s = a.incrementor || i.incrementor;
            s && "function" == typeof s && (ko.utils.registerEventHandler(t, "mousewheel DOMMouseScroll", function (t) {
                var e = pdDOM.getScrollIncrement(t);
                e && s(t, e)
            }), ko.utils.registerEventHandler(t, "keydown", function (t) {
                var e = pdDOM.getKbdIncrement(t);
                e && s(t, e)
            })), ko.utils.domNodeDisposal.addDisposeCallback(t, function () {
                n.slider("destroy")
            })
        }, update: function (t, e) {
            var r = parseFloat(ko.utils.unwrapObservable(e()));
            $(t).slider("value", r || 0)
        }
    }, ko.UndoRedoQueue = function () {
        function t(t) {
            return {value: ko.utils.unwrapObservable(t()), item: t}
        }

        function e(e) {
            if (!i && !a && !this.undoIgnore && this.undoIndex >= 0) {
                var s = (new Date).getTime(), o = +this.undoIdleThreshold || u;
                this.undoIndex != c ? s - l < h && r().length > 0 ? r()[r().length - 1].push(t(this)) : (r.push([t(this)]), n([])) : (this.undoNoCollation || s - this.undoTime > o) && (r.push([t(this)]), n([])), c = this.undoIndex, this.undoTime = s, l = s
            }
        }

        var r = ko.observableArray([]), n = ko.observableArray([]), i = !1, a = !1;
        this.isWorking = function () {
            return i
        }, this.canUndo = ko.pureComputed(function () {
            return r().length > 256 && r().shift(), r().length > 0
        }), this.canRedo = ko.pureComputed(function () {
            return n().length > 0
        }), this.undo = function () {
            if (r().length > 0) {
                var t, e = [], a = r.pop();
                i = !0;
                for (var s = a.length, o = 0; o < s; o++) {
                    t = a[o].item;
                    var d = ko.utils.unwrapObservable(t());
                    t(a[o].value), t.onUndo && "function" == typeof t.onUndo && t.onUndo(a[o].value), a[o].value = d, e.push(a[o])
                }
                e.length > 0 && n.push(e), i = !1
            }
            return this
        }, this.redo = function () {
            if (n().length > 0) {
                var t, e = [], a = n.pop();
                i = !0;
                for (var s = a.length, o = 0; o < s; o++) {
                    t = a[o].item;
                    var d = ko.utils.unwrapObservable(t());
                    t(a[o].value), t.onUndo && "function" == typeof t.onUndo && t.onUndo(a[o].value), a[o].value = d, e.push(a[o])
                }
                e.length > 0 && r.push(e), i = !1
            }
            return this
        }, this.reset = function () {
            return r([]), n([]), this
        };
        var s = [];
        this.storeValues = function () {
            s.length = 0;
            for (var e = arguments.length, r = 0; r < e; r++) ko.isObservable(arguments[r]) && s.push(t(arguments[r]));
            return this
        }, this.checkForChanges = function () {
            if (s.length > 0) {
                for (var t = [], e = s.length, i = 0; i < e; i++) s[i].value != ko.utils.unwrapObservable(s[i].item()) && t.push(s[i]);
                t.length > 0 && (r.push(t), n([])), s.length = 0
            }
            return this
        };
        var o = [], d = [], h = 20, u = 2500, c = -1, l = 0;
        this.addUndoEntry = function (e) {
            if (!i && !a && ko.isObservable(e) && !e.undoIgnore) {
                var s = (new Date).getTime();
                s - l < h && r().length > 0 ? r()[r().length - 1].push(t(e)) : (r.push([t(e)]), n([])), c = -1, this.undoTime = s, l = s
            }
            return this
        }, this.add = function () {
            for (var t = arguments.length, r = 0; r < t; r++) ko.isObservable(arguments[r]) && (o.push({
                item: arguments[r],
                value: ko.utils.unwrapObservable(arguments[r]())
            }), d.push(arguments[r].subscribe(e, arguments[r], "beforeChange")), arguments[r].undoIndex = o.length - 1, arguments[r].undoIgnore = !1, arguments[r].undoTime = 0);
            return this
        }, this.addPostMonitor = function () {
            for (var t = arguments.length, r = 0; r < t; r++) ko.isObservable(arguments[r]) && (o.push({
                item: arguments[r],
                value: ko.utils.unwrapObservable(arguments[r]())
            }), d.push(arguments[r].subscribe(e, arguments[r])), arguments[r].undoIndex = o.length - 1, arguments[r].undoIgnore = !1, arguments[r].undoTime = 0);
            return this
        }, this.clear = function () {
            for (var t = d.length, e = 0; e < t; e++) d.dispose();
            return d.length = 0, o.length = 0, a = !1, this
        };
        var p = [];
        return this.pause = function () {
            if (!i && !a) {
                p.length = 0, a = !0;
                for (var e = o.length, r = 0; r < e; r++) p.push(t(o[r].item))
            }
            return this
        }, this.resume = function () {
            if (!i) {
                if (a && p.length > 0) {
                    for (var t = [], e = p.length, s = 0; s < e; s++) p[s].value != ko.utils.unwrapObservable(p[s].item()) && t.push(p[s]);
                    t.length > 0 && (r.push(t), n([])), p.length = 0
                }
                a = !1
            }
            return this
        }, this.stop = function () {
            return i = !0, this
        }, this.start = function () {
            return i = !1, a && this.resume(), this
        }, this
    }, ko.undoableObservable = function (t) {
        var e = ko.observable(t), r = ko.observableArray([]), n = ko.observableArray([]), i = ko.computed({
            read: function () {
                return e()
            }, write: function (t) {
                var i = e();
                void 0 !== i && r.push(i), e(t), n([])
            }
        });
        return i.undoable = ko.pureComputed(function () {
            return r().length > 0
        }), i.redoable = ko.pureComputed(function () {
            return n().length > 0
        }), i.undo = function () {
            if (r().length > 0) {
                var t = r.pop();
                n.push(e()), e(t)
            }
        }, i.redo = function () {
            if (n().length > 0) {
                var t = n.pop();
                r.push(e()), e(t)
            }
        }, i.reset = function () {
            r([]), n([])
        }, i.getUndoStack = function () {
            return r()
        }, i.getRedoStack = function () {
            return n()
        }, i
    }, ko.bindingHandlers.rowSlider = {
        init: function (e, r, n, i, a) {
            // console.log('t:' + t + '\nf:' + f +'\np:' + p + '\ng:' + g + '\nv:' + v + '\ny:' + y + '\nM:' + M + '\nx:' + x)
            // console.log('pdDOM:' + pdDOM.Interaction);
            function s() {
                D < 5 && (D = Math.max(f.width() - 4, 1));
                var t = (parseFloat(p()) - g) / (v - g);
                D < 5 ? f.find(".row-slider-indicator").width(90.5 * t + "%") : f.find(".row-slider-indicator").width(t * D + "px")
            }

            function o() {
                return O *= _, w = b ? pd.wrapAt(w + O, g, v) : pd.constrainTo(w + O, g, v), p(pd.snapTo(w, S)), pd.closeTo(O, 0, y)
            }

            function d(t) {
                t.button >= 0 && (D = Math.max(f.width() - 4, 1), w = parseFloat(p()), I = 0, O = 0)
            }

            function h(t) {
                //console.info('aaa',t);

                if (t.button >= 0 && t.button < 2) {
                    var e = t.dragX * pdDOM.pageScale;
                    0 == t.button ? O = e / D * (v - g) : 1 == t.button && (O = .25 * pd.sign(e) * pd.interpolate(y, x, Math.min(1, (Math.abs(e) - 1) / 20)), t.metaKey = !0), w = b ? pd.wrapAt(w + O, g, v) : pd.constrainTo(w + O, g, v), S = t.shiftKey ? x : 1 == t.button || t.ctrlKey || t.metaKey ? y : M, I = t.timeStamp, p(pd.snapTo(w, S)), C = 10 * S
                }
            }

            function u(t) {
                t.timeStamp - I < A && Math.abs(O) > C && pdDOM.getGlobalAnimationQueue().addOrReplace(o).start()
            }

            function c(t) {
                t.delta && T(t, t.delta, f, p, g, v, y, M, x)
            }

            function l(t) {
                m && m(t, f, p, g, v, y, M, x)

            }

            var p = r();
            if (!ko.isWriteableObservable(p)) throw"You must pass a Knockout observable or writeable computed";
            var f = $(e), m = n.get("dblclick"), g = pd.toNumber(n.get("min"), 0), v = pd.toNumber(n.get("max"), 100),
                y = pd.toNumber(n.get("step"), .1), M = pd.toNumber(n.get("minor"), 5 * y),
                x = pd.toNumber(n.get("major"), 50 * y), b = pd.toBoolean(n.get("wrap"), !1);
            v <= g && (v = g + 1);
            var D = 0;
            f.toggleClass("row-slider", !0), f.find("td:first").prepend('<div class="row-slider-indicator"></div>'), p.subscribe(s), s();
            var T = n.get("incrementor") || p.incrementor;
            T || "function" == typeof T || (T = t);
            var w = 0, O = 0, A = 50, C = 2, _ = .85, S = 1, I = 0;

            pdDOM.Interaction.makeInteractive(e, {
                onpress: d,
                ondrag: h,
                onrelease: u,
                onscroll: c,
                ondoubletap: l,
                onlongpress: l,
                simple: !0
            })
        }
    }, ko.bindingHandlers.numericSlider = {
        init: function (e, r, n, i, a) {
            var s = $(e), o = r(), d = n().numericOptions || {};
            ko.isObservable(o) && ko.utils.registerEventHandler(e, "input change", function () {
                o(parseFloat(s.val()))
            });
            var h = d.incrementor || o.incrementor;
            if (h && "function" == typeof h) ko.utils.registerEventHandler(e, "mousewheel DOMMouseScroll", function (t) {
                var e = pdDOM.getScrollIncrement(t);
                e && h(t, e)
            }), ko.utils.registerEventHandler(e, "keydown", function (t) {
                var e = pdDOM.getKbdIncrement(t);
                e && h(t, e)
            }); else {
                var u = pd.toNumber(s.attr("min"), 0), c = pd.toNumber(s.attr("max"), 100),
                    l = pd.toNumber(s.attr("step"), .1), p = pd.toNumber(s.attr("minor"), 5 * l),
                    f = pd.toNumber(s.attr("major"), 50 * l);
                ko.utils.registerEventHandler(e, "mousewheel DOMMouseScroll", function (e) {
                    t(e, pdDOM.getScrollIncrement(e), s, o, u, c, l, p, f)
                }), ko.utils.registerEventHandler(e, "keydown", function (e) {
                    t(e, pdDOM.getKbdIncrement(e), s, o, u, c, l, p, f)
                })
            }
            return ko.bindingHandlers.value.init(e, r, n, i, a)
        }, update: function (t, e, r, n, i) {
            ko.bindingHandlers.value.update(t, e, r, n, i)
        }
    }, ko.bindingHandlers.numericInput = {
        init: function (t, e, r, n, i) {
            var a = e(), s = r().numericOptions || {}, o = s.formatter || a.formatter;
            o && ko.isObservable(o) || (o = a);
            var d = s.incrementor || a.incrementor;
            return d && "function" == typeof d && ko.utils.registerEventHandler(t, "mousewheel DOMMouseScroll", function (t) {
                var e = pdDOM.getScrollIncrement(t);
                e && d(t, e)
            }), ko.utils.registerEventHandler(t, "keydown", function (e) {
                if (13 == e.which) return o($(t).val()), void $(t).focus().select();
                if (d) {
                    var r = pdDOM.getKbdIncrement(e);
                    r && d(e, r)
                }
            }), ko.utils.registerEventHandler(t, "blur", function (e) {
                o($(t).val())
            }), ko.bindingHandlers.value.init(t, o, r, n, i)
        }
    };
    ko.components.register("numeric-slider", {
        viewModel: function (t) {
            var e = this;
            this.min = t.min || 0, this.max = t.max || 100, this.step = t.step || 1, this.value = t.value || ko.observable(parseFloat(ko.unwrap(t.min))), this.title = t.title || "No Title", this.suffix = t.suffix || null, t.formatter && ko.isObservable(t.formatter) ? this.formatter = t.formatter : this.value.formatter && ko.isObservable(this.value.formatter) ? this.formatter = this.value.formatter : (this.decimals = pd.isNumeric(t.decimals) ? t.decimals : t.decimals || 2, this.formatter = ko.pureComputed({
                read: function () {
                    var t, r = ko.isObservable(e.suffix) ? e.suffix() : e.suffix,
                        n = ko.isObservable(e.decimals) ? e.decimals() : +e.decimals;
                    return t = n <= 0 ? parseInt(e.value(), 10).toString() : pd.toStringWithPrecisionRange(+e.value(), n, 9), r && (t += r), t
                }, write: function (t) {
                    var r = ko.isObservable(e.min) ? e.min() : +e.min, n = ko.isObservable(e.max) ? e.max() : +e.max,
                        i = (ko.isObservable(e.decimals) ? e.decimals() : +e.decimals) <= 0 ? parseInt(t, 10) : parseFloat(t);
                    i = pd.constrainTo(i, r, n), e.value(i)
                }, owner: this
            })), t.incrementor && "function" == typeof t.incrementor ? this.incrementor = t.incrementor : this.value.incrementor && "function" == typeof this.value.incrementor ? this.incrementor = this.value.incrementor : (this.largeIncrement = t.largeIncrement || 100, this.smallIncrement = t.smallIncrement || 10, this.incrementor = function (t, r) {
                if (r = parseFloat(r)) {
                    var n = ko.isObservable(e.min) ? e.min() : e.min, i = ko.isObservable(e.max) ? e.max() : e.max,
                        a = ko.isObservable(e.largeIncrement) ? e.largeIncrement() : e.largeIncrement,
                        s = ko.isObservable(e.smallIncrement) ? e.smallIncrement() : e.smallIncrement,
                        o = ko.isObservable(e.step) ? e.step() : e.step;
                    r = t.shiftKey ? Math.abs(r) > 5 ? 10 * pd.sign(r) * a : pd.sign(r) * a : t.ctrlKey || t.metaKey ? Math.abs(r) > 5 ? pd.sign(r) * s : pd.sign(r) : Math.abs(r) > 5 ? a * pd.sign(r) : s * pd.sign(r), r *= o;
                    var d = pd.incrementBy(+e.value(), r);
                    e.formatter(pd.constrainTo(d, n, i))
                }
            }), this.incrementValue = function (t, e, r) {
                this.incrementor(r, t)
            }
        },
        template: '        <table class="numeric-slider">            <tr>                <td colspan="3">                    <h4 data-bind="html: title"></h4>                </td>            </tr>            <tr>                <td>                    <div class="btn-group" role="group">                        <button type="button" class="btn btn-default btn-increment no-touch" data-bind="repeatButton: $data.incrementValue.bind($data, -10)"><span class="glyphicon glyphicon-chevron-left"></span></button>                        <button type="button" class="btn btn-default btn-increment no-touch" data-bind="repeatButton: $data.incrementValue.bind($data, -1)"><small><span class="glyphicon glyphicon-chevron-left"></span></small></button>                    </div>                </td>                <td class="pad-sides-4px">                    <input type="text" data-bind="numericInput: $data.value, numericOptions: { formatter: $data.formatter, incrementor: $data.incrementor }" class="form-control text-center" />                </td>                <td>                    <div class="btn-group" role="group">                        <button type="button" class="btn btn-default btn-increment no-touch" data-bind="repeatButton: $data.incrementValue.bind($data, 1)"><small><span class="glyphicon glyphicon-chevron-right"></span></small></button>                        <button type="button" class="btn btn-default btn-increment no-touch" data-bind="repeatButton: $data.incrementValue.bind($data, 10)"><span class="glyphicon glyphicon-chevron-right"></span></button>                    </div>                </td>            </tr>            <tr>                <td colspan="3">                    <input type="range" class="numeric" data-bind="attr: { min: min, max: max, step: step }, numericSlider: $data.value, numericOptions: { incrementor: $data.incrementor }"/>                </td>            </tr>        </table>'
    })
}(), Date.prototype.addDecimalHours = function (t) {
    var e = new Date;
    return e.setTime(this.getTime() + 60 * t * 60 * 1e3), e
}, Date.prototype.isLeapYear = function () {
    var t = this.getFullYear();
    return 0 == (3 & t) && (t % 100 != 0 || t % 400 == 0)
}, Date.prototype.getDOY = function () {
    var t = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], e = this.getMonth(), r = this.getDate() - 1,
        n = t[e] + r;
    return e > 1 && this.isLeapYear() && n++, n
}, (pd = pd || {}).SolarPosition = function (t) {
    function e(t, e, r) {
        return r = r || T, !(t > e + r || t < e - r)
    }

    function r(t, e) {
        return e > 0 ? e * Math.round(t / e) : t
    }

    function n(t, e, r) {
        return isNaN(t) ? e : t < e ? e : t > r ? r : t
    }

    function i(t, e, r) {
        return t < e ? t + (r - e) : t > r ? t - (r - e) : t
    }

    function a(t) {
        return "ERROR: '" + t + "' property is read-only."
    }

    function s(t) {
        if (rt) {
            var e = t / 24, r = 1 - e;
            j = r * nt + e * it, $ = r * at + e * st, K = r * ot + e * ht, Z = r * dt + e * ut, tt = r * ct + e * lt
        }
    }

    function o() {
        rt ? (nt = _.calcJulianCenturiesByMonth(H, Y, G), at = _.calcSolarDeclination(nt), ct = _.calcEquationOfTime(nt), ot = Math.cos(at), dt = Math.sin(at), it = _.calcJulianCenturiesByMonth(H + 1, Y, G), st = _.calcSolarDeclination(it), lt = _.calcEquationOfTime(it), ht = Math.cos(st), ut = Math.sin(st), j = .5 * (nt + it), $ = .5 * (at + st), K = .5 * (ot + ht), Z = .5 * (dt + ut), tt = .5 * (ct + lt)) : (j = _.calcJulianCenturiesByMonth(H, Y, G), $ = _.calcSolarDeclination(j), tt = _.calcEquationOfTime(j), K = Math.cos($), Z = Math.sin($)), et = 12 - tt - P + q;
        for (var t, e, r = U * Z, i = B * K, a = 0; a < 5; a++) (t = (e = (C[a] - r) / i) <= -1 ? 12 : e >= 1 ? 0 : Math.acos(e) / A) < 11.999 ? (Q[a] = n(et - t, 0, 24), J[a] = n(et + t, 0, 24)) : (Q[a] = 0, J[a] = 24);
        S = !1
    }

    function d() {
        s(X);
        var t = ((X - R + tt) / 24 * D + z) % D - Math.PI,
            e = Math.acos(Math.max(-1, Math.min(1, U * Z + B * K * Math.cos(t)))), r = B * Math.sin(e);
        t < -Math.PI && (t += D), Math.abs(r) > 1e-6 && (t = (t > 0 ? -1 : 1) * (Math.PI - Math.acos(Math.max(-1, Math.min(1, (U * Math.cos(e) - Z) / r))))), t < 0 && (t += D);
        var n = 90 - e * b;
        if (n <= 85) {
            var a = Math.tan(n * x);
            e -= (n > 5 ? 58.1 / a - .07 / (a * a * a) + 86e-6 / (a * a * a * a * a) : n > -.575 ? 1735 + n * (n * (103.4 + n * (.711 * n - 12.79)) - 518.2) : -20.774 / a) / 3600 * x
        }
        pt = i(90 - e * b, -180, 180), ft = i(t * b, -180, 180), I = !1
    }

    function h() {
        S ? (o(), d()) : I && d()
    }

    function u(t) {
        return 0 == (3 & t) && (t % 100 != 0 || t % 400 == 0)
    }

    function c(t, e, r) {
        return e = n(e, 0, 11), (u(r) ? w : O)[e] + t - 1
    }

    function l(t) {
        return (357.52911 + t * (35999.05029 - 1537e-7 * t)) * x
    }

    function p(t) {
        var e = l(t);
        return (Math.sin(e) * (1.914602 - t * (.004817 + 14e-6 * t)) + Math.sin(e + e) * (.019993 - 101e-6 * t) + 289e-6 * Math.sin(e + e + e)) * x
    }

    function f(t) {
        var e = (280.46646 + t * (36000.76983 + 3032e-7 * t)) % 360;
        return (e < 0 ? e + 360 : e) * x
    }

    function m(t) {
        return f(t) + p(t)
    }

    function g(t) {
        return m(t) - (.00569 + .00478 * Math.sin((125.04 - 1934.136 * t) * x)) * x
    }

    function v(t) {
        return (23 + (26 + (21.448 - t * (46.815 + t * (59e-5 - .001813 * t))) / 60) / 60) * x
    }

    function y(t) {
        return v(t) + .00256 * Math.cos((125.04 - 1934.136 * t) * x) * x
    }

    function M(t) {
        return .016708634 - t * (42037e-9 + 1.267e-7 * t)
    }

    var x = Math.PI / 180, b = 180 / Math.PI, D = 2 * Math.PI, T = 1e-6,
        w = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
        O = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], A = .26179938779915,
        C = [0, -.014543897651582, -.104528463267654, -.207911690817759, -.309016994374947], _ = this, S = !0, I = !0;
    t = t || {};
    var k = isNaN(t.latitude) ? 54.15197 : t.latitude, N = isNaN(t.longitude) ? -4.48524 : t.longitude,
        V = isNaN(t.timezone) ? 0 : t.timezone, E = isNaN(t.northOffset) ? 0 : t.northOffset, L = 15 * V, R = L / 15,
        P = (N - L) / 15, z = N * x, F = k * x, B = Math.cos(F), U = Math.sin(F), q = 0, H = 1, Y = 3,
        G = (new Date).getFullYear(), X = 10, W = 90, j = 0, $ = 0, K = 0, Z = 0, Q = [0, 0, 0, 0, 0],
        J = [24, 24, 24, 24, 24], tt = 0, et = 0, rt = !!t.interpolateDeclination || !1, nt = 0, it = 0, at = 0, st = 0,
        ot = 0, dt = 0, ht = 0, ut = 0, ct = 0, lt = 0, pt = 0, ft = 0;
    return this.calculate = function () {
        return h(), _
    }, this.getSunAnglesArray = function (t) {
        return h(), t ? (t[0] = ft, t[1] = pt) : t = [ft, pt], t
    }, this.getSunAnglesObject = function () {
        return h(), {azi: ft, alt: pt}
    }, this.getSunDirection = function () {
        azi = ft * x, alt = pt * x;
        var t = Math.cos(alt);
        return [t * Math.sin(azi), t * Math.cos(azi), Math.sin(alt)]
    }, this.getDateObject = function () {
        var t = G, e = n(Y, 0, 11), r = H, a = X - V;
        if (a < 0) a = i(a, 0, 24), --r < 0 && (--e < 0 && (e = 11, --t), r = (s = u(t) ? w : O)[e] - 1); else if (a >= 24) {
            a = i(a, 0, 24);
            var s = u(t) ? w : O;
            ++r >= s[e] && (++e > 11 && (e = 0, ++t), r = 0)
        }
        var o = n(Math.floor(a), 0, 24), d = n(Math.round(60 * (a - o)), 0, 60);
        return d > 59.5 && (o = o < 23 ? o + 1 : 0, d = 0), new Date(Date.UTC(t, e, r, o, d, 0))
    }, this.copyLocation = function (t) {
        return t instanceof pd.SolarPosition && (this.setLocation(t.latitude(), t.longitude(), t.timezone()), this.setDayMonthYear(t.dayOfMonth(), t.monthOfYear(), t.year())), _
    }, this.setLocation = function (t, r, a) {
        if (arguments.length < 2) throw new Error("This method requires at least latitude and longitude as arguments.");
        return t = n(parseFloat(t), -89.9, 89.9), r = i(parseFloat(r), -180, 180), a = pd.toNumber(a, this.calcDefaultTimezone(r)), e(k, t, T) && e(N, r, T) && e(V, a, 1 / 3600) || (S = !0), k = t, N = r, V = a, L = 15 * V, R = L / 15, P = (N - L) / 15, z = N * x, F = k * x, B = Math.cos(F), U = Math.sin(F), q = 0, _
    }, this.setDateTime = function (t) {
        return t && !isNaN(t.getTime()) && (_.setDayMonthYear(t.getDate(), t.getMonth(), t.getFullYear()), _.setTime(t)), _
    }, this.setDate = function (t) {
        return t && !isNaN(t.getTime()) && _.setDayMonthYear(t.getDate(), t.getMonth(), t.getFullYear()), _
    }, this.setTime = function (t) {
        return t && !isNaN(t.getTime()) && _.setTimeOfDay(t.getHours() + t.getMinutes() / 60 + t.getSeconds() / 3600), _
    }, this.setDayOfYear = function (t, e) {
        t = n(t, 0, u(e = e ? parseFloat(e) : G) ? 365 : 364);
        for (var r = n(Math.ceil(t / 30) + 1, 0, 11), i = u(e) ? w : O, a = r; a >= 0; a--) if (t >= i[a]) {
            _.setDayMonthYear(t - i[a] + 1, a, e);
            break
        }
        return _
    }, this.setDayMonthYear = function (t, e, r) {
        return t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), H == t && Y == e && G == r || (W = -1, S = !0), H = t, Y = e, G = r, _
    }, this.setTimeOfDay = function (t) {
        return t = n(t, 0, 24), e(X, t, 1 / 3600) || (I = !0), X = t, _
    }, this.setDateTimeAndGetArray = function (t) {
        return t && !isNaN(t.getTime()) && (_.setDayMonthYear(t.getDate(), t.getMonth(), t.getFullYear()), _.setTime(t)), _.getSunAnglesArray()
    }, this.setTimeAndGetArray = function (t) {
        return _.setTime(t).getSunAnglesArray()
    }, this.setTimeOfDayAndGetArray = function (t) {
        return _.setTimeOfDay(t).getSunAnglesArray()
    }, this.getPosition3D = function (t, e, r, n) {
        r *= x, n *= x;
        var i = e * Math.cos(n);
        return [t[0] + i * Math.sin(r), t[1] + i * Math.cos(r), t[2] + e * Math.sin(n)]
    }, this.getDailySunPathSegmentsAsArray = function (t, e, r) {
        var i = [[]], a = i[0];
        t = n(parseFloat(t), 1 / 60, 6), e = isNaN(e) ? 0 : e, r = isNaN(r) ? 24 : r, h();
        for (var s = e; s < r; s += t) _.setTimeOfDay(s), d(), a.push([ft, pt]);
        return _.setTimeOfDay(r), d(), a.push([ft, pt]), i
    }, this.getAnalemmaSunPathsAsArray = function (t, e, r, a) {
        var s = [];
        t = n(t, 1, 90), e = n(parseFloat(e), 0, 24), isNaN(e) && (e = 0), r = n(parseFloat(r), 0, 24), (isNaN(r) || r <= e) && (r = 24), a = n(parseFloat(a), 1 / 60, 6), isNaN(a) && (r = 1);
        for (var o, u = 0, c = e; c < r; c += a) s.push([]), u++;
        for (var l = 0; l <= 364; l += t) {
            this.setDayOfYear(l, G), h(), o = 0;
            for (c = e; c < r; c += a) _.setTimeOfDay(i(c, 0, 24)), d(), s[o].push([ft, pt]), o++
        }
        this.setDayOfYear(0, G), h(), o = 0;
        for (c = e; c < r; c += a) _.setTimeOfDay(i(c, 0, 24)), d(), s[o].push([ft, pt]), o++;
        return s
    }, this.getHourlySunPathAsArray = function (t, e, i) {
        var a = [], s = n(parseFloat(e), 0, 24);
        isNaN(s) && (s = 0);
        var o = n(parseFloat(i), 0, 24);
        (isNaN(o) || o <= s) && (o = 24), t = n(parseFloat(t), 1 / 60, 6), this.setTimeOfDay(s), h(), a.push([ft, pt]);
        for (var u = s = r(s + t, t); u < o; u += t) this.setTimeOfDay(u), d(), a.push([ft, pt]);
        return this.setTimeOfDay(o), d(), a.push([ft, pt]), a
    }, this.getHourlySunPathAsPositions3D = function (t, e, r, i, a) {
        a = a || {vertices: [], lines: []}, t = n(t, 1 / 60, 6);
        // console.log('3897')
        var s = a.vertices.length;
        this.setTimeOfDay(0), h(), a.vertices.push(this.getPosition3D(e, r, ft, pt));
        for (var o = t; o < 24; o += t) this.setTimeOfDay(o), d(), a.vertices.push(this.getPosition3D(e, r, ft, pt)), (i || s % 2) && a.lines.push([s, s + 1]), s++;
        return this.setTimeOfDay(24), d(), a.vertices.push(this.getPosition3D(e, r, ft, pt)), a.lines.push([s, ++s]), a
    }, this.reuseHourlySunPathAsPositions3D = function (t, e, r, i, a) {
        var s, o;
        if (!a || !a.vertices) return this.getHourlySunPathAsPositions3D(t, e, r, i, null);
        t = n(t, 1 / 60, 6), this.setTimeOfDay(0), h(), s = a.addVertex(this.getPosition3D(e, r, ft, pt));
        for (var u = t; u < 24; u += t) this.setTimeOfDay(u), d(), o = a.addVertex(this.getPosition3D(e, r, ft, pt)), (i || s % 2) && a.addLine(s, o), s = o;
        return (i || s % 2) && (this.setTimeOfDay(24), d(), o = a.addVertex(this.getPosition3D(e, r, ft, pt)), a.addLine(s, o)), a
    }, this.getAnalemmaSunPathAsArray = function (t) {
        var e = [];
        t = n(t, 1, 90), this.setDayOfYear(0, G), h(), e.push([ft, pt]);
        for (var r = t; r <= 364; r += t) this.setDayOfYear(r, G), o(), d(), e.push([ft, pt]);
        return this.setDayOfYear(0, G), o(), d(), e.push([ft, pt]), e
    }, this.getAnalemmaSunPathAsPositions3D = function (t, e, r, i, a) {
        t = n(t, 1, 90);
        var s = (a = a || {vertices: [], lines: []}).vertices.length;
        this.setDayOfYear(0, G), o(), d();
        var h = this.getPosition3D(e, r, ft, pt);
        a.vertices.push(h);
        for (var u = 0; u <= 364; u += t) this.setDayOfYear(u, G), o(), d(), a.vertices.push(this.getPosition3D(e, r, ft, pt)), (i || s % 2) && a.lines.push([s, s + 1]), s++;
        return a.vertices.push(h), a.lines.push([s, ++s]), a
    }, this.getSunriseSunsetAsObjectArray = function (t, e) {
        t = n(t, 1, 90);
        var r = u(G) ? 365 : 364;
        e = e || [];
        for (var i = 0; i < r; i += t) this.setDayOfYear(i, G), o(), e.push({
            dayOfYear: i,
            solarNoon: et,
            sunrise: Q[1],
            sunset: J[1],
            civilDawn: Q[2],
            civilDusk: J[2],
            nauticalDawn: Q[3],
            nauticalDusk: J[3],
            astronomicalDawn: Q[4],
            astronomicalDusk: J[4]
        });
        return this.setDayOfYear(r, G), o(), e.push({
            dayOfYear: i,
            solarNoon: et,
            sunrise: Q[1],
            sunset: J[1],
            civilDawn: Q[2],
            civilDusk: J[2],
            nauticalDawn: Q[3],
            nauticalDusk: J[3],
            astronomicalDawn: Q[4],
            astronomicalDusk: J[4]
        }), e
    }, this.twilight = {
        SOLAR_DISK_CENTER: 0,
        SOLAR_DISK_TOP_WITH_ATM_REFRACTION: 1,
        CIVIL: 2,
        NAUTICAL: 3,
        ASTRONOMICAL: 4
    }, this.getDuskDawnData = function () {
        return h(), {
            solarNoon: et,
            sunrise: Q[1],
            sunset: J[1],
            civilDawn: Q[2],
            civilDusk: J[2],
            nauticalDawn: Q[3],
            nauticalDusk: J[3],
            astronomicalDawn: Q[4],
            astronomicalDusk: J[4]
        }
    }, this.getDawnTime = function (t) {
        if (t < this.twilight.SOLAR_DISK_CENTER || t > this.twilight.ASTRONOMICAL) throw"ERROR: 'stage' parameter must be between twilight.SOLAR_DISK_CENTER and twilight.ASTRONOMICAL, inclusive.";
        return h(), Q[t]
    }, this.getDuskTime = function (t) {
        if (t < this.twilight.SOLAR_DISK_CENTER || t > this.twilight.ASTRONOMICAL) throw"ERROR: 'stage' parameter must be between twilight.SOLAR_DISK_CENTER and twilight.ASTRONOMICAL, inclusive.";
        return h(), J[t]
    }, this.latitude = function (t) {
        if (!arguments.length) return k;
        var r = n(parseFloat(t), -89.9, 89.9);
        return e(k, r, T) || (S = !0), k = r, F = k * x, B = Math.cos(F), U = Math.sin(F), _
    }, this.longitude = function (t) {
        if (!arguments.length) return N;
        var r = i(parseFloat(t), -180, 180);
        return e(N, r, T) || (S = !0), N = r, V = this.calcDefaultTimezone(N), L = 15 * V, R = L / 15, P = (N - L) / 15, z = N * x, _
    }, this.timezone = function (t) {
        if (!arguments.length) return V;
        var r = n(parseFloat(t), -14, 14);
        return e(V, r, 1 / 3600) || (S = !0), V = r, L = 15 * V, R = L / 15, P = (N - L) / 15, _
    }, this.northOffset = function (t) {
        return arguments.length ? (E = i(parseFloat(t), -180, 180), _) : E
    }, this.dayOfMonth = function (t) {
        if (!arguments.length) return H;
        var e = n(parseInt(t, 10), 1, 31);
        return H != e && (W = -1, S = !0), H = e, _
    }, this.monthOfYear = function (t) {
        if (!arguments.length) return Y;
        var e = n(parseInt(t, 10), 0, 11);
        return Y != e && (W = -1, S = !0), Y = e, _
    }, this.year = function (t) {
        if (!arguments.length) return G;
        var e = parseInt(t, 10);
        return G != e && (W = -1, S = !0), G = e, _
    }, this.dayOfYear = function (t) {
        return arguments.length ? (_.setDayOfYear(parseInt(t, 10), G), _) : (W < 0 && (W = c(H, Y, G)), W)
    }, this.clockTime = function (t) {
        return arguments.length ? (_.setTimeOfDay(i(parseFloat(t), 0, 24)), _) : X
    }, this.clockTimeUTC = function (t) {
        return arguments.length ? (_.setTimeOfDay(n(parseFloat(t) + V, 0, 24)), _) : X - V
    }, this.solarTime = function (t) {
        if (h(), !arguments.length) return X + tt + P - q;
        var e = parseFloat(t) - tt - P + q;
        return _.setTimeOfDay(i(e, 0, 24)), _
    }, this.solarTimeUTC = function (t) {
        return arguments.length ? _.solarTime(parseFloat(t) + V) : _.solarTime() - V
    }, this.isLeapYear = function () {
        if (arguments.length) throw a("isLeapYear");
        return u(G)
    }, this.dateAsString = function () {
        if (arguments.length) throw a("dateAsString");
        return this.formatAsDate(this.dayOfYear(), G)
    }, this.solarNoon = function () {
        if (arguments.length) throw a("solarNoon");
        return h(), et
    }, this.timezoneCorrection = function () {
        if (arguments.length) throw a("timezoneCorrection");
        return P - q
    }, this.sunriseTime = function () {
        if (arguments.length) throw a("sunriseTime");
        return h(), Q[this.twilight.SOLAR_DISK_TOP_WITH_ATM_REFRACTION]
    }, this.sunsetTime = function () {
        if (arguments.length) throw a("sunsetTime");
        return h(), J[this.twilight.SOLAR_DISK_TOP_WITH_ATM_REFRACTION]
    }, this.azimuthAngle = function () {
        if (arguments.length) throw a("azimuthAngle");
        return h(), ft
    }, this.altitudeAngle = function () {
        if (arguments.length) throw a("altitudeAngle");
        return h(), pt
    }, this.declinationAngle = function () {
        if (arguments.length) throw a("declinationAngle");
        return h(), $ * b
    }, this.hourAngle = function () {
        if (arguments.length) throw a("hourAngle");
        return (12 - _.solarTime()) / 24 * 360
    }, this.hourAngleSolarUTC = function () {
        if (arguments.length) throw a("hourAngleWithTimeZoneOffset");
        return (12 - (X + tt - V)) / 24 * 360
    }, this.eqnOfTime = function () {
        if (arguments.length) throw a("eqnOfTime");
        return tt
    }, this.calcDefaultTimezone = function (t) {
        return r(t, 15) / 15
    }, this.calcDayOfYearIndex = function (t, e, r) {
        return c(t, e, r)
    }, this.formatAsTime = function (t, e) {
        if (t = i(t, 0, 24), e) {
            var r = 3600 * Math.abs(t), a = n(Math.floor(t), 0, 24), s = n(Math.floor(60 * (t - a)), 0, 60),
                o = n(Math.round(r - (3600 * a + 60 * s)), 0, 60);
            return o > 59.5 && (s = s < 59 ? s + 1 : 0, o = 0), s > 59.5 && (a = a < 23 ? a + 1 : 0, s = 0), a < 10 && (a = "0" + a), s < 10 && (s = "0" + s), o < 10 && (o = "0" + o), sign < 0 ? "-" + a + ":" + s + ":" + o : a + ":" + s + ":" + o
        }
        a = Math.floor(t);
        return (s = n(Math.round(60 * (t - a)), 0, 60)) > 59.5 && (a = a < 23 ? a + 1 : 0, s = 0), a < 10 && (a = "0" + a), s < 10 && (s = "0" + s), a + ":" + s
    }, this.formatAsDuration = function (t, e) {
        var r = pd.sign(t);
        if (t = Math.abs(t), e) {
            var i = Math.floor(t), a = 3600 * Math.abs(t), s = n(Math.floor(60 * (t - i)), 0, 60),
                o = n(Math.round(a - (3600 * i + 60 * s)), 0, 60);
            return o > 59.5 && (s = s < 59 ? s + 1 : 0, o = 0), s > 59.5 && (i = i < 23 ? i + 1 : 0, s = 0), i < 10 && (i = "0" + i), s < 10 && (s = "0" + s), o < 10 && (o = "0" + o), r < 0 ? "-" + i + ":" + s + ":" + o : i + ":" + s + ":" + o
        }
        i = Math.floor(t);
        return (s = n(Math.round(60 * (t - i)), 0, 60)) > 59.5 && (i = i < 23 ? i + 1 : 0, s = 0), i < 10 && (i = "0" + i), s < 10 && (s = "0" + s), r < 0 ? "-" + i + ":" + s : i + ":" + s
    }, this.formatAsDate = function (t, e) {
        var r = e || G;
        t = n(t, 0, u(r) ? 366 : 365);
        for (var i = n(Math.ceil(t / 30) + 1, 0, 11), a = u(r) ? w : O, s = i; s >= 0; s--) if (t >= a[s]) {
            var o = Math.floor(n(s, 0, 11)), d = Math.floor(n(t - a[s] + 1, 1, 31)),
                h = ["/ 1", "/ 2", "/ 3", "/ 4", "/ 5", "/ 6", "/ 7", "/ 8", "/ 9", "/ 10", "/ 11", "/ 12"];
            return d < 10 && (d = "0" + d), d + " " + h[o] + (e ? " " + e : "")
        }
        return ""
    }, this.calcJulianCenturies = function (t, e) {
        var r = Math.floor(--e / 100), n = 2 - r + Math.floor(r / 4);
        return (Math.floor(365.25 * (e + 4716)) + t + n - 1524.5 - 2451545) / 36525
    }, this.calcJulianCenturiesByMonth = function (t, e, r) {
        ++e <= 2 && (e += 12, r -= 1);
        var n = Math.floor(--r / 100), i = 2 - n + Math.floor(n / 4);
        return (Math.floor(365.25 * (r + 4716)) + Math.floor(30.6001 * (e + 1)) + t + i - 1524.5 - 2451545) / 36525
    }, this.calcSolarDeclination = function (t) {
        return Math.asin(Math.sin(y(t)) * Math.sin(g(t)))
    }, this.calcEquationOfTime = function (t) {
        var e = M(t), r = l(t), n = f(t), i = Math.tan(y(t) / 2);
        i *= i;
        var a = Math.sin(r);
        return 4 * (i * Math.sin(2 * n) - 2 * e * a + 4 * e * i * a * Math.cos(2 * n) - .5 * i * i * Math.sin(4 * n) - 1.25 * e * e * Math.sin(2 * r))
    }, this
};
