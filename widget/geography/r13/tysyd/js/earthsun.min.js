function jsonSchema() {
    return {
        title: "EarthSun Schema",
        $schema: "http://json-schema.org/schema#",
        id: "http://performativedesign.com/earthsun",
        type: "object",
        properties: {
            location: {
                type: "object",
                description: "Defines a terrestrial location.",
                properties: {
                    latitude: {
                        description: "The terrestrial latitude of the current location, in decimal degrees.",
                        type: "number",
                        minimum: -90,
                        maximum: 90
                    },
                    longitude: {
                        description: "The terrestrial longitude of the current location, in decimal degrees.",
                        type: "number",
                        minimum: -180,
                        maximum: 180
                    },
                    timezone: {
                        description: "The local time zone at the current location, in decimal hours.",
                        type: "number",
                        minimum: -13,
                        maximum: 13
                    }
                }
            },
            datetime: {
                type: "object",
                description: "Defines a specific data and time.",
                properties: {
                    clockTime: {
                        description: "The local clock time, in decimal hours (0.0 to 24.0).",
                        type: "number",
                        minimum: 0,
                        maximum: 24
                    },
                    dayOfMonth: {
                        description: "The day of the month component of the date (1 to 31).",
                        type: "integer",
                        minimum: 0,
                        maximum: 31
                    },
                    monthOfYear: {
                        description: "The month of the year component of the date (0 to 11).",
                        type: "integer",
                        minimum: 0,
                        maximum: 11
                    },
                    year: {
                        description: "The 4 digit year component of the date.",
                        type: "integer",
                        minimum: 0,
                        maximum: 1e6
                    }
                }
            },
            display: {
                type: "object",
                description: "Display settings for 3D model.",
                properties: {
                    surfaceOpacity: {
                        description: "The opacity with which surfaces are rendered (0 to 1).",
                        type: "number",
                        minimum: 0,
                        maximum: 1
                    },
                    surfaceShininess: {
                        description: "The relative specular reflectance of rendered surfaces (0 to 1).",
                        type: "number",
                        minimum: 0,
                        maximum: 500
                    },
                    ambientFactor: {
                        description: "The relative fraction of ambient light in the model (0 to 1).",
                        type: "number",
                        minimum: 0,
                        maximum: 1
                    }
                }
            },
            orbit: {
                type: "object",
                description: "Display settings for solar orbit.",
                properties: {
                    viewType: {
                        description: "Selects between geo-centric or helio-centric view.",
                        type: "number",
                        minimum: 0,
                        maximum: 1
                    },
                    showSunPath: {description: "Show sun-paths at current location.", type: "boolean"},
                    showSubSolar: {description: "Show sub-solar position at current date/time.", type: "boolean"},
                    showTwilight: {description: "Show sunrise/sunset and twilight periods.", type: "boolean"},
                    showEquator: {description: "Show the terrestrial equator line.", type: "boolean"},
                    showTropics: {description: "Show the Tropics of Cancer and Capricorn.", type: "boolean"},
                    showCircles: {description: "Show the Arctic and Antarctic Circles.", type: "boolean"},
                    showSeasons: {description: "Show seasons in helio-centric view.", type: "boolean"}
                }
            },
            animation: {
                type: "object",
                description: "Playable animation settings.",
                properties: {
                    animateTime: {
                        description: "Whether or not to animate the current time when playing.",
                        type: "boolean"
                    },
                    animateDate: {
                        description: "Whether or not to animate the current date when playing.",
                        type: "boolean"
                    },
                    animateLatitude: {
                        description: "Whether or not to animate the location latitude when playing.",
                        type: "boolean"
                    },
                    animateLongitude: {
                        description: "Whether or not to animate the location longitude when playing.",
                        type: "boolean"
                    },
                    daylightOnly: {description: "Only animate times from dawn to dusk.", type: "boolean"},
                    speed: {
                        description: "The relative speed of the playing animation.",
                        type: "number",
                        minimum: 0,
                        maximum: 20
                    }
                }
            }
        }
    }
}

function jsonEditorLoaded() {
    var e = document.getElementById("jsoneditor");
    (jsonEditor = e.contentWindow.jsonEditor) && (jsonEditor.setName("earthsun"), jsonEditor.setSchema(jsonSchema()), e.contentWindow.onChangeHandler = App.Shadows.paramDataEdited, e.classList.remove("loading"), App.Shadows.formatParamData())
}

function loadTextureImages() {
    function e() {
        textureDaylight && textureNightime && textureSun && (null == $snackbarTexture ? $snackbarTexture = !0 : $snackbarTexture.snackbar("hide"))
    }

    var a = new Image;
    a.onload = function () {
        textureDaylight = GL.Texture.fromImage(a, {unit: 0}), e(), gl.update()
    }, a.src = "imgs/world_blue_2048x1024.png";
    var t = new Image;
    t.onload = function () {
        textureNightime = GL.Texture.fromImage(t, {unit: 1}), e(), gl.update()
    }, t.src = "imgs/world_night_2048x1024.png";
    var i = new Image;
    i.onload = function () {
        textureSun = GL.Texture.fromImage(i, {unit: 2}), e(), gl.update()
    }, i.src = "imgs/sun-1024x512.jpg"
}

function intersectSphere(e, a, t, i) {
    var o = e.subtract(t), r = a.dot(a), n = 2 * a.dot(o), s = n * n - 4 * r * (o.dot(o) - i * i);
    if (s > 0) {
        var l = (-n - Math.sqrt(s)) / (2 * r);
        return e.add(a.multiply(l))
    }
    return null
}

function animateOrbitalView(e) {
    function a(a) {
        if ((t += 2 * a) >= 1) return orbitalViewFactor = e, gl.orbitalView.defaultDistance = gl.orbitalView.cameraDistance = s, subSolarPath3D.arrowScale(l), gl.update(), !0;
        var n = pd.Easing.inOutSine(t);
        return gl.orbitalView.cameraAzi = (1 - n) * c + n * p, gl.orbitalView.cameraAlt = (1 - n) * d + n * u, gl.orbitalView.defaultDistance = gl.orbitalView.cameraDistance = (1 - n) * r + n * s, subSolarPath3D.arrowScale((1 - n) * o + n * l), orbitalViewFactor = (1 - n) * i + n * e, gl.orbitalView._zoomFactorMin = .15 + .15 * orbitalViewFactor, gl.update(), !1
    }

    var t = 0, i = orbitalViewFactor, o = subSolarPath3D.arrowScale(), r = gl.orbitalView.cameraDistance,
        n = pd.constrainTo(100 / gl.orbitalView.aspectRatio, 5, 100), s = e < .5 ? 9 : n, l = e < .5 ? 1 : 2.5,
        c = gl.orbitalView.cameraAzi, p = c, d = gl.orbitalView.cameraAlt, u = d;
    5 == App.Camera.viewType() && (p = getHeliocentricCameraAzimuth(), u = getHeliocentricCameraAltitude()), pd.closeTo(i, e) || gl.animationQueue.add(a)
}

function animateTwilightBands(e) {
    function a(a) {
        if ((t += 2 * a) >= 1) return twilightBands = e, gl.update(), !0;
        var o = pd.Easing.outCubic(t);
        return twilightBands = (1 - o) * i + o * e, gl.update(), !1
    }

    var t = 0, i = twilightBands;
    pd.closeTo(i, e) || gl.animationQueue.add(a)
}

function animateCurrentDate(e) {
    function a(a) {
        if ((t += 2.5 * a) >= 1) return App.Shadows.setDayOfYear(e), !0;
        var o = pd.Easing.inOutSine(t);
        return App.Shadows.setDayOfYear((1 - o) * i + o * e), gl.update(), !1
    }

    var t = 0, i = App.Shadows.dayOfYear();
    i > e && (e += 365), pd.closeTo(i, e) || gl.animationQueue.add(a)
}

function animateCurrentTime(e) {
    function a(a) {
        if ((t += 2.5 * a) >= 1) return App.Shadows.setTimeOfDay(e), !0;
        var o = pd.Easing.inOutSine(t);
        return App.Shadows.setTimeOfDay((1 - o) * i + o * e), gl.update(), !1
    }

    var t = 0, i = App.Shadows.timeOfDay();
    pd.closeTo(i, e) || gl.animationQueue.add(a)
}

function formatAngle(e) {
    return (+e).toFixed(2) + "°"
}

function formatSliderAngle(e) {
    return (+e).toFixed(1) + "°"
}

function formatTime(e) {
    return solar.formatAsTime(e / 60)
}

function formatDate(e) {
    return solar.formatAsDate(e)
}

function showTimezoneWarning(e) {
    if (null == $snackbarTimezone) return void(e && ($snackbarTimezone = $.snackbar({
        content: "<strong>WARNING: Invalid Timezone</strong><br />The selected timezone must be within ±4hrs of the current longitude, where each hour equates to 15 degrees <var>(ref = longitude / 15)</var>.",
        style: "warning",
        timeout: 8e3
    })));
    e && !$snackbarTimezone.hasClass("snackbar-opened") ? $snackbarTimezone.snackbar("show") : !e && $snackbarTimezone.hasClass("snackbar-opened") && $snackbarTimezone.snackbar("hide")
}

function calcBestViewAngle() {
    var e = solar.latitude();
    return e < 0 ? pd.mapAndConstrainTo(e, -0, -90, -15, -45) : pd.mapAndConstrainTo(e, 0, 90, 15, 45)
}

function getHeliocentricCameraAzimuth() {
    return appData.orbit.viewType > .5 ? pd.wrapAt(180 + subSolarPath3D.calculateHeliocentricOrbitAngle(solar.dayOfYear(), solar.solarTime()) * pd.Const.RAD2DEG, -180, 180) : solar.hourAngleSolarUTC()
}

function getHeliocentricCameraAltitude() {
    return appData.orbit.viewType > .5 ? 20 : solar.declinationAngle()
}

function regenerateShadows() {
    App.Shadows.timeOfDay.azimuthAngle(formatAngle(solar.azimuthAngle())), App.Shadows.timeOfDay.altitudeAngle(formatAngle(solar.altitudeAngle()));
    var e = (new pd3D.Vector).fromPolarAngles(solarEquator.azimuthAngle() * pd.Const.DEG2RAD, solarEquator.altitudeAngle() * pd.Const.DEG2RAD);
    if (farFieldSunPosition = subSolarTransform.transformPoint(e.multiply(1e4)), nearFieldEathPosition = subSolarTransform.transformPoint(e.multiply(60)), subSolarPath3D.handleTimeChange(e), sunlightDirection.fromPolarAngles(currentSunPos[0] * pd.Const.DEG2RAD, currentSunPos[1] * pd.Const.DEG2RAD), 5 == App.Camera.viewType()) {
        var a = gl.orbitalView.cameraFOV > .5 ? gl.orbitalView.cameraFOV *= .9 : gl.orbitalView.cameraFOV;
        gl.orbitalView.setCamera(getHeliocentricCameraAzimuth(), getHeliocentricCameraAltitude(), a), App.Camera.isPopupActive && App.Camera.updateCameraOnViewChange()
    }
    sunPath3D.handleTimeChange(sunlightDirection)
}

function updateSunPaths() {
    subSolarPath3D.handleLocationChange(), sunPath3D.handleLocationChange(), App.Shadows.updateDawnDuskValues(), subSolarTransform.reset().rotate(90 + solar.longitude(), 0, 0, 1).rotate(90, 1, 0, 0), sunPathTransform.reset().rotate(90 + solar.longitude(), 0, 0, 1).rotate(-solar.latitude(), 1, 0, 0).translate(0, -3.501, 0).rotate(90, 1, 0, 0)
}

function closeActivePopover() {
    null != activePopover && activePopover.popoverX("hide")
}

function AppViewModel() {
    function e() {
        u || (u = setTimeout(a, d))
    }

    function a() {
        u && clearTimeout(u), u = null, solar.latitude(App.Shadows.latitude()), pd.closeTo(solar.longitude(), App.Shadows.longitude()) ? solar.timezone(App.Shadows.timezone()) : (solar.longitude(App.Shadows.longitude()), App.Shadows.timezone(solar.timezone())), solarEquator.longitude(solar.longitude()), solarEquator.timezone(solar.timezone()), updateSunPaths();
        var e = solar.getSunAnglesArray();
        currentSunPos[0] = e[0], currentSunPos[1] = e[1], regenerateShadows(), gl.update()
    }

    function t(e) {
        e && (h = !0), m || (m = setTimeout(i, d))
    }

    function i() {
        m && clearTimeout(m), m = null, h && (solar.setDayOfYear(App.Shadows.dayOfYear()), solarEquator.setDayOfYear(solar.dayOfYear())), solar.setTimeOfDay(App.Shadows.timeOfDay() / 60), solarEquator.setTimeOfDay(solar.clockTime());
        var e = solar.getSunAnglesArray();
        e[0] == currentSunPos[0] && e[1] == currentSunPos[1] || (currentSunPos[0] = e[0], currentSunPos[1] = e[1], regenerateShadows()), h && (App.Shadows.updateDawnDuskValues(), subSolarPath3D.handleDateChange(), sunPath3D.handleDateChange(), h = !1), gl.update()
    }

    function o() {
        var e = this;
        this.title = ko.observable("Save File"), this.message = ko.observable("Enter the filename to save your data as:"), this.filename = ko.observable("[No Name]"), this.extension = ko.observable(".json"), this.action = ko.observable(), this.selectAndFocus = function () {
            $("#modal-save").find("input[type=text]").focus().select()
        }, this.open = function () {
            $("#modal-save").modal("show")
        }, this.close = function () {
            $("#modal-save").modal("hide")
        }, this.submitFile = function () {
            var a = e.filename().toString();
            if (a && a.length > 0) {
                var t = e.extension();
                if (!pd.endsWith(a, t)) return e.filename(a + t), void e.selectAndFocus();
                var i = e.action() ? e.action() : null;
                if (i && i(a)) return void e.close()
            }
            e.selectAndFocus()
        }
    }

    function r() {
        var e = this;
        this.viewType = ko.observable(appData.orbit.viewType), this.viewType.subscribe(function (e) {
            App.Camera.setZoom(0), appData.orbit.viewType = parseInt(e, 10);
            var a = solar.latitude() < 0;
            seasonsMesh.southernHemisphere !== a && subSolarPath3D.generateHeliocentricSeasonsMesh(seasonsMesh, 34.5, a), animateOrbitalView(appData.orbit.viewType > .5 ? 1 : 0)
        }), this.sunPath = ko.observable(appData.orbit.showSunPath), this.sunPath.subscribe(function (e) {
            appData.orbit.showSunPath = e, gl.update()
        }), this.subSolarIndicators = ko.observable(appData.orbit.showSubSolar), this.subSolarIndicators.subscribe(function (e) {
            subSolarPath3D.components().currentSunPath.show(e), subSolarPath3D.components().solarArrow.show(e || subSolarPath3D.components().declinationPlane.visible), subSolarPath3D.components().solarSphere.show(subSolarPath3D.components().solarArrow.visible), appData.orbit.showSubSolar = e, gl.update()
        }), this.twilightBands = ko.observable(appData.orbit.showTwilight), this.twilightBands.subscribe(function (e) {
            subSolarPath3D.components().solarArrow.show(e || subSolarPath3D.components().currentSunPath.visible), subSolarPath3D.components().solarSphere.show(subSolarPath3D.components().solarArrow.visible), subSolarPath3D.components().declinationPlane.show(e), subSolarPath3D.components().twilightLines.show(e), animateTwilightBands(e ? .5 : 0), appData.orbit.showTwilight = e, gl.update()
        }), this.equatorLine = ko.observable(appData.orbit.showEquator), this.equatorLine.subscribe(function (e) {
            subSolarPath3D.components().baseDiagram.show(e), subSolarPath3D.components().baseDiagramText.show(e), appData.orbit.showEquator = e, gl.update()
        }), this.tropicsLines = ko.observable(appData.orbit.showTropics), this.tropicsLines.subscribe(function (e) {
            subSolarPath3D.components().annualShell.show(e), subSolarPath3D.components().tropicsLines.show(e), appData.orbit.showTropics = e, gl.update()
        }), this.circleLines = ko.observable(appData.orbit.showCircles), this.circleLines.subscribe(function (e) {
            subSolarPath3D.components().circleLines.show(e), appData.orbit.showCircles = e, gl.update()
        }), this.componentsShow = ko.observable(!0), this.toggleComponents = function () {
            e.componentsShow(!e.componentsShow()), $("#btn-components-title").blur()
        }
    }

    function n() {
        var e = this;
        this.viewAzimuth = ko.observable(60).extend({fixedPrecision: 2}), this.viewAzimuth.subscribe(function (a) {
            e.viewAzimuth.undoIgnore || (gl.orbitalView.cameraAzi = pd.wrapAt(a, -180, 180), e.updateViewTypeFromCamera(), gl.update())
        }), this.viewAltitude = ko.observable(30).extend({fixedPrecision: 2}), this.viewAltitude.subscribe(function (a) {
            e.viewAltitude.undoIgnore || (gl.orbitalView.cameraAlt = pd.wrapAt(a, -180, 180), e.updateViewTypeFromCamera(), gl.update())
        }), this.viewAngle = ko.observable(45).extend({fixedPrecision: 2}), this.viewAngle.subscribe(function (a) {
            e.viewAngle.undoIgnore || (gl.orbitalView.cameraFOV = pd.constrainTo(a, 0, 160), gl.orbitalView.hasChanged = gl.PROJECTION, e.updateViewTypeFromCamera(), gl.update())
        }), this.incrementZoom = function (e, a, t) {
            (e = parseFloat(e)) && (t && (t.ctrlKey || t.metaKey ? e /= 10 : t.shiftKey && (e *= 10)), gl.orbitalView.hasChanged = gl.PROJECTION, gl.orbitalView.zoom(.025 * e))
        }, this.setZoom = function (e) {
            pd.isNumeric(e) && (e = pd.constrainTo(parseFloat(e), -1, 1), Math.abs(e) > 1e-4 ? gl.orbitalView.zoom(e) : (gl.orbitalView.hasChanged = gl.PROJECTION, gl.orbitalView.center()))
        }, this.isPopupActive = !1, this.updateCameraOnViewChange = function (a, t) {
            p.resetValue(e.viewAzimuth, gl.orbitalView.cameraAzi), p.resetValue(e.viewAltitude, gl.orbitalView.cameraAlt), p.resetValue(e.viewAngle, gl.orbitalView.cameraFOV), t > .99 && 5 == e.viewType() && p.Animation.pause(!1)
        }, this.updateViewTypeFromCamera = function () {
            gl.orbitalView.cameraFOV > .5 ? 0 != e.viewType() && e.setViewType(0, !0) : pd.closeTo(gl.orbitalView.cameraAzi, getHeliocentricCameraAzimuth(), .1) && pd.closeTo(gl.orbitalView.cameraAlt, getHeliocentricCameraAltitude(), .1) ? e.setViewType(5, !0) : pd.closeTo(gl.orbitalView.cameraAlt, 90, .5) ? e.setViewType(2, !0) : pd.closeTo(gl.orbitalView.cameraAlt, 90, .5) ? e.setViewType(2, !0) : pd.closeTo(gl.orbitalView.cameraAlt, 0, .5) ? pd.closeTo(gl.orbitalView.cameraAzi, -90, .5) ? e.setViewType(3, !0) : pd.closeTo(gl.orbitalView.cameraAzi, 0, .5) ? e.setViewType(4, !0) : e.setViewType(1, !0) : e.setViewType(1, !0)
        }, this.setViewType = function (a, t) {
            t ? p.resetValue(e.viewType, a) : e.viewType(a)
        }, this.viewType = ko.observable(0), this.viewType.subscribe(function (a) {
            if (!e.viewType.undoIgnore) switch (a) {
                default:
                case 0:
                    var t = gl.orbitalView.cameraAlt > 2.5 && gl.orbitalView.cameraAlt < 87.5;
                    gl.orbitalView.animateTo({
                        cameraAzi: t ? gl.orbitalView.cameraAzi : -55,
                        cameraAlt: t ? gl.orbitalView.cameraAlt : 30,
                        cameraFOV: 45
                    }, e.updateCameraOnViewChange);
                    break;
                case 1:
                    gl.orbitalView.animateTo({cameraAzi: -45, cameraAlt: 45, cameraFOV: 0}, e.updateCameraOnViewChange);
                    break;
                case 2:
                    gl.orbitalView.animateTo({cameraAzi: -90, cameraAlt: 90, cameraFOV: 0}, e.updateCameraOnViewChange);
                    break;
                case 3:
                    gl.orbitalView.animateTo({cameraAzi: -90, cameraAlt: 0, cameraFOV: 0}, e.updateCameraOnViewChange);
                    break;
                case 4:
                    gl.orbitalView.animateTo({cameraAzi: 0, cameraAlt: 0, cameraFOV: 0}, e.updateCameraOnViewChange);
                    break;
                case 5:
                    gl.orbitalView.animateTo({
                        target: GL.keys.SHIFT ? sunPath3D.center() : null,
                        cameraAzi: getHeliocentricCameraAzimuth(),
                        cameraAlt: getHeliocentricCameraAltitude(),
                        cameraFOV: 0
                    }, e.updateCameraOnViewChange), p.Animation.pause(!0)
            }
        })
    }

    function s() {
        function a(e) {
            if (e && e.length > 0) {
                i.formatParamData(!0);
                var a = i.paramData(), t = document.createElement("a");
                return t.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(a)), t.setAttribute("download", e), t.click(), !0
            }
            return !1
        }

        var i = this;
        this.surfaceOpacity = ko.observable(appData.display.surfaceOpacity), this.surfaceOpacity.subscribe(function (e) {
            appData.display.surfaceOpacity = parseFloat(e), gl.update()
        }), this.surfaceShininess = ko.observable(appData.display.surfaceShininess), this.surfaceShininess.subscribe(function (e) {
            appData.display.surfaceShininess = parseFloat(e), specularFactor = pd.mapAndConstrainTo(appData.display.surfaceShininess, 0, 50, .02, .25), gl.update()
        }), this.ambientFactor = ko.observable(appData.display.ambientFactor), this.ambientFactor.subscribe(function (e) {
            appData.display.ambientFactor = parseFloat(e), diffuseFactor = 1 - appData.display.ambientFactor, gl.update()
        }), this.latitude = ko.observable(solar.latitude()), this.latitude.subscribe(function (a) {
            orbitalViewFactor > .5 && subSolarPath3D.generateHeliocentricSeasonsMesh(seasonsMesh, 34.5, a < 0), e()
        }), this.longitude = ko.observable(solar.longitude()), this.longitude.subscribe(function (a) {
            e()
        }), this.timezone = ko.observable(solar.timezone()), this.timezone.subscribe(function (a) {
            var t = Math.round(solar.longitude() / 15);
            Math.abs(a - t) < 4.01 ? (solar.timezone(a), i.timezone.ignore || showTimezoneWarning(!1), e()) : (i.timezone.ignore = !0, i.timezone(solar.timezone()), i.timezone.ignore = !1, showTimezoneWarning(!0))
        }), this.timezone.formatter = ko.pureComputed(function () {
            return (i.timezone() >= 0 ? "+" : "-") + solar.formatAsTime(Math.abs(i.timezone()))
        }), this.timezone.incrementor = function (e, a) {
            if (a = parseFloat(a)) {
                a = pd.sign(a);
                for (var t, o = document.getElementById("input-timezone"), r = parseFloat(o.options[o.selectedIndex].value), n = o.selectedIndex + a; n >= 0 && n < o.length;) {
                    if (t = parseFloat(o.options[n].value), !pd.closeTo(r, t, .1)) {
                        r = t;
                        break
                    }
                    n += a
                }
                i.timezone(r)
            }
        }, this.dayOfYear = ko.observable(solar.dayOfYear()), this.dayOfYear.subscribe(function (e) {
            t(!0)
        }), this.setDayOfYear = function (e) {
            this.dayOfYear(Math.round(pd.wrapAt(e, 0, 365)))
        }, this.dayOfYear.formatter = ko.pureComputed({
            read: function () {
                return solar.formatAsDate(i.dayOfYear(), solar.year())
            }, write: function (e) {
                var a = Date.parse(e.toString());
                if (pd.isNumeric(a)) {
                    var o = new Date;
                    o.setTime(a);
                    var r = solar.calcDayOfYearIndex(o.getDate(), o.getMonth(), o.getFullYear()),
                        n = solar.year() != o.getFullYear();
                    solar.year(o.getFullYear()), i.dayOfYear(r), n && (svgSlider.setYear(solar.year()), t(!0))
                } else i.dayOfYear.valueHasMutated()
            }, owner: this
        }), this.dayOfYear.incrementor = function (e, a) {
            if (a = parseFloat(a)) {
                var t = parseInt(i.dayOfYear(), 10);
                if (!e || e.type && e.type.indexOf("move") < 0 || e.event.type && e.event.type.indexOf("move") < 0) if (Math.abs(a) > 5 || e && e.shiftKey) {
                    var o = solar.getDateObject(), r = o.getMonth() + (a > 0 ? 1 : -1);
                    o.setMonth(pd.wrapAt(r, 0, 12, !0)), t = solar.calcDayOfYearIndex(o.getDate(), o.getMonth(), o.getFullYear())
                } else t += a > 0 ? 1 : -1; else t = Math.round(t + a);
                i.dayOfYear(pd.wrapAt(t, 0, solar.isLeapYear() ? 366 : 365, !0))
            }
        };
        var o = solar.getDuskDawnData();
        this.dayOfYear.solarNoon = ko.observable(solar.formatAsTime(o.solarNoon)), this.dayOfYear.civilTwilight = ko.observable(solar.formatAsTime(o.civilDawn) + " / " + solar.formatAsTime(o.civilDusk)), this.dayOfYear.nauticalTwilight = ko.observable(solar.formatAsTime(o.nauticalDawn) + " / " + solar.formatAsTime(o.nauticalDusk)), this.dayOfYear.astronomicalTwilight = ko.observable(solar.formatAsTime(o.astronomicalDawn) + " / " + solar.formatAsTime(o.astronomicalDusk)), this.dayOfYear.dayLength = ko.observable(solar.formatAsTime(o.sunset - o.sunrise)), this.dayOfYear.sunriseTime = ko.observable(solar.formatAsTime(o.sunrise)), this.dayOfYear.sunsetTime = ko.observable(solar.formatAsTime(o.sunset)), this.updateDawnDuskValues = function () {
            var e = solar.getDuskDawnData();
            i.dayOfYear.solarNoon(solar.formatAsTime(e.solarNoon)), i.dayOfYear.civilTwilight(solar.formatAsTime(e.civilDawn) + " / " + solar.formatAsTime(e.civilDusk)), i.dayOfYear.nauticalTwilight(solar.formatAsTime(e.nauticalDawn) + " / " + solar.formatAsTime(e.nauticalDusk)), i.dayOfYear.astronomicalTwilight(solar.formatAsTime(e.astronomicalDawn) + " / " + solar.formatAsTime(e.astronomicalDusk)), i.dayOfYear.dayLength(solar.formatAsTime(e.sunset - e.sunrise)), i.dayOfYear.sunriseTime(solar.formatAsTime(e.sunrise)), i.dayOfYear.sunsetTime(solar.formatAsTime(e.sunset))
        }, this.setUsefulDate = function (e) {
            switch (e) {
                case 0:
                    animateCurrentDate(solar.calcDayOfYearIndex(21, solar.latitude() < 0 ? 11 : 5, solar.year()));
                    break;
                case 1:
                    animateCurrentDate(solar.calcDayOfYearIndex(21, solar.latitude() < 0 ? 2 : 8, solar.year()));
                    break;
                case 2:
                    animateCurrentDate(solar.calcDayOfYearIndex(21, solar.latitude() < 0 ? 5 : 11, solar.year()));
                    break;
                case 3:
                    animateCurrentDate(solar.calcDayOfYearIndex(21, solar.latitude() < 0 ? 8 : 2, solar.year()))
            }
        }, this.setNextUsefulDate = function (e) {
            var a = solar.dayOfYear();
            solar.latitude() < 0 ? a < solar.calcDayOfYearIndex(21, 2, solar.year()) ? i.setUsefulDate(1) : a < solar.calcDayOfYearIndex(21, 5, solar.year()) ? i.setUsefulDate(2) : a < solar.calcDayOfYearIndex(21, 8, solar.year()) ? i.setUsefulDate(3) : a < solar.calcDayOfYearIndex(21, 11, solar.year()) ? i.setUsefulDate(0) : i.setUsefulDate(1) : a < solar.calcDayOfYearIndex(21, 2, solar.year()) ? i.setUsefulDate(3) : a < solar.calcDayOfYearIndex(21, 5, solar.year()) ? i.setUsefulDate(0) : a < solar.calcDayOfYearIndex(21, 8, solar.year()) ? i.setUsefulDate(1) : a < solar.calcDayOfYearIndex(21, 11, solar.year()) ? i.setUsefulDate(2) : i.setUsefulDate(3)
        }, this.timeOfDay = ko.observable(60 * solar.clockTime()), this.timeOfDay.subscribe(function (e) {
            t(!1)
        }), this.setTimeOfDay = function (e) {
            this.timeOfDay(Math.round(pd.wrapAt(e, 0, 1440)))
        }, this.timeOfDay.formatter = ko.pureComputed({
            read: function () {
                return solar.formatAsTime(i.timeOfDay() / 60)
            }, write: function (e) {
                var a = pd.DateTime.parseTimeToDecimalHours(e);
                a = pd.constrainTo(pd.isNumeric(a) ? a : 0, 0, 24), i.timeOfDay(60 * a)
            }, owner: this
        }), this.timeOfDay.incrementor = function (e, a) {
            if (a = parseFloat(a)) {
                a = e && e.shiftKey ? Math.abs(a) < 5 ? 30 * pd.sign(a) : Math.abs(a) < 10 ? 15 * pd.sign(a) : 180 * pd.sign(a) : e && (e.ctrlKey || e.metaKey) ? Math.abs(a) < 10 ? pd.sign(a) : 5 * pd.sign(a) : Math.abs(a) < 10 ? 5 * pd.sign(a) : 30 * pd.sign(a);
                var t = pd.incrementBy(i.timeOfDay(), a);
                i.timeOfDay(pd.wrapAt(t, 0, 1440, !0))
            }
        }, this.timeOfDay.azimuthAngle = ko.observable("0.000°"), this.timeOfDay.altitudeAngle = ko.observable("0.000°"), this.setUsefulTime = function (e) {
            switch (e) {
                case 0:
                    animateCurrentTime(60 * solar.getDawnTime(solar.twilight.ASTRONOMICAL));
                    break;
                case 1:
                    animateCurrentTime(60 * solar.getDawnTime(solar.twilight.NAUTICAL));
                    break;
                case 2:
                    animateCurrentTime(60 * solar.getDawnTime(solar.twilight.CIVIL));
                    break;
                case 3:
                    animateCurrentTime(60 * solar.getDawnTime(solar.twilight.SOLAR_DISK_TOP_WITH_ATM_REFRACTION));
                    break;
                case 4:
                    animateCurrentTime(720);
                    break;
                case 5:
                    animateCurrentTime(60 * solar.solarNoon());
                    break;
                case 6:
                    animateCurrentTime(60 * solar.getDuskTime(solar.twilight.SOLAR_DISK_TOP_WITH_ATM_REFRACTION));
                    break;
                case 7:
                    animateCurrentTime(60 * solar.getDuskTime(solar.twilight.CIVIL));
                    break;
                case 8:
                    animateCurrentTime(60 * solar.getDuskTime(solar.twilight.NAUTICAL));
                    break;
                case 9:
                    animateCurrentTime(60 * solar.getDuskTime(solar.twilight.ASTRONOMICAL))
            }
        }, this.setNextUsefulTime = function () {
            var e = solar.clockTime() + 1 / 120, a = solar.getDuskDawnData(), t = 12, o = 4, r = a.solarNoon, n = 5;
            a.solarNoon < 12 && (t = a.solarNoon, o = 5, r = 12, n = 4), e < a.astronomicalDawn ? i.setUsefulTime(0) : e < a.nauticalDawn ? i.setUsefulTime(1) : e < a.civilDawn ? i.setUsefulTime(2) : e < a.sunrise ? i.setUsefulTime(3) : e < t ? i.setUsefulTime(o) : e < r ? i.setUsefulTime(n) : e < a.sunset ? i.setUsefulTime(6) : e < a.civilDusk ? i.setUsefulTime(7) : e < a.nauticalDusk ? i.setUsefulTime(8) : e < a.astronomicalDusk ? i.setUsefulTime(9) : i.setUsefulTime(0)
        }, this.paramData = ko.observable("[No location data available]"), this.paramErrorVisible = !1, this.paramDataChanged = ko.observable(!1), this.paramDataEdited = function () {
            i.paramDataChanged(!0), i.paramErrorVisible && ($("#modal-data-alert").addClass("hidden"), i.paramErrorVisible = !1)
        }, this.formatParamData = function (e) {
            appData.updateDataFromModel(), !e && jsonEditor ? jsonEditor.setText(JSON.stringify(appData, null, "    ")) : i.paramData(JSON.stringify(appData, null, "    ")), i.paramDataChanged(!1)
        }, this.showTextMode = function () {
            jsonEditor && ("text" != jsonEditor.getMode() ? jsonEditor.setMode("text") : jsonEditor.setMode("tree"))
        }, this.shareParamDataAsURI = function () {
            var e = document.location, a = e.protocol + "//" + e.host + e.pathname,
                t = activeModal ? jsonEditor ? jsonEditor.get() : JSON.parse(i.paramData()) : appData,
                o = a + "?earthsun=" + pdDOM.jsonToURI(t),
                r = prompt("Opening the following URL in a new browser page will generate the same model and settings:", o);
            r && r.length > 0 && window.open(o, "_blank")
        }, this.showSaveSettings = function () {
            p.SaveAs.title("Save Settings"), p.SaveAs.message("Enter the filename to save your current model settings as:"), p.SaveAs.filename("earthsun-" + pd.DateTime.generateDateSuffix() + ".json"), p.SaveAs.action(a), p.SaveAs.extension(".json"), p.SaveAs.open()
        }, this.processParamData = function (e) {
            appData.readAppData(e), i.latitude(appData.location.latitude), i.longitude(appData.location.longitude), i.timezone(appData.location.timezone), i.dayOfYear(solar.calcDayOfYearIndex(appData.datetime.dayOfMonth, appData.datetime.monthOfYear, appData.datetime.year)), i.timeOfDay(60 * appData.datetime.clockTime), solar.year(appData.datetime.year), i.dayOfYear.valueHasMutated(), p.Components.sunPath(appData.orbit.showSunPath), p.Components.subSolarIndicators(appData.orbit.showSubSolar), p.Components.twilightBands(appData.orbit.showTwilight), p.Components.equatorLine(appData.orbit.showEquator), p.Components.tropicsLines(appData.orbit.showTropics), p.Components.circleLines(appData.orbit.showCircles), p.Components.viewType(appData.orbit.viewType), p.Animation.animateTime(appData.animation.animateTime), p.Animation.animateDate(appData.animation.animateDate), p.Animation.animateLatitude(appData.animation.animateLatitude), p.Animation.animateLongitude(appData.animation.animateLongitude), p.Animation.speed(appData.animation.speed)
        }, this.parseParamData = function () {
            try {
                var e = jsonEditor ? jsonEditor.get() : JSON.parse(i.paramData());
                i.processParamData(e), $("#modal-data").modal("hide")
            } catch (e) {
                var a = "Editor contains invalid JSON data.";
                null != activeModal ? ($("#modal-data-error").text(a), $("#modal-data-alert").removeClass("hidden"), i.paramErrorVisible = !0) : window.alert("ERROR: " + a)
            }
        }, this.selectSettingsFile = function () {
            i.selectFile("text/*,application/json")
        }, this.selectFile = function (e) {
            var a = document.getElementById("modal-data-file");
            e && e.length > 0 && (a.accept = e);
            try {
                a.value = null, a.value && (a.type = "text", a.type = "file")
            } catch (e) {
            }
            a.click()
        }, this.importFile = function (e) {
            if (window.FileReader && null != e && e.length > 0) {
                var a = e[0];
                if (/text|json|javascript/i.test(a.type)) {
                    var t = new FileReader;
                    t.onload = function (e) {
                        jsonEditor ? jsonEditor.setText(t.result) : i.paramData(t.result), null != activeModal ? (i.paramDataChanged(!0), $("#file-drop-box-label").html("File successfully loaded: <em>" + a.name + "</em>"), jsonEditor && jsonEditor.focus()) : i.parseParamData()
                    }, t.readAsText(a)
                } else {
                    var o = "File does not contain a recognisable data format.";
                    null != activeModal ? ($("#modal-data-error").text(o), $("#modal-data-alert").removeClass("hidden"), i.paramErrorVisible = !0) : window.alert("ERROR: " + o)
                }
            }
        }, this.storeSettings = function () {
            !0 === confirm("This will store your current location and settings as your initial start-up configuration.\n\nAre you sure?") && appData.writeToLocalStorage()
        }, this.clearSettings = function () {
            !0 === confirm("This will remove any stored start-up configuration data and return to original default values.\n\nAre you sure?") && appData.clearLocalStorage()
        }, this.detailMode = ko.observable(!1), this.detailMode.subscribe(function (e) {
            svgSlider.detailMode(!!e)
        }), this.sliderWrap = ko.observable(!0), this.sliderWrap.subscribe(function (e) {
            svgSlider.wrap(e)
        }), this.sliderShow = ko.observable(!0), this.sliderShow.subscribe(function (e) {
            svgSlider.show(e)
        }), this.toggleSlider = function () {
            i.sliderShow(!i.sliderShow()), $("#btn-slider-title").blur()
        }, this.sliderValue = ko.observable(2), this.sliderValue.subscribe(function (e) {
            switch (parseInt(e, 10)) {
                case 0:
                    svgSlider.set({
                        observable: App.Shadows.latitude,
                        type: svgSlider.TYPE_NUMERIC,
                        format: formatSliderAngle,
                        title: "纬 度\n位 置",
                        tickMajor: 15,
                        tickMinor: 5,
                        stepMajor: 15,
                        stepMinor: 1,
                        wrap: !1,
                        min: -90,
                        max: 90,
                        step: .1
                    });
                    break;
                case 1:
                    svgSlider.set({
                        observable: App.Shadows.longitude,
                        type: svgSlider.TYPE_NUMERIC,
                        format: formatSliderAngle,
                        title: "经 度\n位 置",
                        tickMajor: 15,
                        tickMinor: 5,
                        stepMajor: 15,
                        stepMinor: 1,
                        wrap: i.sliderWrap(),
                        min: -180,
                        max: 180,
                        step: .1
                    });
                    break;
                case 2:
                    svgSlider.set({
                        observable: App.Shadows.dayOfYear,
                        type: svgSlider.TYPE_DATE,
                        format: formatDate,
                        title: "\n日期",
                        year: solar.year(),
                        tickMajor: 28,
                        tickMinor: 7,
                        stepMajor: 10,
                        stepMinor: 1,
                        wrap: i.sliderWrap(),
                        min: 0,
                        max: 364,
                        step: 1
                    });
                    break;
                case 3:
                    svgSlider.set({
                        observable: App.Shadows.timeOfDay,
                        type: svgSlider.TYPE_TIME,
                        format: formatTime,
                        title: "\n时刻",
                        tickMajor: 60,
                        tickMinor: 15,
                        stepMajor: 60,
                        stepMinor: 5,
                        wrap: i.sliderWrap(),
                        min: 0,
                        max: 1440,
                        step: 1
                    })
            }
        }), this.setSlider = function (e) {
            i.sliderValue(e)
        }
    }

    function l() {
        function e(e) {
            if (r.pause()) return !1;
            var t, c = !1, d = Math.max(1, parseFloat(r.speed()));
            if (d > 10 && (d = pd.mapAndConstrainTo(d - 10, 0, 10, 10, 200)), r.animateTime()) {
                var u = +p.Shadows.timeOfDay();
                Math.abs(u - l) > 1.01 && (l = u), (t = l += .25 * d) >= 1440 && r.animateDate() && (p.Shadows.setDayOfYear(+p.Shadows.dayOfYear() + 1), solar.setDayOfYear(s = +p.Shadows.dayOfYear()), solarEquator.setDayOfYear(solar.dayOfYear()), t = l = 0), p.Shadows.timeOfDay(pd.wrapAt(t, 0, 1440)), i(), c = !0
            } else if (r.animateDate()) {
                var m = +p.Shadows.dayOfYear();
                Math.abs(m - s) > 1.01 && (s = m);
                var h = Math.floor(s += .025 * d);
                h != p.Shadows.dayOfYear() && (p.Shadows.setDayOfYear(h), i(), c = !0)
            }
            return r.animateLatitude() && ((t = pd.snapTo(solar.latitude() + .01 * d * n, .01)) < -89.8 && (n = 1, t = -90), t > 89.8 && (n = -1, t = 90), p.Shadows.latitude(t), a(), c = !0), r.animateLongitude() && (p.Shadows.longitude(pd.snapTo(pd.wrapAt(solar.longitude() + .01 * d, -180, 180), .01)), a(), c = !0), c && gl.update(), !r.playing() && (o(), !0)
        }

        function t() {
            $("#btn-play-icon").attr("class", "icon icon-stop"), $("#btn-play").toggleClass("btn-default", !1).toggleClass("btn-info", !0).toggleClass("active", !0), s = +p.Shadows.dayOfYear(), l = +p.Shadows.timeOfDay(), gl.animationQueue.add(e), r.playing(!0)
        }

        function o() {
            $("#btn-play-icon").attr("class", "icon icon-play"), $("#btn-play").toggleClass("btn-default", !0).toggleClass("btn-info", !1).toggleClass("active", !1), r.playing(!1)
        }

        var r = this;
        r.pause = ko.observable(!1), r.playing = ko.observable(!1), r.animateTime = ko.observable(appData.animation.animateTime), r.animateDate = ko.observable(appData.animation.animateDate), r.animateLatitude = ko.observable(appData.animation.animateLatitude), r.animateLongitude = ko.observable(appData.animation.animateLongitude), r.speed = ko.observable(appData.animation.speed), r.canAnimate = ko.computed(function () {
            return r.animateTime() || r.animateDate() || r.animateLatitude() || r.animateLongitude()
        }, this);
        var n = 1, s = 0, l = 0;
        r.rewind = function () {
            r.animateTime() && p.Shadows.timeOfDay(0), r.animateDate() && p.Shadows.dayOfYear(0), r.animateLatitude() && p.Shadows.latitude(-90), r.animateLongitude() && p.Shadows.longitude(-180)
        }, r.play = function () {
            r.playing(!r.playing()), r.playing() ? t() : o()
        }, r.faster = function () {
            r.speed(r.speed() + 2), r.canAnimate() && !r.playing() && t()
        }, r.stop = function () {
            r.playing(!1)
        }
    }

    function c() {
        function e(e) {
            var n = {mapTypeId: google.maps.MapTypeId.ROADMAP, center: e, zoom: 6};
            t = new google.maps.Map(document.getElementById("mapCanvas"), n), o = new google.maps.Marker({
                position: e,
                title: "Selected Location",
                draggable: !0,
                map: t
            }), google.maps.event.addListener(t, "click", function (e) {
                r.markerPosition(e.latLng)
            }), google.maps.event.addListener(o, "dragend", function () {
                r.markerPosition(o.getPosition())
            }), google.maps.event.addListener(o, "position_changed", function () {
                r.dynamicMarkerPosition(o.getPosition())
            });
            var s = document.getElementById("pac-input");
            t.controls[google.maps.ControlPosition.TOP_LEFT].push(s);
            var l = new google.maps.places.SearchBox(s);
            google.maps.event.addListener(l, "places_changed", function () {
                var e = l.getPlaces();
                if (a(), 0 != e.length) {
                    if (1 == e.length && e[0].geometry) return r.markerPosition(e[0].geometry.location), void t.panTo(o.getPosition());
                    for (var n, s = new google.maps.LatLngBounds, c = 0; n = e[c]; c++) {
                        var p = {
                            url: n.icon,
                            size: new google.maps.Size(71, 71),
                            origin: new google.maps.Point(0, 0),
                            anchor: new google.maps.Point(17, 34),
                            scaledSize: new google.maps.Size(25, 25)
                        }, d = new google.maps.Marker({
                            map: t,
                            icon: p,
                            draggable: !0,
                            title: n.name,
                            position: n.geometry.location
                        });
                        s.extend(n.geometry.location), i.push(d)
                    }
                    t.fitBounds(s)
                }
            })
        }

        function a() {
            for (var e, a = 0; e = i[a]; a++) e.setMap(null);
            i = []
        }

        var t = null, i = [], o = null, r = this;
        this.markerPosition = ko.undoableObservable(), this.markerPosition.subscribe(function (e) {
            if (o.setPosition(e), r.dynamicMarkerPosition(e), t) {
                var a = t.getBounds();
                a && !a.contains(e) && t.panTo(e)
            }
        }), this.dynamicMarkerPosition = ko.observable(), this.dynamicMarkerPosition.formatter = ko.pureComputed(function () {
            var e = r.dynamicMarkerPosition();
            return "google" in window ? (e || (e = new google.maps.LatLng(solar.latitude(), solar.longitude())), e.lat().toFixed(8) + "°, " + e.lng().toFixed(8) + "°") : solar.latitude().toFixed(8) + "°, " + solar.longitude().toFixed(8) + "°"
        }), this.initialise = function () {
            $("#modal-map").on("shown.bs.modal", function () {
                var a = new google.maps.LatLng(solar.latitude(), solar.longitude());
                t || e(a), t.setCenter(a), google.maps.event.trigger(t, "resize"), r.markerPosition(a), r.markerPosition.reset()
            }).on("hidden.bs.modal", function () {
                a(), activeModal = null
            })
        }, this.applyChanges = function () {
            var e = o.getPosition();
            App.Shadows.longitude(e.lng()), App.Shadows.latitude(e.lat())
        }
    }

    var p = this;
    this.resetValue = function (e, a) {
        e && (e.undoIgnore = !0, e(a), e.undoIgnore = !1)
    };
    var d = 25, u = null, m = null, h = !1;
    this.SaveAs = new o, this.Components = new r, this.Camera = new n, this.Shadows = new s, this.Animation = new l, this.ModalMap = new c
}

function getGeoLocation() {
    if (navigator.geolocation) {
        buttonLocationText = $buttonLocation.val(), $buttonLocation.val("Requesting location..."), disableElement("#button-location");
        var e = {maximumAge: 6e4, timeout: 1e4, enableHighAccuracy: !0};
        navigator.geolocation.getCurrentPosition(getGeoLocationSuccess, getGeoLocationError, e)
    } else alert("This browser does not support HTML5 GeoLocation.")
}

function getGeoLocationError(e) {
    var a = "";
    switch (e.code) {
        case e.PERMISSION_DENIED:
            a = "Permission to access GeoLocation data was denied.";
            break;
        case e.POSITION_UNAVAILABLE:
            a = "GeoLocation data is currently unavailable.";
            break;
        case e.TIMEOUT:
            a = "Your request for GeoLocation data timed out.";
            break;
        case e.UNKNOWN_ERROR:
            a = "An unknown error occurred when obtaining GeoLocation data."
    }
    alert("ERROR: " + a), $buttonLocation.val(buttonLocationText), enableElement("#button-location")
}

function getGeoLocationSuccess(e) {
    App.Shadows.latitude(e.coords.latitude), App.Shadows.longitude(e.coords.longitude), $buttonLocation.val(buttonLocationText), enableElement("#button-location")
}

function disableElement(e) {
    var a = $(e);
    a.prop("disabled", !0), a.attr("disabled", "disabled"), a.css("opacity", .5)
}

function enableElement(e) {
    var a = $(e);
    a.prop("disabled", !1), a.removeAttr("disabled"), a.css("opacity", 1)
}

function updateResponsiveLayout() {
    var e = pdDOM.getClientWidth(), a = pdDOM.getClientHeight();
    a < 525 ? (pageZoom = pd.mapAndConstrainTo(a, 300, 525, .56, 1), e < 675 && (pageZoom = Math.min(pageZoom, pd.mapAndConstrainTo(e, 480, 675, .69, 1)))) : pageZoom = e < 675 ? pd.mapAndConstrainTo(e, 480, 675, .69, 1) : 1, $(".btn-optional").css("display", e < 725 ? "none" : "inline-block"), $("#footer-toolbar").css("margin-top", e < 470 ? "-74px" : "-40px"), (pageZoom < .9999 || pdDOM.pageScale > 1.0001) && ($("html").css("zoom", pageZoom), pdDOM.pageScale = 1 / pageZoom, pdDOM.applyFirefoxPageScaleFix($("body"), e, a, pageZoom), a *= pdDOM.pageScale, e *= pdDOM.pageScale), document.getElementById("overlay-info").style.top = topbotOverlayHeight + "px", document.getElementById("overlay-header").style.width = e + "px";
    var t = document.getElementById("overlay-footer");
    t.style.width = e + "px", t.style.top = a + "px";
    var i = a - topbotOverlayHeight - topbotOverlayHeight - 2 * sliderOverlayPadding,
        o = document.getElementById("overlay-slider");
    o.setAttribute("viewBox", "0 0 110 " + i), o.style.left = e - 110 - sliderOverlayPadding + "px", o.style.top = topbotOverlayHeight + sliderOverlayPadding + "px", o.style.height = i + "px", svgSlider.rescale(), pdDOM.isMobile && (pdDOM.isiOS || pdDOM.isAndroid) && setTimeout(function () {
        window.scrollTo(0, 1)
    }, 0), pdDOM.setFullSizeCanvasByDevice(gl, pdDOM.getClientWidth(), pdDOM.getClientHeight(), $.snackbar), gl.orbitalView && gl.orbitalView.applyProjection(), gl.onresize && gl.onresize(), gl.update()
}

var appData = {
    location: {latitude: 54.15197, longitude: -4.48524, timezone: 0},
    datetime: {clockTime: 10.5, dayOfMonth: 21, monthOfYear: 2, year: (new Date).getFullYear()},
    display: {surfaceOpacity: 1, surfaceShininess: 75, ambientFactor: .1},
    orbit: {
        viewType: 0,
        showSunPath: !0,
        showSubSolar: !1,
        showTwilight: !1,
        showEquator: !0,
        showTropics: !1,
        showCircles: !1,
        showSeasons: !0
    },
    animation: {animateTime: !0, animateDate: !0, animateLatitude: !1, animateLongitude: !1, speed: 10},
    updateDataFromModel: function () {
        this.location.latitude = solar.latitude(), this.location.longitude = solar.longitude(), this.location.timezone = solar.timezone(), this.datetime.clockTime = solar.clockTime(), this.datetime.dayOfMonth = solar.dayOfMonth(), this.datetime.monthOfYear = solar.monthOfYear(), this.datetime.year = solar.year(), this.animation.animateTime = App.Animation.animateTime(), this.animation.animateDate = App.Animation.animateDate(), this.animation.animateLatitude = App.Animation.animateLatitude(), this.animation.animateLongitude = App.Animation.animateLongitude(), this.animation.speed = +App.Animation.speed()
    },
    readAppData: function (e) {
        if ("location" in e) {
            var a = e.location;
            "latitude" in a && pd.isNumeric(a.latitude) && (this.location.latitude = pd.constrainTo(parseFloat(a.latitude), -90, 90)), "longitude" in a && pd.isNumeric(a.longitude) && (this.location.longitude = pd.constrainTo(parseFloat(a.longitude), -180, 180)), "timezone" in a && pd.isNumeric(a.timezone) && (this.location.timezone = pd.constrainTo(parseFloat(a.timezone), -13, 13))
        }
        if ("datetime" in e) {
            var t = e.datetime;
            "clockTime" in t && pd.isNumeric(t.clockTime) && (this.datetime.clockTime = pd.constrainTo(parseFloat(t.clockTime), 0, 24)), "dayOfMonth" in t && pd.isNumeric(t.dayOfMonth) && (this.datetime.dayOfMonth = pd.constrainTo(parseInt(t.dayOfMonth, 10), 0, 31)), "monthOfYear" in t && pd.isNumeric(t.monthOfYear) && (this.datetime.monthOfYear = pd.constrainTo(parseInt(t.monthOfYear, 10), 0, 11)), "year" in t && pd.isNumeric(t.year) && (this.datetime.year = parseInt(t.year, 10))
        }
        if ("display" in e) {
            var i = e.display;
            "surfaceOpacity" in i && pd.isNumeric(i.surfaceOpacity) && (this.display.surfaceOpacity = pd.constrainTo(parseFloat(i.surfaceOpacity), 0, 1)), "outlineOpacity" in i && pd.isNumeric(i.outlineOpacity) && (this.display.outlineOpacity = pd.constrainTo(parseFloat(i.outlineOpacity), 0, 1)), "surfaceShininess" in i && pd.isNumeric(i.surfaceShininess) && (this.display.surfaceShininess = pd.constrainTo(parseFloat(i.surfaceShininess), 0, 500)), "ambientFactor" in i && pd.isNumeric(i.ambientFactor) && (this.display.ambientFactor = pd.constrainTo(parseFloat(i.ambientFactor), 0, 1))
        }
        if ("orbit" in e) {
            var o = e.orbit;
            "viewType" in o && pd.isNumeric(o.viewType) && (this.orbit.viewType = parseInt(o.viewType, 10)), "showSunPath" in o && (this.orbit.showSunPath = "true" === String(o.showSunPath)), "showSubSolar" in o && (this.orbit.showSubSolar = "true" === String(o.showSubSolar)), "showTwilight" in o && (this.orbit.showTwilight = "true" === String(o.showTwilight)), "showEquator" in o && (this.orbit.showEquator = "true" === String(o.showEquator)), "showTropics" in o && (this.orbit.showTropics = "true" === String(o.showTropics)), "showCircles" in o && (this.orbit.showCircles = "true" === String(o.showCircles)), "showSeasons" in o && (this.orbit.showSeasons = "true" === String(o.showSeasons))
        }
        if ("animation" in e) {
            var r = e.animation;
            "animateTime" in r && (this.animation.animateTime = "true" === String(r.animateTime)), "animateDate" in r && (this.animation.animateDate = "true" === String(r.animateDate)), "animateLatitude" in r && (this.animation.animateLatitude = "true" === String(r.animateLatitude)), "animateLongitude" in r && (this.animation.animateLongitude = "true" === String(r.animateLongitude)), "speed" in r && !isNaN(r.speed) && (this.animation.speed = pd.constrainTo(parseFloat(r.speed), 0, 20))
        }
    },
    readFromLocalStorage: function () {
        var e = pdDOM.getLocalStorageItem("appConfig");
        if (e) {
            var a = JSON.parse(e);
            this.readAppData(a)
        }
    },
    writeToLocalStorage: function () {
        this.updateDataFromModel(), pdDOM.setLocalStorageItem("appConfig", JSON.stringify(this))
    },
    clearLocalStorage: function () {
        this.updateDataFromModel(), pdDOM.removeLocalStorageItems(["appConfig"])
    }
};
appData.readFromLocalStorage();
var urlData = pdDOM.getUrlParams().locData;
urlData && urlData.length && appData.readAppData(pdDOM.uriToJSON(urlData)), delete urlData;
var jsonEditor = null,
    solar = new pd.SolarPosition({interpolateDeclination: !0}).setLocation(appData.location.latitude, appData.location.longitude, appData.location.timezone);
solar.setDayMonthYear(appData.datetime.dayOfMonth, appData.datetime.monthOfYear, appData.datetime.year).setTimeOfDay(appData.datetime.clockTime);
var currentSunPos = solar.getSunAnglesArray(),
    solarEquator = new pd.SolarPosition({interpolateDeclination: !0}).setLocation(0, solar.longitude(), solar.timezone());
solarEquator.setDayMonthYear(21, 2, 2014).setTimeOfDay(10.5);
var gl = null;
try {
    gl = GL.create({
        canvas: document.getElementById("canvas"),
        alpha: pdDOM.isMacintosh && pdDOM.isSafari && !pdDOM.isSafariOldVersion,
        antialias: !0
    })
} catch (e) {
    throw $("#loading-message-title").html("ERROR: " + e.toString()).addClass("error"), new Error("WebGL not supported by this browser:\n" + e.toString())
}
pd3D.Font.lineSpacing(1), pd3D.Font.aspectRatio(1.5), pd3D.Font.weight(500);
var App = new AppViewModel, outlineWidth = 1.1,
    lineShader = GL.Material.VariableColorUniformPointSize({uniforms: {color: [1, 1, 1, 1]}}),
    outlineShader = GL.Material.FixedColorUniformPointSize({uniforms: {color: [.74902, .84314, 1, .2]}}),
    textureDaylight = null, textureNightime = null, textureSun = null, $snackbarTexture = null,
    earthMesh = pd3D.Shapes.sphereLatLng({
        radius: 3.5,
        increment: 5,
        graticule: 2,
        center: [0, 0, 0],
        defaultColor: [1, 1, 1, 1],
        normals: !0,
        coords: !0,
        lines: !0
    }),
    earthShader = new GL.Shader("\nuniform vec4 color;\nuniform vec3 lightPosition;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec4 vTexCoords;\nvarying vec3 vLight;\nvarying vec4 vColor;\n\nvoid main() {\n    \n    vColor = color;\n    \n    vTexCoords = gl_TexCoord;\n    \n    vec4 vtx = gl_ModelViewMatrix * gl_Vertex;\n    vVertex = vec3(vtx) / vtx.w;\n    \n    vNormal = gl_NormalMatrix * gl_Normal;\n    vLight = lightPosition - vVertex;\n    \n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n    \n}\n", "\nuniform float opacity;\nuniform float shininess;\nuniform vec3 specularColor;\nuniform vec3 ambientColor;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float twilightBands;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec4 vTexCoords;\nvarying vec3 vLight;\nvarying vec4 vColor;\n\nvoid main() {\n\n    float diffuse = 0.0;\n    float specular = 0.0;\n    vec3 normal = normalize(vNormal);\n    vec3 lightDir = normalize(vLight);\n    float lambertian = dot(lightDir, normal);\n    if (lambertian > 0.0) {\n        vec3 viewDir = normalize(-vVertex);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(normal, halfDir), 0.0);\n        specular = pow(specAngle, shininess);\n        diffuse = lambertian;\n    } else {\n        diffuse = lambertian * 0.25;\n    }\n\n    vec3 color3 = ((ambientColor * vColor.rgb) + (diffuse * vColor.rgb) + (specular * specularColor));\n\n    if ((twilightBands > 1e-5) && (lambertian >= -0.309017)) {\n        if (lambertian < -0.2079117) color3 += twilightBands * vec3(0.0, 0.2, 0.4);\n        else if (lambertian < -0.1045285) color3 += twilightBands * vec3(0.2, 0.4, 0.6);\n        else if (lambertian < -0.014543316) color3 += twilightBands * vec3(0.4, 0.6, 0.8);\n        else if (lambertian <= 0.0) color3 += twilightBands * vec3(0.5, 0.7, 0.9);\n        else color3 += twilightBands * (1.0 - diffuse) * 0.75 * vColor.rgb;\n    }\n\n    vec4 color4 = vec4(clamp(color3 , 0.0, 1.0), 1.0) * texture2D(texture1, vTexCoords.xy);\n    if (lambertian < -0.15) color4 += 0.5 * (1.0 - (1.25 * ambientColor.r)) * texture2D(texture2, vTexCoords.xy);\n    else if (lambertian < 0.05) color4 += 2.5 * abs(lambertian - 0.05) * (1.0 - (1.25 * ambientColor.r)) * texture2D(texture2, vTexCoords.xy);\n    gl_FragColor = vec4(clamp(color4, 0.0, 1.0).rgb, clamp((opacity * vColor.a), 0.0, 1.0));\n    \n}\n"),
    atmosphereMesh = pd3D.Shapes.sphereLatLng({
        radius: -3.7,
        graticule: 2,
        increment: 5,
        center: [0, 0, 0],
        defaultColor: [.5, .7, .9, 1],
        normals: !0,
        coords: !1,
        lines: !1
    }),
    atmosphereShader = new GL.Shader("\nuniform vec4 color;\nuniform vec3 lightPosition;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec3 vLight;\nvarying vec4 vColor;\n\nvoid main() {\n\n    vNormal = gl_NormalMatrix * gl_Normal;\n    vec4 vtx = gl_ModelViewMatrix * gl_Vertex;\n    vVertex = vec3(vtx) / vtx.w;\n    vLight = lightPosition - vVertex;\n    vColor = color;\n\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n\n}\n", "\nuniform float opacity;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec3 vLight;\nvarying vec4 vColor;\n\nvoid main() {\n\n    vec3 normal = normalize(vNormal);\n    float lightIncidence = dot(normalize(vLight), normal);\n    float viewIncidence = dot(normalize(vVertex), normal);\n\n    float lambertian = max(1.0 - lightIncidence, 0.0);\n    vec3 incidenceColor = lambertian * vColor.rgb;\n\n    float fresnel = 1.0 - viewIncidence;\n    float incidenceFactor = pow(abs(viewIncidence), 0.25);\n    vec3 fresnelColor = pow(fresnel, 0.75) * vColor.rgb;\n\n    float fadeOut = clamp(pow(incidenceFactor, 6.0) * lambertian * fresnel, 0.0, 1.0);\n\n    gl_FragColor = vec4(clamp((incidenceColor * fresnelColor), 0.0, 1.0), clamp((fadeOut * opacity * vColor.a), 0.0, 1.0));\n\n}\n"),
    sunMesh = pd3D.Shapes.sphereLatLng({
        radius: 7.5,
        increment: 5,
        center: [0, 0, 0],
        defaultColor: [1, 1, .5, 1],
        normals: !0,
        coords: !0
    }),
    sunShader = new GL.Shader("\nuniform vec4 color;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec4 vTexCoords;\nvarying vec4 vColor;\n\nvoid main() {\n\n    vColor = color;\n    vNormal = gl_NormalMatrix * gl_Normal;\n    vec4 vtx = gl_ModelViewMatrix * gl_Vertex;\n    vVertex = vec3(vtx) / vtx.w;\n    vTexCoords = gl_TexCoord;\n\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n\n}\n", "\nuniform float opacity;\nuniform float mixFactor;\nuniform float fuzzFactor;\nuniform sampler2D texture;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec4 vTexCoords;\nvarying vec4 vColor;\n\nvoid main() {\n    vec3 normal = normalize(vNormal);\n    float viewIncidence = dot(normalize(vVertex), normal);\n    float fadeOut = clamp(pow(abs(viewIncidence), fuzzFactor) * (1.0 - viewIncidence), 0.0, 1.0);\n    vec4 color4 = mix(vec4(vColor.rgb, 1.0), texture2D(texture, vTexCoords.xy), mixFactor);\n    gl_FragColor = vec4(clamp(color4.rgb, 0.0, 1.0), clamp((fadeOut * opacity * vColor.a), 0.0, 1.0));\n}\n"),
    sunPath3D = new pdWGL.SunPath3D(gl, {
        colorDiagramLines: [1, 1, 1, .7],
        colorDiagramText: [1, 1, 1, .8],
        center: [0, 0, 0],
        solarPosition: solar,
        timeIncrement: .125,
        dayIncrement: 7,
        arrowStyle: 2.5,
        arrowSize: 2,
        radius: .75
    }), sunPathTransform = new pd3D.MatrixAccumulator,
    siteMesh = new pd3D.Mesh({defaultColor: [1, 0, 0, 1], triangles: !1, lines: !0});
siteMesh.vertices.push([-.15, 0, 0]), siteMesh.vertices.push([-.02, 0, 0]), siteMesh.vertices.push([.15, 0, 0]), siteMesh.vertices.push([.02, 0, 0]), siteMesh.vertices.push([0, -.15, 0]), siteMesh.vertices.push([0, -.02, 0]), siteMesh.vertices.push([0, .15, 0]), siteMesh.vertices.push([0, .02, 0]), siteMesh.lines.push([0, 1]), siteMesh.lines.push([2, 3]), siteMesh.lines.push([4, 5]), siteMesh.lines.push([6, 7]), siteMesh.compile();
var subSolarPath3D = new pdWGL.SubSolar3D(gl, {
    solarPosition: solarEquator,
    timeIncrement: 2 / 60,
    dayIncrement: 2,
    arrowStyle: 3.5,
    radius: 3.5
});
subSolarPath3D.components().baseDiagram.show(appData.orbit.showEquator), subSolarPath3D.components().baseDiagramText.show(appData.orbit.showEquator), subSolarPath3D.components().monthlySunPaths.show(!1), subSolarPath3D.components().currentSunPath.show(appData.orbit.showSubSolar), subSolarPath3D.components().solarArrow.show(appData.orbit.showTwilight || subSolarPath3D.components().currentSunPath.visible), subSolarPath3D.components().solarSphere.show(subSolarPath3D.components().solarArrow.visible), subSolarPath3D.components().declinationPlane.show(appData.orbit.showTwilight), subSolarPath3D.components().twilightLines.show(appData.orbit.showTwilight), subSolarPath3D.components().annualShell.show(appData.orbit.showTropics), subSolarPath3D.components().tropicsLines.show(appData.orbit.showTropics), subSolarPath3D.components().circleLines.show(appData.orbit.showCircles);
var subSolarTransform = new pd3D.MatrixAccumulator,
    polesMesh = new pd3D.Mesh({defaultColor: [1, 1, 1, 1], triangles: !1, lines: !0});
polesMesh.vertices.push([0, 0, 3.5]), polesMesh.vertices.push([0, 0, 5]), polesMesh.vertices.push([0, 0, -3.5]), polesMesh.vertices.push([0, 0, -5]), polesMesh.lines.push([0, 1]), polesMesh.lines.push([2, 3]), polesMesh.compile();
var starFieldRadius = 1e3, starFieldMesh = new pd3D.Mesh({triangles: !1, lines: !1, normals: !1, colors: !1});
starFieldMesh.addVertexBuffer("pointSize", "pointSize"), function () {
    gl.maxLineWidth < 1.5 && (pdDOM.devicePixelRatio = 1);
    for (var e = 0; e < 1500; e++) starFieldMesh.pointSize.push(pd.constrainTo(4.5 * Math.random() - 1, .5, 4) * pdDOM.devicePixelRatio), starFieldMesh.vertices.push(pd3D.Vector.randomDirection().scale(starFieldRadius).toArray());
    starFieldMesh.compile()
}();
var starFieldShader = GL.Material.FixedColorVariablePointSize({uniforms: {color: [1, 1, 1, 1]}}),
    Origin = new pd3D.Vector(0, 0, 0),
    helioMesh = new pd3D.Mesh({defaultColor: [.6, .8, 1, 1], noCullFace: !0, triangles: !0, lines: !0});
subSolarPath3D.generateHeliocentricOrbitPath(helioMesh, 35), helioMesh.compile();
var seasonsMesh = new pd3D.Mesh({defaultColor: [.9, .9, 0, 1], noCullFace: !0, colors: !0, lines: !0});
subSolarPath3D.generateHeliocentricSeasonsMesh(seasonsMesh, 34.5, solar.latitude() < 0);
var orbitalViewFactor = appData.orbit.viewType > .5 ? 1 : 0, twilightBands = appData.orbit.showTwilight ? .5 : 0,
    svgSlider = new pdSVG.Slider({
        elementId: "#overlay-slider",
        observable: App.Shadows.dayOfYear,
        type: 1,
        format: formatDate,
        title: "\n日期",
        tickMajor: 28,
        tickMinor: 7,
        stepMajor: 10,
        stepMinor: 1,
        wrap: App.Shadows.sliderWrap(),
        min: 0,
        max: 364,
        step: 1
    }), sunlightDirection = new pd3D.Vector(1, 1, 1).normalize(), farFieldSunPosition = sunlightDirection.multiply(1e4),
    nearFieldEathPosition = sunlightDirection.multiply(60),
    specularFactor = pd.mapAndConstrainTo(appData.display.surfaceShininess, 0, 50, .02, .25),
    diffuseFactor = 1 - appData.display.ambientFactor, $snackbarTimezone = null;
gl.onkeydown = function (e) {
    if (null != activePopover || null != activeModal) return !1;
    var a = e.keyCode || event.which;
    if (27 == a) return gl.orbitalView.clearInertia(), gl.orbitalView.orbitMode = !0, void(App.Animation.playing() && App.Animation.stop());
    if (70 == a && !gl.orbitalView.isCenter()) return gl.orbitalView.center(), !0;
    if (!e.ctrlKey && !e.altKey && !e.metaKey) {
        if (a > 48 && a < 58) return void(e.shiftKey ? App.Shadows.setUsefulTime(a - 49) : a < 55 ? App.Camera.setViewType(a - 49) : App.Shadows.setUsefulDate(a - 55));
        if (48 == a) return void(e.shiftKey ? App.Shadows.setUsefulTime(9) : App.Shadows.setUsefulDate(3));
        if (71 == a || 103 == a) return void App.Components.viewType(0);
        if (72 == a || 104 == a) return void App.Components.viewType(1);
        if (80 == a || 112 == a) return void App.Animation.play();
        if (84 == a || 116 == a) return void App.Shadows.setNextUsefulTime();
        if (89 == a || 121 == a) return void App.Shadows.setNextUsefulDate()
    }
    return !1
}, gl.onupdate = function (e) {
    if (GL.keyCount) {
        if (null != activePopover || null != activeModal || !gl.orbitalView) return !1;
        var a = e;
        (GL.keys.CapsLock || GL.keys.SHIFT) && (a *= 2.5);
        var t = GL.keys.W || 0, i = GL.keys.S || 0;
        t - i && (gl.orbitalView.orbitMode || (a *= .5), gl.orbitalView.walk(a * (t - i)));
        var o = GL.keys.A || 0, r = GL.keys.D || 0, n = GL.keys.Q || 0, s = GL.keys.Z || 0;
        if (o - r || n || s) {
            u = gl.orbitalView.orbitMode ? 1.5 : .5;
            gl.orbitalView.pan(a * u * (o - r), a * u * (n - s), !0)
        }
        var l = GL.keys.UP || 0, c = GL.keys.DOWN || 0, p = GL.keys.LEFT || 0, d = GL.keys.RIGHT || 0;
        if (l - c || p - d) {
            var u = 40, m = l - c, h = p - d;
            gl.orbitalView.orbitMode || (m = .5 * -m, h = -h), gl.orbitalView.rotate(a * u * h, a * u * m), 5 == App.Camera.viewType() && App.Camera.setViewType(1, !0)
        }
    }
    return !1
}, gl.ondraw = function () {
    if (gl.orbitalView) {
        var e = gl.orbitalView.eyePos;
        if (gl.clearColor(0, 0, 0, 1), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT), gl.orbitalView.apply(!0), gl.enable(gl.BLEND), gl.pushMatrix(), gl.translate(e.x, e.y, e.z), orbitalViewFactor <= .001 ? (gl.multMatrix(subSolarTransform.toMatrix()), gl.multMatrix(subSolarPath3D.relativeSunDirection())) : orbitalViewFactor < .98 && gl.rotate(360 * pd.Easing.inOutSine(1 - orbitalViewFactor), .5, .75, 1), starFieldShader.draw(starFieldMesh, gl.POINTS), gl.popMatrix(), orbitalViewFactor > .001) {
            if (gl.lineWidth(pdDOM.devicePixelRatio), helioMesh.defaultColor[3] = orbitalViewFactor, lineShader.draw(helioMesh, [gl.LINES, gl.TRIANGLES]), appData.orbit.showSeasons) {
                gl.depthMask(!1);
                var a = Math.pow(pd.Easing.inSine(Math.abs(Math.sin(solar.latitude() * pd.Const.DEG2RAD))), .5);
                lineShader.uniform("opacity", appData.display.surfaceOpacity * orbitalViewFactor * a), lineShader.draw(seasonsMesh, [gl.LINES, gl.TRIANGLES]), lineShader.uniform("opacity", 1), gl.depthMask(!0)
            }
            gl.pushMatrix();
            var t = pd.Easing.inOutSine(orbitalViewFactor),
                i = subSolarPath3D.calculateHeliocentricOrbitPosition(solar.dayOfYear(), solar.solarTime(), 35);
            gl.translate(t * i[0], t * i[1], t * i[2]);
            var o = 0;
            o = Math.abs(i[0]) < .001 ? Math.abs(i[1]) < .001 ? 0 : i[1] < 0 ? -90 : 90 : Math.atan2(i[1], i[0]) * pd.Const.RAD2DEG;
            var r = -1.5 * Math.abs(Math.pow(Math.cos((solar.dayOfYear() - 79) / 183 * Math.PI), 3));
            gl.rotate(t * r, 1, 0, 0), gl.rotate(23.44 * t, 0, 1, 0), gl.rotate(t * (solarEquator.clockTimeUTC() / 24 * 360 + o), 0, 0, 1)
        }
        if (outlineWidth > 0 && appData.display.surfaceOpacity < .95 && (gl.depthMask(!1), gl.lineWidth(outlineWidth), outlineShader.drawOutline(earthMesh), gl.depthMask(!0)), subSolarPath3D.drawDiagram(), gl.pushMatrix(), gl.multMatrix(subSolarTransform.toMatrix()), subSolarPath3D.drawSunPosition(), subSolarPath3D.drawSunPathLines(), gl.popMatrix(), gl.pushMatrix(), gl.multMatrix(sunPathTransform.toMatrix()), gl.lineWidth(gl.getCanvasLineWidthThicker()), siteMesh.visible && lineShader.drawOutline(siteMesh), appData.orbit.showSunPath && sunPath3D.drawOutlines(), gl.popMatrix(), gl.lineWidth(4 * outlineWidth), lineShader.drawOutline(polesMesh), earthMesh.visible && appData.display.surfaceOpacity > .001) {
            var n = gl.modelviewMatrix.transformPoint(farFieldSunPosition);
            atmosphereMesh.visible && (gl.depthMask(!1), atmosphereShader.uniforms({
                opacity: appData.display.surfaceOpacity,
                lightPosition: n,
                color: atmosphereMesh.color()
            }).draw(atmosphereMesh, gl.TRIANGLES), gl.depthMask(!0)), textureDaylight || GL.Texture.placeholder().bind(0), textureNightime || GL.Texture.placeholder().bind(1), earthShader.uniforms({
                opacity: appData.display.surfaceOpacity,
                shininess: appData.display.surfaceShininess,
                lightPosition: n,
                specularColor: [specularFactor, specularFactor, specularFactor],
                ambientColor: [appData.display.ambientFactor, appData.display.ambientFactor, appData.display.ambientFactor],
                diffuseColor: [diffuseFactor, diffuseFactor, diffuseFactor],
                twilightBands: twilightBands,
                color: earthMesh.color(),
                texture1: 0,
                texture2: 1
            }).draw(earthMesh, gl.TRIANGLES)
        }
        if (outlineWidth > 0 && (gl.lineWidth(outlineWidth), outlineShader.drawOutline(earthMesh)), gl.pushMatrix(), gl.multMatrix(subSolarTransform.toMatrix()), subSolarPath3D.drawSunSurface(), gl.popMatrix(), appData.orbit.showSunPath && (gl.pushMatrix(), gl.multMatrix(sunPathTransform.toMatrix()), sunPath3D.drawSurfaces(), gl.popMatrix()), orbitalViewFactor > .001 && gl.popMatrix(), sunMesh.visible) {
            textureSun || GL.Texture.placeholder().bind(2), gl.pushMatrix();
            var s = 1 - orbitalViewFactor, l = Math.pow(gl.orbitalView.cameraDistance, .9);
            if (orbitalViewFactor < .99) {
                var c = intersectSphere(e, farFieldSunPosition.negative().subtract(e).normalize(), e, starFieldRadius);
                if (null == c && (c = farFieldSunPosition.unit().scale(starFieldRadius)), l = s * e.distanceTo(c) + orbitalViewFactor * l, orbitalViewFactor < .5 && gl.translate(c.x, c.y, c.z), orbitalViewFactor > .001) {
                    t = orbitalViewFactor > .5 ? pd.mapTo(orbitalViewFactor, .5, 1, 0, .5) : pd.mapTo(s, .5, 1, 0, 1);
                    gl.scale(t, t, t)
                }
            } else gl.scale(.5, .5, .5);
            sunShader.uniforms({
                opacity: 1,
                fuzzFactor: pd.mapAndConstrainTo(l, 15, 100, .5, 25),
                mixFactor: pd.mapAndConstrainTo(l, 15, 100, 1, .1),
                color: sunMesh.color(),
                texture: 2
            }).draw(sunMesh, gl.TRIANGLES), gl.popMatrix()
        }
        gl.disable(gl.BLEND)
    }
};
var activeModal = null, activePopover = null;
$(document).ready(function () {
    if ($('[data-toggle="tooltip"]').tooltip(), $('[data-toggle="popover"]').popover(), $(".popover").on("shown.bs.modal", function (e) {
            activePopover = $(this)
        }).on("hidden.bs.modal", function (e) {
            activePopover = null
        }), $(".modal").on("shown.bs.modal", function (e) {
            activeModal = $(this)
        }).on("hidden.bs.modal", function (e) {
            activeModal = null
        }), $("[data-toggle='modal']").on("click", function (e) {
            closeActivePopover()
        }), $(document).on("mousedown touchstart pointerdown", function (e) {
            null != activePopover && 0 === activePopover.has(e.target).length && (activePopover.popoverX("hide"), e.preventDefault())
        }), $("#popover-view").on("show.bs.modal", function (e) {
            pd.closeTo(App.Camera.viewAzimuth(), gl.orbitalView.cameraAzi, .001) || App.Camera.viewAzimuth(gl.orbitalView.cameraAzi), pd.closeTo(App.Camera.viewAltitude(), gl.orbitalView.cameraAlt, .001) || App.Camera.viewAltitude(gl.orbitalView.cameraAlt), pd.closeTo(App.Camera.viewAngle(), gl.orbitalView.cameraFOV, .001) || App.Camera.viewAngle(gl.orbitalView.cameraFOV)
        }), $("#modal-data").on("show.bs.modal", function (e) {
            if (App.Shadows.paramErrorVisible = !1, $("#file-drop-box-label").text("Drag and drop a JSON file anywhere in the app window to load it."), $("#modal-data-alert").addClass("hidden"), jsonEditor) App.Shadows.formatParamData(); else {
                var a = document.getElementById("jsoneditor");
                a.addEventListener("load", jsonEditorLoaded, !1), a.classList.add("loading"), a.src = "./jsonEditor.html"
            }
        }), pdDOM.enableDragDrop(document.body, App.Shadows.importFile) && $("#file-drop-box").on("click", App.Shadows.selectFile).show(), App.ModalMap.initialise(), $("#loading-message").remove(), $("#overlay-header, #overlay-footer, #overlay-info, #overlay-slider").fadeIn("slow"), setTimeout(function () {
            null == $snackbarTexture && ($snackbarTexture = $.snackbar({
                content: '<img src="imgs/loader.gif" width="24" height="24" style="margin-top: -5px" title="Loading..." /> Loading world map textures, please wait...',
                htmlAllowed: !0,
                timeout: 6e4,
                style: "info"
            }))
        }, 1e3), $(window).resize(function () {
            null != $snackbarTimezone && showTimezoneWarning(!1), updateResponsiveLayout(), activePopover && (pdDOM.isAndroid ? activePopover.popoverX("show") : closeActivePopover())
        }), updateResponsiveLayout(), gl.animate(), gl.useOrbitalView({
            zoomByDollying: !0,
            defaultDistance: 9,
            defaultAzi: solar.longitude() + 30,
            defaultAlt: appData.orbit.viewType > .5 ? 30 : calcBestViewAngle(),
            farFieldMin: 2.5 * starFieldRadius,
            zoomFactorMin: .15
        }), orbitalViewFactor > .5) {
        var e = pd.constrainTo(100 / gl.orbitalView.aspectRatio, 5, 100);
        gl.orbitalView.defaultDistance = gl.orbitalView.cameraDistance = e, subSolarPath3D.arrowScale(2.5)
    }
    gl.disableContextMenu(!0), updateSunPaths(), loadTextureImages(), regenerateShadows(), gl.update(), $("#canvas").focus()
});
var $buttonLocation = $("#button-location"), buttonLocationText = "", pageZoom = 1, topbotOverlayHeight = 40,
    sliderOverlayPadding = 10;
ko.applyBindings(App);
